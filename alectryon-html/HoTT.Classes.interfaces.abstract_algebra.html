<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>abstract_algebra.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk0"><span class="kn">Require Export</span> Basics.Classes Basics.Overture.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Spaces.Nat.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> HoTT.Classes.interfaces.canonical_names.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Modalities.ReflectiveSubuniverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Set Polymorphic Inductive Cumulativity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable Variables</span> <span class="nf">A</span> B C f g x y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* </span>
<span class="c">For various structures we omit declaration of substructures. For example, if we </span>
<span class="c">say:</span>

<span class="c">Class Setoid_Morphism :=</span>
<span class="c">  { setoidmor_a : Setoid A</span>
<span class="c">  ; setoidmor_b : Setoid B</span>
<span class="c">  ; sm_proper : Proper ((=) ==&gt; (=)) f }.</span>
<span class="c">#[export] Existing Instances setoidmor_a setoidmor_b sm_proper.</span>

<span class="c">then each time a Setoid instance is required, Coq will try to prove that a</span>
<span class="c">Setoid_Morphism exists. This obviously results in an enormous blow-up of the</span>
<span class="c">search space. Moreover, one should be careful to declare a Setoid_Morphisms</span>
<span class="c">as a substructure. Consider [f t1 t2], now if we want to perform setoid rewriting</span>
<span class="c">in [t2] Coq will first attempt to prove that [f t1] is Proper, for which it will </span>
<span class="c">attempt to prove [Setoid_Morphism (f t1)]. If many structures declare</span>
<span class="c">Setoid_Morphism as a substructure, setoid rewriting will become horribly slow.</span>
<span class="c">*)</span>

<span class="c">(* An unbundled variant of the former CoRN CSetoid. We do not </span>
<span class="c">  include a proof that A is a Setoid because it can be derived. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsApart</span> <span class="nv">A</span> {<span class="nv">Aap</span> : Apart A} : <span class="kt">Type</span> :=
  { apart_set : IsHSet A
  ; apart_mere : is_mere_relation _ apart
  ; apart_symmetric : Symmetric (‚â∂)
  ; apart_cotrans : CoTransitive (‚â∂)
  ; tight_apart : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, ~(x ‚â∂ y) &lt;-&gt; x = y }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances
  apart_set
  apart_mere
  apart_symmetric
  apart_cotrans.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1"><span class="kn">Global Instance</span> <span class="nf">apart_irrefl</span> `{IsApart A} : Irreflexive (‚â∂).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aap</var><span class="hyp-type"><b>: </b><span>Apart A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsApart A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Irreflexive apart</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aap</var><span class="hyp-type"><b>: </b><span>Apart A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsApart A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Irreflexive apart</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk3"><span class="nb">intros</span> x ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aap</var><span class="hyp-type"><b>: </b><span>Apart A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsApart A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ap</var><span class="hyp-type"><b>: </b><span>x ‚â∂ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk4"><span class="nb">apply</span> (tight_apart x x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aap</var><span class="hyp-type"><b>: </b><span>Apart A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsApart A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ap</var><span class="hyp-type"><b>: </b><span>x ‚â∂ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = x</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aap</var><span class="hyp-type"><b>: </b><span>Apart A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsApart A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ap</var><span class="hyp-type"><b>: </b><span>x ‚â∂ x</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk5"><hr></label><div class="goal-conclusion">x ‚â∂ x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aap</var><span class="hyp-type"><b>: </b><span>Apart A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsApart A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ap</var><span class="hyp-type"><b>: </b><span>x ‚â∂ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aap</var><span class="hyp-type"><b>: </b><span>Apart A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsApart A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>ap</var><span class="hyp-type"><b>: </b><span>x ‚â∂ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ‚â∂ x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> tight_apart {A Aap IsApart} _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">setoid_morphisms</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">Aap</span> : Apart A} {<span class="nv">Bap</span> : Apart B} (<span class="nv">f</span> : A -&gt; B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">StrongExtensionality</span> := strong_extensionality : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, f x ‚â∂ f y -&gt; x ‚â∂ y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">setoid_morphisms</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* HOTT TODO check if this is ok/useful *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (<span class="nl">?f</span> _ = <span class="nl">?f</span> _) =&gt; <span class="nb">eapply</span> (ap f) : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">setoid_binary_morphisms</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} {<span class="nv">Aap</span>: Apart A} 
    {<span class="nv">Bap</span> : Apart B} {<span class="nv">Cap</span> : Apart C} (<span class="nv">f</span> : A -&gt; B -&gt; C).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">StrongBinaryExtensionality</span> := strong_binary_extensionality
    : <span class="kr">forall</span> <span class="nv">x‚ÇÅ</span> <span class="nv">y‚ÇÅ</span> <span class="nv">x‚ÇÇ</span> <span class="nv">y‚ÇÇ</span>, f x‚ÇÅ y‚ÇÅ ‚â∂ f x‚ÇÇ y‚ÇÇ -&gt; hor (x‚ÇÅ ‚â∂ x‚ÇÇ) (y‚ÇÅ ‚â∂ y‚ÇÇ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">setoid_binary_morphisms</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">Since apartness usually only becomes relevant when considering fields (e.g. the </span>
<span class="c">real numbers), we do not include it in the lower part of the algebraic hierarchy</span>
<span class="c">(as opposed to CoRN).</span>
<span class="c">*)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">upper_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Universe</span> <span class="nf">i</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">A</span> : <span class="kt">Type</span>@{i}).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsSemiGroup</span> {<span class="nv">Aop</span>: SgOp A} :=
    { sg_set : IsHSet A
    ; sg_ass : Associative (.*.) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances sg_set sg_ass.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsCommutativeSemiGroup</span> {<span class="nv">Aop</span> : SgOp A} :=
    { comsg_sg : @IsSemiGroup (.*.)
    ; comsg_comm : Commutative (.*.) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances comsg_sg comsg_comm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsSemiLattice</span> {<span class="nv">Aop</span> : SgOp A} :=
    { semilattice_sg : @IsCommutativeSemiGroup (.*.)
    ; semilattice_idempotent : BinaryIdempotent (.*.)}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances semilattice_sg semilattice_idempotent.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsMonoid</span> {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Aunit</span> : MonUnit A} :=
    { monoid_semigroup : IsSemiGroup
    ; monoid_left_id : LeftIdentity (.*.) mon_unit
    ; monoid_right_id : RightIdentity (.*.) mon_unit }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances
    monoid_semigroup
    monoid_left_id
    monoid_right_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsCommutativeMonoid</span> {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Aunit</span> : MonUnit A} :=
    { commonoid_mon : @IsMonoid (.*.) Aunit
    ; commonoid_commutative : Commutative (.*.) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances
    commonoid_mon
    commonoid_commutative.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsGroup</span> {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Aunit</span> : MonUnit A} {<span class="nv">Anegate</span> : Negate A} :=
    { group_monoid : @IsMonoid (.*.) Aunit
    ; negate_l : LeftInverse (.*.) (-) mon_unit
    ; negate_r : RightInverse (.*.) (-) mon_unit }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances 
    group_monoid
    negate_l
    negate_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsBoundedSemiLattice</span> {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Aunit</span> : MonUnit A} :=
    { bounded_semilattice_mon : @IsCommutativeMonoid (.*.) Aunit
    ; bounded_semilattice_idempotent : BinaryIdempotent (.*.)}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances
    bounded_semilattice_mon
    bounded_semilattice_idempotent.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsAbGroup</span> {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Aunit</span> : MonUnit A} {<span class="nv">Anegate</span> : Negate A} :=
    { abgroup_group : @IsGroup (.*.) Aunit Anegate
    ; abgroup_commutative : Commutative (.*.) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances abgroup_group abgroup_commutative.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Close Scope</span> mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">Aplus</span> : Plus A} {<span class="nv">Amult</span> : Mult A} {<span class="nv">Azero</span> : Zero A} {<span class="nv">Aone</span> : One A}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsSemiCRing</span> :=
    { semiplus_monoid : @IsCommutativeMonoid plus_is_sg_op zero_is_mon_unit
    ; semimult_monoid : @IsCommutativeMonoid mult_is_sg_op one_is_mon_unit
    ; semiring_distr : LeftDistribute (.*.) (+)
    ; semiring_left_absorb : LeftAbsorb (.*.) <span class="mi">0</span> }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances semiplus_monoid semimult_monoid semiring_distr semiring_left_absorb.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">Anegate</span> : Negate A}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsRing</span> := {
    ring_abgroup :: @IsAbGroup plus_is_sg_op zero_is_mon_unit _;
    ring_monoid :: @IsMonoid mult_is_sg_op one_is_mon_unit;
    ring_dist_left :: LeftDistribute (.*.) (+);
    ring_dist_right :: RightDistribute (.*.) (+);
  }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsCRing</span> :=
    { cring_group : @IsAbGroup plus_is_sg_op zero_is_mon_unit _
    ; cring_monoid : @IsCommutativeMonoid mult_is_sg_op one_is_mon_unit
    ; cring_dist : LeftDistribute (.*.) (+) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances cring_group cring_monoid cring_dist.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk8"><span class="kn">Global Instance</span> <span class="nf">isring_iscring</span> : IsCRing -&gt; IsRing.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aplus</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>Amult</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>Azero</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>Aone</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>Anegate</var><span class="hyp-type"><b>: </b><span>Negate A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCRing -&gt; IsRing</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aplus</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>Amult</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>Azero</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>Aone</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>Anegate</var><span class="hyp-type"><b>: </b><span>Negate A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsCRing -&gt; IsRing</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chka"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aplus</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>Amult</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>Azero</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>Aone</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>Anegate</var><span class="hyp-type"><b>: </b><span>Negate A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsCRing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsRing</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chkb"><span class="nb">econstructor</span>; <span class="kp">try</span> <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aplus</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>Amult</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>Azero</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>Aone</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>Anegate</var><span class="hyp-type"><b>: </b><span>Negate A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsCRing</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RightDistribute mult plus</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chkc"><span class="nb">intros</span> a b c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aplus</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>Amult</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>Azero</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>Aone</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>Anegate</var><span class="hyp-type"><b>: </b><span>Negate A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsCRing</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a + b) * c = a * c + b * c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chkd">lhs rapply commutativity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aplus</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>Amult</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>Azero</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>Aone</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>Anegate</var><span class="hyp-type"><b>: </b><span>Negate A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsCRing</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op c (a + b) = a * c + b * c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chke">lhs rapply distribute_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aplus</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>Amult</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>Azero</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>Aone</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>Anegate</var><span class="hyp-type"><b>: </b><span>Negate A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsCRing</span></span></span><br><span><var>a, b, c</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">c * a + c * b = a * c + b * c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">f_ap; <span class="nb">apply</span> commutativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsIntegralDomain</span> :=
    { intdom_ring : IsCRing
    ; intdom_nontrivial : PropHolds (not (<span class="mi">1</span> = <span class="mi">0</span>))
    ; intdom_nozeroes : NoZeroDivisors A }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances intdom_nozeroes.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* We do not include strong extensionality for (-) and (/)</span>
<span class="c">    because it can de derived *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsField</span> {<span class="nv">Aap</span>: Apart A} {<span class="nv">Arecip</span>: Recip A} :=
    { field_ring : IsCRing
    ; field_apart : IsApart A
    ; field_plus_ext : StrongBinaryExtensionality (+)
    ; field_mult_ext : StrongBinaryExtensionality (.*.)
    ; field_nontrivial : PropHolds (<span class="mi">1</span> ‚â∂ <span class="mi">0</span>)
    ; recip_inverse : <span class="kr">forall</span> <span class="nv">x</span>, x.<span class="mi">1</span> // x = <span class="mi">1</span> }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances
    field_ring
    field_apart
    field_plus_ext
    field_mult_ext.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="c">(* We let /0 = 0 so properties as Injective (/),</span>
<span class="c">    f (/x) = / (f x), / /x = x, /x * /y = /(x * y) </span>
<span class="c">    hold without any additional assumptions *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsDecField</span> {<span class="nv">Adec_recip</span> : DecRecip A} :=
    { decfield_ring : IsCRing
    ; decfield_nontrivial : PropHolds (<span class="mi">1</span> &lt;&gt; <span class="mi">0</span>)
    ; dec_recip_0 : /<span class="mi">0</span> = <span class="mi">0</span>
    ; dec_recip_inverse : <span class="kr">forall</span> <span class="nv">x</span>, x &lt;&gt; <span class="mi">0</span> -&gt; x / x = <span class="mi">1</span> }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances decfield_ring.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">FieldCharacteristic</span>@{j} {Aap : Apart@{i j} A} (k : nat) : <span class="kt">Type</span>@{j}
    := field_characteristic : <span class="kr">forall</span> <span class="nv">n</span> : nat,
        Nat.Core.lt <span class="mi">0</span> n -&gt;
        iff@{j j j} (<span class="kr">forall</span> <span class="nv">m</span> : nat, not@{j} (paths@{<span class="kt">Set</span>} n
                                                  (nat_mul k m)))
        (@apart A Aap (nat_iter n (<span class="mi">1</span> +) <span class="mi">0</span>) <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">upper_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Due to bug #2528 *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (PropHolds (<span class="mi">1</span> &lt;&gt; <span class="mi">0</span>)) =&gt;
  <span class="nb">eapply</span> @intdom_nontrivial : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">5</span> (PropHolds (<span class="mi">1</span> ‚â∂ <span class="mi">0</span>)) =&gt;
  <span class="nb">eapply</span> @field_nontrivial : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">5</span> (PropHolds (<span class="mi">1</span> &lt;&gt; <span class="mi">0</span>)) =&gt;
  <span class="nb">eapply</span> @decfield_nontrivial : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* </span>
<span class="c">For a strange reason IsCRing instances of Integers are sometimes obtained by</span>
<span class="c">Integers -&gt; IntegralDomain -&gt; Ring and sometimes directly. Making this an</span>
<span class="c">instance with a low priority instead of using intdom_ring:&gt; IsCRing forces Coq to</span>
<span class="c">take the right way </span>
<span class="c">*)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">10</span> (IsCRing _) =&gt; <span class="nb">apply</span> @intdom_ring : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> recip_inverse {A Aplus Amult Azero Aone Anegate Aap Arecip IsField} _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> dec_recip_inverse
  {A Aplus Amult Azero Aone Anegate Adec_recip IsDecField} _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> dec_recip_0 {A Aplus Amult Azero Aone Anegate Adec_recip IsDecField}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">lattice</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> <span class="nv">A</span> {<span class="nv">Ajoin</span>: Join A} {<span class="nv">Ameet</span>: Meet A} {<span class="nv">Abottom</span> : Bottom A} {<span class="nv">Atop</span> : Top A}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsJoinSemiLattice</span> := 
    join_semilattice : @IsSemiLattice A join_is_sg_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Existing Instance</span> <span class="nf">join_semilattice</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsBoundedJoinSemiLattice</span> := 
    bounded_join_semilattice : @IsBoundedSemiLattice A
      join_is_sg_op bottom_is_mon_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Existing Instance</span> <span class="nf">bounded_join_semilattice</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsMeetSemiLattice</span> :=
    meet_semilattice : @IsSemiLattice A meet_is_sg_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Existing Instance</span> <span class="nf">meet_semilattice</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsBoundedMeetSemiLattice</span> :=
    bounded_meet_semilattice : @IsBoundedSemiLattice A
      meet_is_sg_op top_is_mon_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Existing Instance</span> <span class="nf">bounded_meet_semilattice</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsLattice</span> := 
    { lattice_join : IsJoinSemiLattice
    ; lattice_meet : IsMeetSemiLattice
    ; join_meet_absorption : Absorption (‚äî) (‚äì) 
    ; meet_join_absorption : Absorption (‚äì) (‚äî) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances
    lattice_join
    lattice_meet
    join_meet_absorption 
    meet_join_absorption.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsBoundedLattice</span> :=
    { boundedlattice_join : IsBoundedJoinSemiLattice
    ; boundedlattice_meet : IsBoundedMeetSemiLattice
    ; boundedjoin_meet_absorption : Absorption (‚äî) (‚äì)
    ; boundedmeet_join_absorption : Absorption (‚äì) (‚äî)}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances
    boundedlattice_join
    boundedlattice_meet
    boundedjoin_meet_absorption
    boundedmeet_join_absorption.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsDistributiveLattice</span> := 
    { distr_lattice_lattice : IsLattice
    ; join_meet_distr_l : LeftDistribute (‚äî) (‚äì) }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances distr_lattice_lattice join_meet_distr_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">lattice</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">morphism_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sgmorphism_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Bop</span> : SgOp B}
    {<span class="nv">Aunit</span> : MonUnit A} {<span class="nv">Bunit</span> : MonUnit B}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsSemiGroupPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    preserves_sg_op : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, f (x * y) = f x * f y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsUnitPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    preserves_mon_unit : f mon_unit = mon_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsMonoidPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    { monmor_sgmor : IsSemiGroupPreserving f
    ; monmor_unitmor : IsUnitPreserving f }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances monmor_sgmor monmor_unitmor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sgmorphism_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">ringmorphism_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">Aplus</span> : Plus A} {<span class="nv">Bplus</span> : Plus B}
    {<span class="nv">Amult</span> : Mult A} {<span class="nv">Bmult</span> : Mult B} {<span class="nv">Azero</span> : Zero A} {<span class="nv">Bzero</span> : Zero B}
    {<span class="nv">Aone</span> : One A} {<span class="nv">Bone</span> : One B}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsSemiRingPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    { semiringmor_plus_mor : @IsMonoidPreserving A B
        plus_is_sg_op plus_is_sg_op zero_is_mon_unit zero_is_mon_unit f
    ; semiringmor_mult_mor : @IsMonoidPreserving A B
        mult_is_sg_op mult_is_sg_op one_is_mon_unit one_is_mon_unit f }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances semiringmor_plus_mor semiringmor_mult_mor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">Aap</span> : Apart A} {<span class="nv">Bap</span> : Apart B}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsSemiRingStrongPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    { strong_semiringmor_sr_mor : IsSemiRingPreserving f
    ; strong_semiringmor_strong_mor : StrongExtensionality f }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances strong_semiringmor_sr_mor strong_semiringmor_strong_mor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">ringmorphism_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">latticemorphism_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">Ajoin</span> : Join A} {<span class="nv">Bjoin</span> : Join B}
    {<span class="nv">Ameet</span> : Meet A} {<span class="nv">Bmeet</span> : Meet B}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsJoinPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    join_slmor_sgmor : @IsSemiGroupPreserving A B join_is_sg_op join_is_sg_op f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances join_slmor_sgmor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsMeetPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    meet_slmor_sgmor : @IsSemiGroupPreserving A B meet_is_sg_op meet_is_sg_op f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances meet_slmor_sgmor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">Abottom</span> : Bottom A} {<span class="nv">Bbottom</span> : Bottom B}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsBoundedJoinPreserving</span> (<span class="nv">f</span> : A -&gt; B) := bounded_join_slmor_monmor
      : @IsMonoidPreserving A B join_is_sg_op join_is_sg_op
         bottom_is_mon_unit bottom_is_mon_unit f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances bounded_join_slmor_monmor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsLatticePreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    { latticemor_join_mor : IsJoinPreserving f
    ; latticemor_meet_mor : IsMeetPreserving f }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">#[export] Existing Instances
    latticemor_join_mor
    latticemor_meet_mor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">latticemorphism_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">morphism_classes</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">id_mor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{SgOp A} `{MonUnit A}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chkf"><span class="kn">Global Instance</span> <span class="nf">id_sg_morphism</span> : IsSemiGroupPreserving (@id A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk11"><span class="kn">Global Instance</span> <span class="nf">id_monoid_morphism</span> : IsMonoidPreserving (@id A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsMonoidPreserving id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsMonoidPreserving id</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="nb">split</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">id_mor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">compose_mor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{SgOp A} `{MonUnit A}
    `{SgOp B} `{MonUnit B}
    `{SgOp C} `{MonUnit C}
    (f : A -&gt; B) (g : B -&gt; C).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Making these global instances causes typeclass loops.  Instead they are declared below as [Hint Extern]s that apply only when the goal has the specified form. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk13"><span class="kn">Local Instance</span> <span class="nf">compose_sg_morphism</span> : IsSemiGroupPreserving f -&gt; IsSemiGroupPreserving g -&gt;
    IsSemiGroupPreserving (g ‚àò f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving f -&gt;
IsSemiGroupPreserving g -&gt;
IsSemiGroupPreserving (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving f -&gt;
IsSemiGroupPreserving g -&gt;
IsSemiGroupPreserving (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk15"><span class="nb">red</span>; <span class="nb">intros</span> fp gp x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>gp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g ‚àò f) (sg_op x y) = sg_op ((g ‚àò f) x) ((g ‚àò f) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk16"><span class="nb">unfold</span> Compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>gp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (f (sg_op x y)) = sg_op (g (f x)) (g (f y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk17"><span class="nb">refine</span> ((ap g _) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>gp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (sg_op x y) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk18" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>gp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk18"><hr></label><div class="goal-conclusion">g <span class="nl">?Goal</span> = sg_op (g (f x)) (g (f y))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk19">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>gp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (sg_op x y) = <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> fp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>gp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving g</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (sg_op (f x) (f y)) = sg_op (g (f x)) (g (f y))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> gp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1b"><span class="kn">Local Instance</span> <span class="nf">compose_monoid_morphism</span> : IsMonoidPreserving f -&gt; IsMonoidPreserving g -&gt;
    IsMonoidPreserving (g ‚àò f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsMonoidPreserving f -&gt;
IsMonoidPreserving g -&gt; IsMonoidPreserving (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsMonoidPreserving f -&gt;
IsMonoidPreserving g -&gt; IsMonoidPreserving (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1d"><span class="nb">intros</span>;<span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (g ‚àò f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving g</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk1e"><hr></label><div class="goal-conclusion">IsUnitPreserving (g ‚àò f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsUnitPreserving (g ‚àò f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk21"><span class="nb">red</span>;<span class="nb">unfold</span> Compose.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (f mon_unit) = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk22"><span class="nb">etransitivity</span>;[|<span class="nb">apply</span> (preserves_mon_unit (f:=g))].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SgOp C</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>MonUnit C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br><span><var>X0</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (f mon_unit) = g mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap,preserves_mon_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">compose_mor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">invert_mor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
    `{SgOp A} `{MonUnit A}
    `{SgOp B} `{MonUnit B}
    (f : A -&gt; B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk23"><span class="kn">Local Instance</span> <span class="nf">invert_sg_morphism</span>
    : <span class="kr">forall</span> `{!IsEquiv f}, IsSemiGroupPreserving f -&gt;
      IsSemiGroupPreserving (f^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">IsEquiv0</span> : IsEquiv f,
IsSemiGroupPreserving f -&gt; IsSemiGroupPreserving f^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk24"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">IsEquiv0</span> : IsEquiv f,
IsSemiGroupPreserving f -&gt; IsSemiGroupPreserving f^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk25"><span class="nb">red</span>; <span class="nb">intros</span> E fp x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f^-<span class="mi">1</span> (sg_op x y) = sg_op (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk26"><span class="nb">apply</span> (equiv_inj f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (f^-<span class="mi">1</span> (sg_op x y)) = f (sg_op (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk27"><span class="nb">refine</span> (_ @ _ @ _ @ _)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (sg_op (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y)) = <span class="nl">?Goal1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk28"><hr></label><div class="goal-conclusion"><span class="nl">?Goal1</span> = <span class="nl">?Goal0</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk29"><hr></label><div class="goal-conclusion"><span class="nl">?Goal0</span> = <span class="nl">?Goal</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk2a"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> = f (f^-<span class="mi">1</span> (sg_op x y))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (sg_op (f^-<span class="mi">1</span> x) (f^-<span class="mi">1</span> y)) = <span class="nl">?Goal1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> fp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* We could use [apply ap2; apply eisretr] here, but it is convenient</span>
<span class="c">       to have things in terms of ap. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op (f (f^-<span class="mi">1</span> x)) (f (f^-<span class="mi">1</span> y)) = <span class="nl">?Goal0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">z</span> =&gt; sg_op z _) _); <span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op x (f (f^-<span class="mi">1</span> y)) = <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">z</span> =&gt; sg_op _ z) _); <span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>fp</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op x y = f (f^-<span class="mi">1</span> (sg_op x y))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2f"><span class="kn">Local Instance</span> <span class="nf">invert_monoid_morphism</span> :
    <span class="kr">forall</span> `{!IsEquiv f}, IsMonoidPreserving f -&gt; IsMonoidPreserving (f^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">IsEquiv0</span> : IsEquiv f,
IsMonoidPreserving f -&gt; IsMonoidPreserving f^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk30"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">IsEquiv0</span> : IsEquiv f,
IsMonoidPreserving f -&gt; IsMonoidPreserving f^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk31"><span class="nb">intros</span>;<span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving f^-<span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk32"><hr></label><div class="goal-conclusion">IsUnitPreserving f^-<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk33">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving f^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk34">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsUnitPreserving f^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk35"><span class="nb">apply</span> (equiv_inj f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (f^-<span class="mi">1</span> mon_unit) = f mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk36"><span class="nb">refine</span> (_ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (f^-<span class="mi">1</span> mon_unit) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk37" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk37"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> = f mon_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk38">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (f^-<span class="mi">1</span> mon_unit) = <span class="nl">?Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk39">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsEquiv0</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>IsMonoidPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mon_unit = f mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> preserves_mon_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">invert_mor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (IsSemiGroupPreserving (_ ‚àò _)) =&gt;
  class_apply @compose_sg_morphism : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (IsMonoidPreserving (_ ‚àò _)) =&gt;
  class_apply @compose_monoid_morphism : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (IsSemiGroupPreserving (_ o _)) =&gt;
  class_apply @compose_sg_morphism : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (IsMonoidPreserving (_ o _)) =&gt;
  class_apply @compose_monoid_morphism : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (IsSemiGroupPreserving (_^-<span class="mi">1</span>)) =&gt;
  class_apply @invert_sg_morphism : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (IsMonoidPreserving (_^-<span class="mi">1</span>)) =&gt;
  class_apply @invert_monoid_morphism : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Instance</span> <span class="nf">isinjective_mapinO_tr</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
  {<span class="nv">p</span> : MapIn (Tr (-<span class="mi">1</span>)) f} : IsInjective f
  := <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">pfeq</span> =&gt; ap pr1 (@center _ (p (f y) (x; pfeq) (y; idpath))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">strong_injective</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">Aap</span> : Apart A} {<span class="nv">Bap</span> : Apart B} (<span class="nv">f</span> : A -&gt; B) .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsStrongInjective</span> :=
    { strong_injective : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x ‚â∂ y -&gt; f x ‚â∂ f y
    ; strong_injective_mor : StrongExtensionality f }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">strong_injective</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">extras</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">CutMinusSpec</span> <span class="nv">A</span> (<span class="nv">cm</span> : CutMinus A) `{Zero A} `{Plus A} `{Le A} := {
  cut_minus_le : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, y ‚â§ x -&gt; x ‚à∏ y + y = x ;
  cut_minus_0 : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x ‚â§ y -&gt; x ‚à∏ y = <span class="mi">0</span>
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk3a"><span class="kn">Global Instance</span> <span class="nf">ishprop_issemigrouppreserving</span> `{Funext} {A B : <span class="kt">Type</span>} `{IsHSet B}
  `{SgOp A} `{SgOp B} {f : A -&gt; B} : IsHProp (IsSemiGroupPreserving f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsSemiGroupPreserving f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk3b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsSemiGroupPreserving f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unfold</span> IsSemiGroupPreserving; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_IsSemiRingPreserving</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>}
  `{Plus A, Plus B, Mult A, Mult B, Zero A, Zero B, One A, One B} {f : A -&gt; B}
  : _ &lt;~&gt; IsSemiRingPreserving f := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_IsMonoidPreserving</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{SgOp A} `{SgOp B}
  `{MonUnit A} `{MonUnit B} {f : A -&gt; B} : _ &lt;~&gt; IsMonoidPreserving f
  := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk3c"><span class="kn">Global Instance</span> <span class="nf">ishprop_ismonoidpreserving</span> `{Funext} {A B : <span class="kt">Type</span>} `{SgOp A}
  `{SgOp B} `{IsHSet B} `{MonUnit A} `{MonUnit B} (f : A -&gt; B)
  : IsHProp (IsMonoidPreserving f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsMonoidPreserving f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk3d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsMonoidPreserving f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk3e">srapply (istrunc_equiv_istrunc _ issig_IsMonoidPreserving).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp
  {_ : IsSemiGroupPreserving f &amp; IsUnitPreserving f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk3f">srapply (istrunc_equiv_istrunc _ (equiv_sigma_prod0 _ _)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsSemiGroupPreserving f * IsUnitPreserving f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk40">srapply istrunc_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsUnitPreserving f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk41"><span class="nb">unfold</span> IsUnitPreserving.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>SgOp B</span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>MonUnit B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (f mon_unit = mon_unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk42"><span class="kn">Global Instance</span> <span class="nf">ishprop_issemiringpreserving</span> `{Funext} {A B : <span class="kt">Type</span>} `{IsHSet B}
  `{Plus A, Plus B, Mult A, Mult B, Zero A, Zero B, One A, One B}
  (f : A -&gt; B)
  : IsHProp (IsSemiRingPreserving f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Plus B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult B</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Zero B</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>One B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsSemiRingPreserving f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk43"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Plus B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult B</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Zero B</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>One B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsSemiRingPreserving f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk44">snrapply (istrunc_equiv_istrunc _ issig_IsSemiRingPreserving).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet B</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Plus A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Plus B</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Mult A</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Mult B</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Zero A</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>Zero B</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>One A</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>One B</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp
  {_ : IsMonoidPreserving f &amp; IsMonoidPreserving f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_issemigroup</span> <span class="nv">x</span> <span class="nv">y</span> : _ &lt;~&gt; @IsSemiGroup x y := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk45"><span class="kn">Global Instance</span> <span class="nf">ishprop_issemigroup</span> `{Funext}
  : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, IsHProp (@IsSemiGroup x y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : <span class="kt">Type</span>) (<span class="nv">y</span> : SgOp x),
IsHProp (IsSemiGroup x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk46"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : <span class="kt">Type</span>) (<span class="nv">y</span> : SgOp x),
IsHProp (IsSemiGroup x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk47"><span class="nb">intros</span> x y; <span class="nb">apply</span> istrunc_S; <span class="nb">intros</span> a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (a = b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk48"><span class="nb">rewrite</span> &lt;- (eisretr (issig_issemigroup x y) a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (issig_issemigroup x y
     ((issig_issemigroup x y)^-<span class="mi">1</span> a) = b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk49"><span class="nb">rewrite</span> &lt;- (eisretr (issig_issemigroup x y) b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (issig_issemigroup x y
     ((issig_issemigroup x y)^-<span class="mi">1</span> a) =
   issig_issemigroup x y
     ((issig_issemigroup x y)^-<span class="mi">1</span> b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk4a"><span class="nb">set</span> (a&#39; := (issig_issemigroup x y)^-<span class="mi">1</span> a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a'</var><span><span class="hyp-body"><b>:= </b><span>(issig_issemigroup x y)^-<span class="mi">1</span> a</span></span><span class="hyp-type"><b>: </b><span>{_ : IsHSet x &amp; Associative sg_op}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (issig_issemigroup x y a&#39; =
   issig_issemigroup x y
     ((issig_issemigroup x y)^-<span class="mi">1</span> b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk4b"><span class="nb">set</span> (b&#39; := (issig_issemigroup x y)^-<span class="mi">1</span> b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a'</var><span><span class="hyp-body"><b>:= </b><span>(issig_issemigroup x y)^-<span class="mi">1</span> a</span></span><span class="hyp-type"><b>: </b><span>{_ : IsHSet x &amp; Associative sg_op}</span></span></span></span><br><span><var>b'</var><span><span class="hyp-body"><b>:= </b><span>(issig_issemigroup x y)^-<span class="mi">1</span> b</span></span><span class="hyp-type"><b>: </b><span>{_ : IsHSet x &amp; Associative sg_op}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (issig_issemigroup x y a&#39; = issig_issemigroup x y b&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk4c"><span class="nb">clearbody</span> a&#39; b&#39;; <span class="nb">clear</span> a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsHSet x &amp; Associative sg_op}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (issig_issemigroup x y a&#39; = issig_issemigroup x y b&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk4d">srapply (contr_equiv _ (ap (issig_issemigroup x y))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsHSet x &amp; Associative sg_op}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (a&#39; = b&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk4e"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) a&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsHSet x &amp; Associative sg_op}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsHSet x) (Associative sg_op)
        a&#39;) = b&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk4f"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) b&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsHSet x &amp; Associative sg_op}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsHSet x) (Associative sg_op)
        a&#39;) =
   (equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsHSet x) (Associative sg_op)
        b&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk50"><span class="nb">set</span> (a := equiv_sigma_prod0 _ _ a&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsHSet x &amp; Associative sg_op}</span></span></span><br><span><var>a</var><span><span class="hyp-body"><b>:= </b><span>equiv_sigma_prod0 (IsHSet x) (Associative sg_op) a&#39;</span></span><span class="hyp-type"><b>: </b><span>(IsHSet x * Associative sg_op)%type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     a =
   (equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsHSet x) (Associative sg_op)
        b&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk51"><span class="nb">set</span> (b := equiv_sigma_prod0 _ _ b&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsHSet x &amp; Associative sg_op}</span></span></span><br><span><var>a</var><span><span class="hyp-body"><b>:= </b><span>equiv_sigma_prod0 (IsHSet x) (Associative sg_op) a&#39;</span></span><span class="hyp-type"><b>: </b><span>(IsHSet x * Associative sg_op)%type</span></span></span></span><br><span><var>b</var><span><span class="hyp-body"><b>:= </b><span>equiv_sigma_prod0 (IsHSet x) (Associative sg_op) b&#39;</span></span><span class="hyp-type"><b>: </b><span>(IsHSet x * Associative sg_op)%type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     a =
   (equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk52"><span class="nb">clearbody</span> a b; <span class="nb">clear</span> a&#39; b&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>(IsHSet x * Associative sg_op)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     a =
   (equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk53">srapply (contr_equiv _ (ap (equiv_sigma_prod0 _ _)^-<span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>(IsHSet x * Associative sg_op)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (a = b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk54">srapply (contr_equiv _ (equiv_path_prod _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>(IsHSet x * Associative sg_op)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr ((fst a = fst b) * (snd a = snd b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk55">srapply contr_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>(IsHSet x * Associative sg_op)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (snd a = snd b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk56"><span class="nb">destruct</span> a <span class="kr">as</span> [a&#39; a], b <span class="kr">as</span> [b&#39; b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>IsHSet x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>IsHSet x</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (snd (a&#39;, a) = snd (b&#39;, b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk57"><span class="kp">do</span> <span class="mi">3</span> (nrefine (contr_equiv&#39; _ (@equiv_path_forall H _ _ _ _));
  nrefine (@contr_forall H _ _ _); <span class="nb">intro</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>IsHSet x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>IsHSet x</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Associative sg_op</span></span></span><br><span><var>a0, a1, a2</var><span class="hyp-type"><b>: </b><span>x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (snd (a&#39;, a) a0 a1 a2 = snd (b&#39;, b) a0 a1 a2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_ismonoid</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : _ &lt;~&gt; @IsMonoid x y z := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk58"><span class="kn">Global Instance</span> <span class="nf">ishprop_ismonoid</span> `{Funext} x y z : IsHProp (@IsMonoid x y z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsMonoid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk59"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsMonoid x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk5a"><span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : IsMonoid x, Contr (x0 = y0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk5b"><span class="nb">intros</span> a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>IsMonoid x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (a = b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk5c"><span class="nb">rewrite</span> &lt;- (eisretr (issig_ismonoid x y z) a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>IsMonoid x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (issig_ismonoid x y z ((issig_ismonoid x y z)^-<span class="mi">1</span> a) =
   b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk5d"><span class="nb">rewrite</span> &lt;- (eisretr (issig_ismonoid x y z) b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>IsMonoid x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (issig_ismonoid x y z ((issig_ismonoid x y z)^-<span class="mi">1</span> a) =
   issig_ismonoid x y z ((issig_ismonoid x y z)^-<span class="mi">1</span> b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk5e"><span class="nb">set</span> (a&#39; := (issig_ismonoid x y z)^-<span class="mi">1</span> a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>IsMonoid x</span></span></span><br><span><var>a'</var><span><span class="hyp-body"><b>:= </b><span>(issig_ismonoid x y z)^-<span class="mi">1</span> a</span></span><span class="hyp-type"><b>: </b><span>{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (issig_ismonoid x y z a&#39; =
   issig_ismonoid x y z ((issig_ismonoid x y z)^-<span class="mi">1</span> b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk5f"><span class="nb">set</span> (b&#39; := (issig_ismonoid x y z)^-<span class="mi">1</span> b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>IsMonoid x</span></span></span><br><span><var>a'</var><span><span class="hyp-body"><b>:= </b><span>(issig_ismonoid x y z)^-<span class="mi">1</span> a</span></span><span class="hyp-type"><b>: </b><span>{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span></span><br><span><var>b'</var><span><span class="hyp-body"><b>:= </b><span>(issig_ismonoid x y z)^-<span class="mi">1</span> b</span></span><span class="hyp-type"><b>: </b><span>{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (issig_ismonoid x y z a&#39; = issig_ismonoid x y z b&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk60"><span class="nb">clearbody</span> a&#39; b&#39;; <span class="nb">clear</span> a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (issig_ismonoid x y z a&#39; = issig_ismonoid x y z b&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk61">srapply (contr_equiv _ (ap (issig_ismonoid x y z))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (a&#39; = b&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk62"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) a&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsSemiGroup x)
        {_ : LeftIdentity sg_op mon_unit &amp;
        RightIdentity sg_op mon_unit} a&#39;) = b&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk63"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) b&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsSemiGroup x)
        {_ : LeftIdentity sg_op mon_unit &amp;
        RightIdentity sg_op mon_unit} a&#39;) =
   (equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsSemiGroup x)
        {_ : LeftIdentity sg_op mon_unit &amp;
        RightIdentity sg_op mon_unit} b&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk64"><span class="nb">set</span> (a := equiv_sigma_prod0 _ _ a&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span><br><span><var>a</var><span><span class="hyp-body"><b>:= </b><span>equiv_sigma_prod0 (IsSemiGroup x)
  {_ : LeftIdentity sg_op mon_unit &amp;
  RightIdentity sg_op mon_unit} a&#39;</span></span><span class="hyp-type"><b>: </b><span>(IsSemiGroup x *
 {_ : LeftIdentity sg_op mon_unit &amp;
 RightIdentity sg_op mon_unit})%type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span> a =
   (equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsSemiGroup x)
        {_ : LeftIdentity sg_op mon_unit &amp;
        RightIdentity sg_op mon_unit} b&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk65"><span class="nb">set</span> (b := equiv_sigma_prod0 _ _ b&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span><br><span><var>a</var><span><span class="hyp-body"><b>:= </b><span>equiv_sigma_prod0 (IsSemiGroup x)
  {_ : LeftIdentity sg_op mon_unit &amp;
  RightIdentity sg_op mon_unit} a&#39;</span></span><span class="hyp-type"><b>: </b><span>(IsSemiGroup x *
 {_ : LeftIdentity sg_op mon_unit &amp;
 RightIdentity sg_op mon_unit})%type</span></span></span></span><br><span><var>b</var><span><span class="hyp-body"><b>:= </b><span>equiv_sigma_prod0 (IsSemiGroup x)
  {_ : LeftIdentity sg_op mon_unit &amp;
  RightIdentity sg_op mon_unit} b&#39;</span></span><span class="hyp-type"><b>: </b><span>(IsSemiGroup x *
 {_ : LeftIdentity sg_op mon_unit &amp;
 RightIdentity sg_op mon_unit})%type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span> a =
   (equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span> b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk66"><span class="nb">clearbody</span> a b; <span class="nb">clear</span> a&#39; b&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>(IsSemiGroup x *
 {_ : LeftIdentity sg_op mon_unit &amp;
 RightIdentity sg_op mon_unit})%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span> a =
   (equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span> b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk67">srapply (contr_equiv _ (ap (equiv_sigma_prod0 _ _)^-<span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>(IsSemiGroup x *
 {_ : LeftIdentity sg_op mon_unit &amp;
 RightIdentity sg_op mon_unit})%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (a = b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk68">srapply (contr_equiv _ (equiv_path_prod _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>(IsSemiGroup x *
 {_ : LeftIdentity sg_op mon_unit &amp;
 RightIdentity sg_op mon_unit})%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr ((fst a = fst b) * (snd a = snd b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk69">srapply contr_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>(IsSemiGroup x *
 {_ : LeftIdentity sg_op mon_unit &amp;
 RightIdentity sg_op mon_unit})%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (snd a = snd b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk6a"><span class="nb">destruct</span> a <span class="kr">as</span> [a&#39; a], b <span class="kr">as</span> [b&#39; b]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (a = b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk6b"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span>
     (equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
        (RightIdentity sg_op mon_unit) a) = b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk6c"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span>
     (equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
        (RightIdentity sg_op mon_unit) a) =
   (equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span>
     (equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
        (RightIdentity sg_op mon_unit) b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk6d"><span class="nb">set</span> (a&#39;&#39; := equiv_sigma_prod0 _ _ a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span><br><span><var>a''</var><span><span class="hyp-body"><b>:= </b><span>equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
  (RightIdentity sg_op mon_unit) a</span></span><span class="hyp-type"><b>: </b><span>(LeftIdentity sg_op mon_unit * RightIdentity sg_op mon_unit)%type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span> a&#39;&#39; =
   (equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span>
     (equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
        (RightIdentity sg_op mon_unit) b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk6e"><span class="nb">set</span> (b&#39;&#39; := equiv_sigma_prod0 _ _ b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span><br><span><var>a''</var><span><span class="hyp-body"><b>:= </b><span>equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
  (RightIdentity sg_op mon_unit) a</span></span><span class="hyp-type"><b>: </b><span>(LeftIdentity sg_op mon_unit * RightIdentity sg_op mon_unit)%type</span></span></span></span><br><span><var>b''</var><span><span class="hyp-body"><b>:= </b><span>equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
  (RightIdentity sg_op mon_unit) b</span></span><span class="hyp-type"><b>: </b><span>(LeftIdentity sg_op mon_unit * RightIdentity sg_op mon_unit)%type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span> a&#39;&#39; =
   (equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span> b&#39;&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk6f"><span class="nb">clearbody</span> a&#39;&#39; b&#39;&#39;; <span class="nb">clear</span> a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a'', b''</var><span class="hyp-type"><b>: </b><span>(LeftIdentity sg_op mon_unit * RightIdentity sg_op mon_unit)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span> a&#39;&#39; =
   (equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span> b&#39;&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk70">srapply (contr_equiv _ (ap (equiv_sigma_prod0 _ _)^-<span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a'', b''</var><span class="hyp-type"><b>: </b><span>(LeftIdentity sg_op mon_unit * RightIdentity sg_op mon_unit)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (a&#39;&#39; = b&#39;&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk71">srapply (contr_equiv _ (equiv_path_prod _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a'', b''</var><span class="hyp-type"><b>: </b><span>(LeftIdentity sg_op mon_unit * RightIdentity sg_op mon_unit)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr ((fst a&#39;&#39; = fst b&#39;&#39;) * (snd a&#39;&#39; = snd b&#39;&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk72"><span class="nb">destruct</span> a&#39;&#39; <span class="kr">as</span> [a a&#39;&#39;], b&#39;&#39; <span class="kr">as</span> [b b&#39;&#39;]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op mon_unit</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>RightIdentity sg_op mon_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op mon_unit</span></span></span><br><span><var>b''</var><span class="hyp-type"><b>: </b><span>RightIdentity sg_op mon_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr ((a = b) * (a&#39;&#39; = b&#39;&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk73">snrapply contr_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op mon_unit</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>RightIdentity sg_op mon_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op mon_unit</span></span></span><br><span><var>b''</var><span class="hyp-type"><b>: </b><span>RightIdentity sg_op mon_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (a = b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk74" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op mon_unit</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>RightIdentity sg_op mon_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op mon_unit</span></span></span><br><span><var>b''</var><span class="hyp-type"><b>: </b><span>RightIdentity sg_op mon_unit</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk74"><hr></label><div class="goal-conclusion">Contr (a&#39;&#39; = b&#39;&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk75"><span class="kp">all</span>: srapply contr_paths_contr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op mon_unit</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>RightIdentity sg_op mon_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op mon_unit</span></span></span><br><span><var>b''</var><span class="hyp-type"><b>: </b><span>RightIdentity sg_op mon_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (LeftIdentity sg_op mon_unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk76" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op mon_unit</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>RightIdentity sg_op mon_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op mon_unit</span></span></span><br><span><var>b''</var><span class="hyp-type"><b>: </b><span>RightIdentity sg_op mon_unit</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk76"><hr></label><div class="goal-conclusion">Contr (RightIdentity sg_op mon_unit)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk77"><span class="kp">all</span>: srapply contr_inhabited_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op mon_unit</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>RightIdentity sg_op mon_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op mon_unit</span></span></span><br><span><var>b''</var><span class="hyp-type"><b>: </b><span>RightIdentity sg_op mon_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (LeftIdentity sg_op mon_unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk78" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>SgOp x</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>MonUnit x</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsSemiGroup x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op mon_unit</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>RightIdentity sg_op mon_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>LeftIdentity sg_op mon_unit</span></span></span><br><span><var>b''</var><span class="hyp-type"><b>: </b><span>RightIdentity sg_op mon_unit</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk78"><hr></label><div class="goal-conclusion">IsHProp (RightIdentity sg_op mon_unit)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: srapply istrunc_forall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_isgroup</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : _ &lt;~&gt; @IsGroup w x y z := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk79"><span class="kn">Global Instance</span> <span class="nf">ishprop_isgroup</span> `{Funext} w x y z : IsHProp (@IsGroup w x y z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsGroup w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk7a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (IsGroup w)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk7b"><span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : IsGroup w, Contr (x0 = y0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk7c"><span class="nb">intros</span> a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>IsGroup w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (a = b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk7d"><span class="nb">rewrite</span> &lt;- (eisretr (issig_isgroup w x y z) a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>IsGroup w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (issig_isgroup w x y z
     ((issig_isgroup w x y z)^-<span class="mi">1</span> a) = b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk7e"><span class="nb">rewrite</span> &lt;- (eisretr (issig_isgroup w x y z) b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>IsGroup w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (issig_isgroup w x y z
     ((issig_isgroup w x y z)^-<span class="mi">1</span> a) =
   issig_isgroup w x y z
     ((issig_isgroup w x y z)^-<span class="mi">1</span> b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk7f"><span class="nb">set</span> (a&#39; := (issig_isgroup w x y z)^-<span class="mi">1</span> a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>IsGroup w</span></span></span><br><span><var>a'</var><span><span class="hyp-body"><b>:= </b><span>(issig_isgroup w x y z)^-<span class="mi">1</span> a</span></span><span class="hyp-type"><b>: </b><span>{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (issig_isgroup w x y z a&#39; =
   issig_isgroup w x y z
     ((issig_isgroup w x y z)^-<span class="mi">1</span> b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk80"><span class="nb">set</span> (b&#39; := (issig_isgroup w x y z)^-<span class="mi">1</span> b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>IsGroup w</span></span></span><br><span><var>a'</var><span><span class="hyp-body"><b>:= </b><span>(issig_isgroup w x y z)^-<span class="mi">1</span> a</span></span><span class="hyp-type"><b>: </b><span>{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span></span><br><span><var>b'</var><span><span class="hyp-body"><b>:= </b><span>(issig_isgroup w x y z)^-<span class="mi">1</span> b</span></span><span class="hyp-type"><b>: </b><span>{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (issig_isgroup w x y z a&#39; = issig_isgroup w x y z b&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk81"><span class="nb">clearbody</span> a&#39; b&#39;; <span class="nb">clear</span> a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  (issig_isgroup w x y z a&#39; = issig_isgroup w x y z b&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk82">srapply (contr_equiv _ (ap (issig_isgroup w x y z))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (a&#39; = b&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk83"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) a&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsMonoid w)
        {_ : LeftInverse sg_op negate mon_unit &amp;
        RightInverse sg_op negate mon_unit} a&#39;) = b&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk84"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) b&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsMonoid w)
        {_ : LeftInverse sg_op negate mon_unit &amp;
        RightInverse sg_op negate mon_unit} a&#39;) =
   (equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsMonoid w)
        {_ : LeftInverse sg_op negate mon_unit &amp;
        RightInverse sg_op negate mon_unit} b&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk85"><span class="nb">set</span> (a := equiv_sigma_prod0 _ _ a&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span><br><span><var>a</var><span><span class="hyp-body"><b>:= </b><span>equiv_sigma_prod0 (IsMonoid w)
  {_ : LeftInverse sg_op negate mon_unit &amp;
  RightInverse sg_op negate mon_unit} a&#39;</span></span><span class="hyp-type"><b>: </b><span>(IsMonoid w *
 {_ : LeftInverse sg_op negate mon_unit &amp;
 RightInverse sg_op negate mon_unit})%type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span> a =
   (equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsMonoid w)
        {_ : LeftInverse sg_op negate mon_unit &amp;
        RightInverse sg_op negate mon_unit} b&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk86"><span class="nb">set</span> (b := equiv_sigma_prod0 _ _ b&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span><br><span><var>a</var><span><span class="hyp-body"><b>:= </b><span>equiv_sigma_prod0 (IsMonoid w)
  {_ : LeftInverse sg_op negate mon_unit &amp;
  RightInverse sg_op negate mon_unit} a&#39;</span></span><span class="hyp-type"><b>: </b><span>(IsMonoid w *
 {_ : LeftInverse sg_op negate mon_unit &amp;
 RightInverse sg_op negate mon_unit})%type</span></span></span></span><br><span><var>b</var><span><span class="hyp-body"><b>:= </b><span>equiv_sigma_prod0 (IsMonoid w)
  {_ : LeftInverse sg_op negate mon_unit &amp;
  RightInverse sg_op negate mon_unit} b&#39;</span></span><span class="hyp-type"><b>: </b><span>(IsMonoid w *
 {_ : LeftInverse sg_op negate mon_unit &amp;
 RightInverse sg_op negate mon_unit})%type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span> a =
   (equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span> b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk87"><span class="nb">clearbody</span> a b; <span class="nb">clear</span> a&#39; b&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>(IsMonoid w *
 {_ : LeftInverse sg_op negate mon_unit &amp;
 RightInverse sg_op negate mon_unit})%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span> a =
   (equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span> b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk88">srapply (contr_equiv _ (ap (equiv_sigma_prod0 _ _)^-<span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>(IsMonoid w *
 {_ : LeftInverse sg_op negate mon_unit &amp;
 RightInverse sg_op negate mon_unit})%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (a = b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk89">srapply (contr_equiv _ (equiv_path_prod _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>(IsMonoid w *
 {_ : LeftInverse sg_op negate mon_unit &amp;
 RightInverse sg_op negate mon_unit})%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr ((fst a = fst b) * (snd a = snd b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk8a">srapply contr_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>(IsMonoid w *
 {_ : LeftInverse sg_op negate mon_unit &amp;
 RightInverse sg_op negate mon_unit})%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (snd a = snd b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk8b"><span class="nb">destruct</span> a <span class="kr">as</span> [a&#39; a], b <span class="kr">as</span> [b&#39; b]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (a = b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk8c"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span>
     (equiv_sigma_prod0
        (LeftInverse sg_op negate mon_unit)
        (RightInverse sg_op negate mon_unit) a) = b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk8d"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span>
     (equiv_sigma_prod0
        (LeftInverse sg_op negate mon_unit)
        (RightInverse sg_op negate mon_unit) a) =
   (equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span>
     (equiv_sigma_prod0
        (LeftInverse sg_op negate mon_unit)
        (RightInverse sg_op negate mon_unit) b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk8e"><span class="nb">set</span> (a&#39;&#39; := equiv_sigma_prod0 _ _ a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span><br><span><var>a''</var><span><span class="hyp-body"><b>:= </b><span>equiv_sigma_prod0
  (LeftInverse sg_op negate mon_unit)
  (RightInverse sg_op negate mon_unit) a</span></span><span class="hyp-type"><b>: </b><span>(LeftInverse sg_op negate mon_unit * RightInverse sg_op negate mon_unit)%type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span> a&#39;&#39; =
   (equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span>
     (equiv_sigma_prod0
        (LeftInverse sg_op negate mon_unit)
        (RightInverse sg_op negate mon_unit) b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk8f"><span class="nb">set</span> (b&#39;&#39; := equiv_sigma_prod0 _ _ b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span><br><span><var>b'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span><br><span><var>a''</var><span><span class="hyp-body"><b>:= </b><span>equiv_sigma_prod0
  (LeftInverse sg_op negate mon_unit)
  (RightInverse sg_op negate mon_unit) a</span></span><span class="hyp-type"><b>: </b><span>(LeftInverse sg_op negate mon_unit * RightInverse sg_op negate mon_unit)%type</span></span></span></span><br><span><var>b''</var><span><span class="hyp-body"><b>:= </b><span>equiv_sigma_prod0
  (LeftInverse sg_op negate mon_unit)
  (RightInverse sg_op negate mon_unit) b</span></span><span class="hyp-type"><b>: </b><span>(LeftInverse sg_op negate mon_unit * RightInverse sg_op negate mon_unit)%type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span> a&#39;&#39; =
   (equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span> b&#39;&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk90"><span class="nb">clearbody</span> a&#39;&#39; b&#39;&#39;; <span class="nb">clear</span> a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>a'', b''</var><span class="hyp-type"><b>: </b><span>(LeftInverse sg_op negate mon_unit * RightInverse sg_op negate mon_unit)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  ((equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span> a&#39;&#39; =
   (equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span> b&#39;&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk91">srapply (contr_equiv _ (ap (equiv_sigma_prod0 _ _)^-<span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>a'', b''</var><span class="hyp-type"><b>: </b><span>(LeftInverse sg_op negate mon_unit * RightInverse sg_op negate mon_unit)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (a&#39;&#39; = b&#39;&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk92">srapply (contr_equiv _ (equiv_path_prod _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>a'', b''</var><span class="hyp-type"><b>: </b><span>(LeftInverse sg_op negate mon_unit * RightInverse sg_op negate mon_unit)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr ((fst a&#39;&#39; = fst b&#39;&#39;) * (snd a&#39;&#39; = snd b&#39;&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk93"><span class="nb">destruct</span> a&#39;&#39; <span class="kr">as</span> [a a&#39;&#39;], b&#39;&#39; <span class="kr">as</span> [b b&#39;&#39;]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op negate mon_unit</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>RightInverse sg_op negate mon_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op negate mon_unit</span></span></span><br><span><var>b''</var><span class="hyp-type"><b>: </b><span>RightInverse sg_op negate mon_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr ((a = b) * (a&#39;&#39; = b&#39;&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk94">srapply contr_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op negate mon_unit</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>RightInverse sg_op negate mon_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op negate mon_unit</span></span></span><br><span><var>b''</var><span class="hyp-type"><b>: </b><span>RightInverse sg_op negate mon_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (a = b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk95" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op negate mon_unit</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>RightInverse sg_op negate mon_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op negate mon_unit</span></span></span><br><span><var>b''</var><span class="hyp-type"><b>: </b><span>RightInverse sg_op negate mon_unit</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk95"><hr></label><div class="goal-conclusion">Contr (a&#39;&#39; = b&#39;&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk96"><span class="kp">all</span>: srapply contr_paths_contr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op negate mon_unit</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>RightInverse sg_op negate mon_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op negate mon_unit</span></span></span><br><span><var>b''</var><span class="hyp-type"><b>: </b><span>RightInverse sg_op negate mon_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (LeftInverse sg_op negate mon_unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk97" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op negate mon_unit</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>RightInverse sg_op negate mon_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op negate mon_unit</span></span></span><br><span><var>b''</var><span class="hyp-type"><b>: </b><span>RightInverse sg_op negate mon_unit</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk97"><hr></label><div class="goal-conclusion">Contr (RightInverse sg_op negate mon_unit)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk98"><span class="kp">all</span>: srapply contr_inhabited_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op negate mon_unit</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>RightInverse sg_op negate mon_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op negate mon_unit</span></span></span><br><span><var>b''</var><span class="hyp-type"><b>: </b><span>RightInverse sg_op negate mon_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (LeftInverse sg_op negate mon_unit)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk99" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>SgOp w</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>MonUnit w</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Negate w</span></span></span><br><span><var>a', b'</var><span class="hyp-type"><b>: </b><span>IsMonoid w</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op negate mon_unit</span></span></span><br><span><var>a''</var><span class="hyp-type"><b>: </b><span>RightInverse sg_op negate mon_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>LeftInverse sg_op negate mon_unit</span></span></span><br><span><var>b''</var><span class="hyp-type"><b>: </b><span>RightInverse sg_op negate mon_unit</span></span></span><br></div><label class="goal-separator" for="abstract-algebra-v-chk99"><hr></label><div class="goal-conclusion">IsHProp (RightInverse sg_op negate mon_unit)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: srapply istrunc_forall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">extras</span>.</span></span></pre>
</div>
</div></body>
</html>
