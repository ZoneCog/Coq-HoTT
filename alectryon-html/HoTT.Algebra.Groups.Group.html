<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Group.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk0"><span class="kn">Require Import</span> Basics Types HProp HFiber HSet.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> PathAny.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> (notations) Classes.interfaces.canonical_names.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> (hints) Classes.interfaces.abstract_algebra.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> (hints) Classes.interfaces.canonical_names.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** We only export the parts of these that will be most useful to users of this file. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Classes.interfaces.canonical_names (SgOp, sg_op, One, one,
    MonUnit, mon_unit, LeftIdentity, left_identity, RightIdentity, right_identity,
    Negate, negate, Associative, simple_associativity, associativity,
    LeftInverse, left_inverse, RightInverse, right_inverse, Commutative, commutativity).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Export</span> canonical_names.BinOpNotations.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Classes.interfaces.abstract_algebra (IsGroup(..), group_monoid, negate_l, negate_r,
    IsSemiGroup(..), sg_set, sg_ass,
    IsMonoid(..), monoid_left_id, monoid_right_id, monoid_semigroup,
    IsMonoidPreserving(..), monmor_unitmor, monmor_sgmor,
    IsSemiGroupPreserving, preserves_sg_op, IsUnitPreserving, preserves_mon_unit).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Classes.theory.groups.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Pointed.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> WildCat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Spaces.Nat.Core Spaces.Int.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Truncations.Core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Set Polymorphic Inductive Cumulativity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable Variables</span> <span class="nf">G</span> H A B C f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> group_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Groups *)</span>

<span class="sd">(** A group is an abstraction of several common situations in mathematics. For example, consider the symmetries of an object.  Two symmetries can be combined; there is a symmetry that does nothing; and any symmetry can be reversed. Such situations arise in geometry, algebra and, importantly for us, homotopy theory. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> pointed_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_mult_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> wc_iso_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Definition of a Group *)</span>

<span class="sd">(** A group consists of a type, an operation on that type, a unit and an inverse that satisfy the group axioms in [IsGroup]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">Group</span> := {
  group_type :&gt; <span class="kt">Type</span>;
  group_sgop :: SgOp group_type;
  group_unit :: MonUnit group_type;
  group_inverse :: Negate group_type;
  group_isgroup :: IsGroup group_type;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> group_sgop {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> group_unit {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> group_inverse {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> group_isgroup {_}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** We should never need to unfold the proof that something is a group. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global</span> <span class="kn">Opaque</span> group_isgroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_group</span> : _ &lt;~&gt; Group
  := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Proof automation *)</span>
<span class="sd">(** Many times in group theoretic proofs we want some form of automation for obvious identities. Here we implement such a behavior. *)</span>

<span class="sd">(** We create a database of hints for the group theory library *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Create HintDb</span> group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Our group laws can be proven easily with tactics such as [rapply associativity]. However this requires a typeclass search on more general algebraic structures. Therefore we explicitly list many groups laws here so that coq can use them. We also create hints for each law in our groups database. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">GroupLaws</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_assoc</span> := associativity x y z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_unit_l</span> := left_identity x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_unit_r</span> := right_identity x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_inv_l</span> := left_inverse x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_inv_r</span> := right_inverse x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">GroupLaws</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> grp_assoc  : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> grp_unit_l : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> grp_unit_r : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> grp_inv_l  : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> grp_inv_r  : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given path types in a product we may want to decompose. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Extern</span> <span class="mi">5</span> (@paths (_ * _) _ _) =&gt; (<span class="nb">apply</span> path_prod) : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** Given path types in a sigma type of a hprop family (i.e. a subset) we may want to decompose. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Extern</span> <span class="mi">6</span> (@paths (sig _) _ _) =&gt; (rapply path_sigma_hprop) : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We also declare a tactic (notation) for automatically solving group laws *)</span>
<span class="sd">(** TODO: improve this tactic so that it also rewrites and is able to solve basic group lemmas. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Tactic Notation</span> <span class="s2">&quot;grp_auto&quot;</span> := <span class="nb">hnf</span>; <span class="nb">intros</span>; <span class="nb">eauto with</span> group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Some basic properties of groups *)</span>

<span class="sd">(** Groups are pointed sets with point the identity. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">ispointed_group</span> (<span class="nv">G</span> : Group)
  : IsPointed G := @mon_unit G _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ptype_group</span> : Group -&gt; pType
  := <span class="kr">fun</span> <span class="nv">G</span> =&gt; [G, _].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">ptype_group</span> : Group &gt;-&gt; pType.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** An element acting like the identity is unique. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">identity_unique</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">Aop</span> : SgOp A}
  (<span class="nv">x</span> <span class="nv">y</span> : A) {<span class="nv">p</span> : LeftIdentity Aop x} {<span class="nv">q</span> : RightIdentity Aop y}
  : x = y := (q x)^ @ p y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">identity_unique&#39;</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">Aop</span> : SgOp A}
  (<span class="nv">x</span> <span class="nv">y</span> : A) {<span class="nv">p</span> : LeftIdentity Aop x} {<span class="nv">q</span> : RightIdentity Aop y}
  : y = x := (identity_unique x y)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** An element acting like an inverse is unique. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1"><span class="kn">Definition</span> <span class="nf">inverse_unique</span> `{IsMonoid A}
  (a x y : A) {p : x * a = mon_unit} {q : a * y = mon_unit}
  : x = y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aop</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>Aunit</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsMonoid A</span></span></span><br><span><var>a, x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x * a = mon_unit</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>a * y = mon_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aop</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>Aunit</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsMonoid A</span></span></span><br><span><var>a, x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x * a = mon_unit</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>a * y = mon_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk3"><span class="nb">refine</span> ((right_identity x)^ @ ap _ q^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aop</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>Aunit</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsMonoid A</span></span></span><br><span><var>a, x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x * a = mon_unit</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>a * y = mon_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * (a * y) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk4"><span class="nb">refine</span> (associativity _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aop</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>Aunit</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsMonoid A</span></span></span><br><span><var>a, x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x * a = mon_unit</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>a * y = mon_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * a * y = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk5"><span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x * y) p @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Aop</var><span class="hyp-type"><b>: </b><span>SgOp A</span></span></span><br><span><var>Aunit</var><span class="hyp-type"><b>: </b><span>MonUnit A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsMonoid A</span></span></span><br><span><var>a, x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>x * a = mon_unit</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>a * y = mon_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mon_unit * y = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> left_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Group homomorphisms *)</span>

<span class="sd">(** Group homomorphisms are maps between groups that preserve the group operation. They allow us to compare groups and map their structure to one another. This is useful for determining if two groups are really the same, in which case we say they are &quot;isomorphic&quot;. *)</span>

<span class="sd">(** A group homomorphism consists of a map between groups and a proof that the map preserves the group operation. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">GroupHomomorphism</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) := Build_GroupHomomorphism {
  grp_homo_map :&gt; group_type G -&gt; group_type H;
  issemigrouppreserving_grp_homo :: IsSemiGroupPreserving grp_homo_map;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> grp_homo_map {G H}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Build_GroupHomomorphism {G H} _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> issemigrouppreserving_grp_homo {G H} f _ : <span class="nb">rename</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Basic properties of group homomorphisms *)</span>

<span class="sd">(** Group homomorphisms preserve group operations. This is an alias for [issemigrouppreserving_grp_homo] with the identity written explicitly. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_homo_op</span>
  : <span class="kr">forall</span> {<span class="nv">G</span> <span class="nv">H</span> : Group} (<span class="nv">f</span> : GroupHomomorphism G H) (<span class="nv">x</span> <span class="nv">y</span> : G), f (x * y) = f x * f y
  := @issemigrouppreserving_grp_homo.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> grp_homo_op : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group homomorphisms are unit preserving. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk6"><span class="kn">Global Instance</span> <span class="nf">isunitpreserving_grp_homo</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  (<span class="nv">f</span> : GroupHomomorphism G H)
  : IsUnitPreserving f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsUnitPreserving f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsUnitPreserving f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk8"><span class="nb">unfold</span> IsUnitPreserving.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f mon_unit = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk9"><span class="nb">apply</span> (group_cancelL (f mon_unit)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f mon_unit * f mon_unit = f mon_unit * mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka">rhs nrapply grp_unit_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f mon_unit * f mon_unit = f mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb">rhs_V rapply (ap  _ (monoid_left_id _ mon_unit)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f mon_unit * f mon_unit = f (mon_unit * mon_unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkc"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (mon_unit * mon_unit) = f mon_unit * f mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">nrapply issemigrouppreserving_grp_homo.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group homomorphisms preserve identities. This is an alias for the previous statement. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_homo_unit</span>
  : <span class="kr">forall</span> {<span class="nv">G</span> <span class="nv">H</span> : Group} (<span class="nv">f</span> : GroupHomomorphism G H), f mon_unit = mon_unit
  := @isunitpreserving_grp_homo.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> grp_homo_unit : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Therefore, group homomorphisms are monoid homomorphisms. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">ismonoidpreserving_grp_homo</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  (<span class="nv">f</span> : GroupHomomorphism G H)
  : IsMonoidPreserving f
  := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group homomorphisms are pointed maps. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pmap_GroupHomomorphism</span> {<span class="nv">G</span> <span class="nv">H</span> : Group} (<span class="nv">f</span> : GroupHomomorphism G H) : G -&gt;* H
  := Build_pMap G H f (isunitpreserving_grp_homo f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">pmap_GroupHomomorphism</span> : GroupHomomorphism &gt;-&gt; pForall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_GroupHomomorphism</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) : _ &lt;~&gt; GroupHomomorphism G H
  := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Function extensionality for group homomorphisms. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd"><span class="kn">Definition</span> <span class="nf">equiv_path_grouphomomorphism</span> {<span class="nv">F</span> : Funext} {<span class="nv">G</span> <span class="nv">H</span> : Group}
  {<span class="nv">g</span> <span class="nv">h</span> : GroupHomomorphism G H} : g == h &lt;~&gt; g = h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g == h &lt;~&gt; g = h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g == h &lt;~&gt; g = h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkf"><span class="nb">refine</span> ((equiv_ap (issig_GroupHomomorphism G H)^-<span class="mi">1</span> _ _)^-<span class="mi">1</span> oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g == h &lt;~&gt;
(issig_GroupHomomorphism G H)^-<span class="mi">1</span> g =
(issig_GroupHomomorphism G H)^-<span class="mi">1</span> h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk10"><span class="nb">refine</span> (equiv_path_sigma_hprop _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g == h &lt;~&gt;
((issig_GroupHomomorphism G H)^-<span class="mi">1</span> g).<span class="mi">1</span> =
((issig_GroupHomomorphism G H)^-<span class="mi">1</span> h).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_path_forall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group homomorphisms are sets, in the presence of funext. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk11"><span class="kn">Global Instance</span> <span class="nf">ishset_grouphomomorphism</span> {<span class="nv">F</span> : Funext} {<span class="nv">G</span> <span class="nv">H</span> : Group}
  : IsHSet (GroupHomomorphism G H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (GroupHomomorphism G H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (GroupHomomorphism G H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk13"><span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_mere_relation (GroupHomomorphism G H) paths</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> f g; <span class="nb">apply</span> (istrunc_equiv_istrunc _ equiv_path_grouphomomorphism).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group homomorphisms preserve inverses. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk14"><span class="kn">Definition</span> <span class="nf">grp_homo_inv</span> {<span class="nv">G</span> <span class="nv">H</span>} (<span class="nv">f</span> : GroupHomomorphism G H)
  : <span class="kr">forall</span> <span class="nv">x</span>, f (- x) = -(f x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, f (- x) = - f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk15"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, f (- x) = - f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk16"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (- x) = - f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk17"><span class="nb">apply</span> (inverse_unique (f x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (- x) * f x = mon_unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk18" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk18"><hr></label><div class="goal-conclusion">f x * - f x = mon_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk19">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (- x) * f x = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a"><span class="nb">refine</span> (_ @ grp_homo_unit f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (- x) * f x = f mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b"><span class="nb">refine</span> ((grp_homo_op f (-x) x)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (- x * x) = f mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- x * x = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_inv_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x * - f x = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_inv_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Hint Immediate</span> grp_homo_inv : group_db.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The identity map is a group homomorphism. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_homo_id</span> {<span class="nv">G</span> : Group} : GroupHomomorphism G G
  := Build_GroupHomomorphism idmap _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The composition of the underlying functions of two group homomorphisms is also a group homomorphism. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1e"><span class="kn">Definition</span> <span class="nf">grp_homo_compose</span> {<span class="nv">G</span> <span class="nv">H</span> <span class="nv">K</span> : Group}
  : GroupHomomorphism H K -&gt; GroupHomomorphism G H -&gt; GroupHomomorphism G K.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism H K -&gt;
GroupHomomorphism G H -&gt; GroupHomomorphism G K</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism H K -&gt;
GroupHomomorphism G H -&gt; GroupHomomorphism G K</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk20"><span class="nb">intros</span> f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism H K</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism G K</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply (Build_GroupHomomorphism (f o g)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Group Isomorphisms *)</span>

<span class="sd">(** Group isomorphsims are group homomorphisms whose underlying map happens to be an equivalence. They allow us to consider two groups to be the &quot;same&quot;. They can be inverted and composed just like equivalences. *)</span>

<span class="sd">(** An isomorphism of groups is defined as group homomorphism that is an equivalence. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">GroupIsomorphism</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) := Build_GroupIsomorphism {
  grp_iso_homo :&gt; GroupHomomorphism G H;
  isequiv_group_iso :: IsEquiv grp_iso_homo;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We can build an isomorphism from an operation-preserving equivalence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk21"><span class="kn">Definition</span> <span class="nf">Build_GroupIsomorphism&#39;</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  (<span class="nv">f</span> : G &lt;~&gt; H) (<span class="nv">h</span> : IsSemiGroupPreserving f)
  : GroupIsomorphism G H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G &lt;~&gt; H</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G &lt;~&gt; H</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk23">srapply Build_GroupIsomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G &lt;~&gt; H</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism G H</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G &lt;~&gt; H</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br></div><label class="goal-separator" for="group-v-chk24"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?grp_iso_homo</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk25"><span class="mi">1</span>: srapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G &lt;~&gt; H</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  {|
    grp_homo_map := f;
    issemigrouppreserving_grp_homo := h
  |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_GroupIsomorphism</span> (<span class="nv">G</span> <span class="nv">H</span> : Group)
  : _ &lt;~&gt; GroupIsomorphism G H := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The underlying equivalence of a group isomorphism. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_groupisomorphism</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  : GroupIsomorphism G H -&gt; G &lt;~&gt; H
  := <span class="kr">fun</span> <span class="nv">f</span> =&gt; Build_Equiv G H f _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">equiv_groupisomorphism</span> : GroupIsomorphism &gt;-&gt; Equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The underlying pointed equivalence of a group isomorphism. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pequiv_groupisomorphism</span> {<span class="nv">A</span> <span class="nv">B</span> : Group}
  : GroupIsomorphism A B -&gt; (A &lt;~&gt;* B)
  := <span class="kr">fun</span> <span class="nv">f</span> =&gt; Build_pEquiv _ _ f _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">pequiv_groupisomorphism</span> : GroupIsomorphism &gt;-&gt; pEquiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Funext for group isomorphisms. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk26"><span class="kn">Definition</span> <span class="nf">equiv_path_groupisomorphism</span> `{F : Funext} {G H : Group}
  (f g : GroupIsomorphism G H)
  : f == g &lt;~&gt; f = g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g &lt;~&gt; f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk27"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g &lt;~&gt; f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk28"><span class="nb">refine</span> ((equiv_ap (issig_GroupIsomorphism G H)^-<span class="mi">1</span> _ _)^-<span class="mi">1</span> oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g &lt;~&gt;
(issig_GroupIsomorphism G H)^-<span class="mi">1</span> f =
(issig_GroupIsomorphism G H)^-<span class="mi">1</span> g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk29"><span class="nb">refine</span> (equiv_path_sigma_hprop _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g &lt;~&gt;
((issig_GroupIsomorphism G H)^-<span class="mi">1</span> f).<span class="mi">1</span> =
((issig_GroupIsomorphism G H)^-<span class="mi">1</span> g).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_path_grouphomomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group isomorphisms form a set. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk2a"><span class="kn">Definition</span> <span class="nf">ishset_groupisomorphism</span> `{F : Funext} {G H : Group}
  : IsHSet (GroupIsomorphism G H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (GroupIsomorphism G H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk2b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (GroupIsomorphism G H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk2c"><span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_mere_relation (GroupIsomorphism G H) paths</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> f g; <span class="nb">apply</span> (istrunc_equiv_istrunc _ (equiv_path_groupisomorphism _ _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The identity map is an equivalence and therefore a group isomorphism. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_iso_id</span> {<span class="nv">G</span> : Group} : GroupIsomorphism G G
  := Build_GroupIsomorphism _ _ grp_homo_id _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group isomorphisms can be composed by composing the underlying group homomorphism. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_iso_compose</span> {<span class="nv">G</span> <span class="nv">H</span> <span class="nv">K</span> : Group}
  (<span class="nv">g</span> : GroupIsomorphism H K) (<span class="nv">f</span> : GroupIsomorphism G H)
  : GroupIsomorphism G K
  := Build_GroupIsomorphism _ _ (grp_homo_compose g f) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group isomorphisms can be inverted. The inverse map of the underlying equivalence also preserves the group operation and unit. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk2d"><span class="kn">Definition</span> <span class="nf">grp_iso_inverse</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  : GroupIsomorphism G H -&gt; GroupIsomorphism H G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G H -&gt; GroupIsomorphism H G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk2e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G H -&gt; GroupIsomorphism H G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk2f"><span class="nb">intros</span> [f e].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism H G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk30">srapply Build_GroupIsomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism H G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk31" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><label class="goal-separator" for="group-v-chk31"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?grp_iso_homo</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk32">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism H G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">srapply (Build_GroupHomomorphism f^-<span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk33">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>IsEquiv f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  {|
    grp_homo_map := f^-<span class="mi">1</span>;
    issemigrouppreserving_grp_homo := monmor_sgmor
  |}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group isomorphism is a reflexive relation. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">reflexive_groupisomorphism</span>
  : Reflexive GroupIsomorphism
  := <span class="kr">fun</span> <span class="nv">G</span> =&gt; grp_iso_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group isomorphism is a symmetric relation. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">symmetric_groupisomorphism</span>
  : Symmetric GroupIsomorphism
  := <span class="kr">fun</span> <span class="nv">G</span> <span class="nv">H</span> =&gt; grp_iso_inverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group isomorphism is a transitive relation. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">transitive_groupisomorphism</span>
  : Transitive GroupIsomorphism
  := <span class="kr">fun</span> <span class="nv">G</span> <span class="nv">H</span> <span class="nv">K</span> <span class="nv">f</span> <span class="nv">g</span> =&gt; grp_iso_compose g f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Under univalence, equality of groups is equivalent to isomorphism of groups. This is the structure identity principle for groups. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk34"><span class="kn">Definition</span> <span class="nf">equiv_path_group&#39;</span> {<span class="nv">U</span> : Univalence} {<span class="nv">G</span> <span class="nv">H</span> : Group}
  : GroupIsomorphism G H &lt;~&gt; G = H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G H &lt;~&gt; G = H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G H &lt;~&gt; G = H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk36">equiv_via {f : G &lt;~&gt; H &amp; IsSemiGroupPreserving f}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism G H &lt;~&gt;
{f : G &lt;~&gt; H &amp; IsSemiGroupPreserving f}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk37" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk37"><hr></label><div class="goal-conclusion">{f : G &lt;~&gt; H &amp; IsSemiGroupPreserving f} &lt;~&gt; G = H</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk38"><span class="mi">1</span>: make_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : G &lt;~&gt; H &amp; IsSemiGroupPreserving f} &lt;~&gt; G = H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk39"><span class="nb">revert</span> G H; <span class="nb">apply</span> (equiv_path_issig_contr issig_group).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">b</span> : {H : <span class="kt">Type</span> &amp;
    {H0 : SgOp H &amp;
    {H1 : MonUnit H &amp; {H2 : Negate H &amp; IsGroup H}}}},
{f : issig_group b &lt;~&gt; issig_group b &amp;
IsSemiGroupPreserving f}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk3a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><label class="goal-separator" for="group-v-chk3a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">b1</span> : {H : <span class="kt">Type</span> &amp;
     {H0 : SgOp H &amp;
     {H1 : MonUnit H &amp; {H2 : Negate H &amp; IsGroup H}}}},
Contr
  {b2
  : {H : <span class="kt">Type</span> &amp;
    {H0 : SgOp H &amp;
    {H1 : MonUnit H &amp; {H2 : Negate H &amp; IsGroup H}}}} &amp;
  {f : issig_group b1 &lt;~&gt; issig_group b2 &amp;
  IsSemiGroupPreserving f}}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk3b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">b</span> : {H : <span class="kt">Type</span> &amp;
    {H0 : SgOp H &amp;
    {H1 : MonUnit H &amp; {H2 : Negate H &amp; IsGroup H}}}},
{f : issig_group b &lt;~&gt; issig_group b &amp;
IsSemiGroupPreserving f}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk3c"><span class="nb">intros</span> [G [? [? [? ?]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f
: issig_group (G; proj1; proj0; proj2; proj3) &lt;~&gt;
  issig_group (G; proj1; proj0; proj2; proj3) &amp;
IsSemiGroupPreserving f}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk3d"><span class="kr">exists</span> <span class="mi">1</span>%equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>proj1</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>proj0</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>proj2</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>proj3</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving <span class="mi">1</span>%equiv</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk3e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">b1</span> : {H : <span class="kt">Type</span> &amp;
     {H0 : SgOp H &amp;
     {H1 : MonUnit H &amp; {H2 : Negate H &amp; IsGroup H}}}},
Contr
  {b2
  : {H : <span class="kt">Type</span> &amp;
    {H0 : SgOp H &amp;
    {H1 : MonUnit H &amp; {H2 : Negate H &amp; IsGroup H}}}} &amp;
  {f : issig_group b1 &lt;~&gt; issig_group b2 &amp;
  IsSemiGroupPreserving f}}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk3f"><span class="nb">intros</span> [G [op [unit [neg ax]]]]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {b2
  : {H : <span class="kt">Type</span> &amp;
    {H0 : SgOp H &amp;
    {H1 : MonUnit H &amp; {H2 : Negate H &amp; IsGroup H}}}} &amp;
  {f : G &lt;~&gt; b2.<span class="mi">1</span> &amp; IsSemiGroupPreserving f}}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk40">contr_sigsig G (equiv_idmap G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr
  {y
  : {H0 : SgOp G &amp;
    {H1 : MonUnit G &amp; {H2 : Negate G &amp; IsGroup G}}} &amp;
  IsSemiGroupPreserving <span class="mi">1</span>%equiv}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk41">srefine (Build_Contr _ ((_;(_;(_;_)));_) _); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsGroup G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk42" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br></div><label class="goal-separator" for="group-v-chk42"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk43" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br></div><label class="goal-separator" for="group-v-chk43"><hr></label><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">y</span> : {y
    : {H0 : SgOp G &amp;
      {H1 : MonUnit G &amp; {H2 : Negate G &amp; IsGroup G}}}
    &amp; IsSemiGroupPreserving idmap},
((op; unit; neg; <span class="nl">?Goal</span>); <span class="nl">?Goal0</span>) = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk44"><span class="mi">1</span>: <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk45" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br></div><label class="goal-separator" for="group-v-chk45"><hr></label><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">y</span> : {y
    : {H0 : SgOp G &amp;
      {H1 : MonUnit G &amp; {H2 : Negate G &amp; IsGroup G}}}
    &amp; IsSemiGroupPreserving idmap},
((op; unit; neg; ax); <span class="nl">?Goal</span>) = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk46"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">y</span> : {y
    : {H0 : SgOp G &amp;
      {H1 : MonUnit G &amp; {H2 : Negate G &amp; IsGroup G}}}
    &amp; IsSemiGroupPreserving idmap},
((op; unit; neg; ax); abstract_algebra.id_sg_morphism) =
y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk47"><span class="nb">intros</span> [[op&#39; [unit&#39; [neg&#39; ax&#39;]]] eq].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((op; unit; neg; ax); abstract_algebra.id_sg_morphism) =
((op&#39;; unit&#39;; neg&#39;; ax&#39;); eq)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk48"><span class="nb">apply</span> path_sigma_hprop; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(op; unit; neg; ax) = (op&#39;; unit&#39;; neg&#39;; ax&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk49"><span class="nb">refine</span> (@ap _ _ (<span class="kr">fun</span> <span class="nv">x</span> : { oun :
      { oo : SgOp G &amp; { u : MonUnit G &amp; Negate G}}
      &amp; @IsGroup G oun.<span class="mi">1</span> oun.<span class="mi">2</span>.<span class="mi">1</span> oun.<span class="mi">2</span>.<span class="mi">2</span>}
      =&gt; (x.<span class="mi">1</span>.<span class="mi">1</span> ; x.<span class="mi">1</span>.<span class="mi">2</span>.<span class="mi">1</span> ; x.<span class="mi">1</span>.<span class="mi">2</span>.<span class="mi">2</span> ; x.<span class="mi">2</span>))
      ((op;unit;neg);ax) ((op&#39;;unit&#39;;neg&#39;);ax&#39;) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((op; unit; neg); ax) = ((op&#39;; unit&#39;; neg&#39;); ax&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk4a"><span class="nb">apply</span> path_sigma_hprop; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(op; unit; neg) = (op&#39;; unit&#39;; neg&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk4b">srefine (path_sigma&#39; _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">op = op&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk4c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br></div><label class="goal-separator" for="group-v-chk4c"><hr></label><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">_</span> : SgOp G =&gt; {_ : MonUnit G &amp; Negate G}) 
  <span class="nl">?p</span> (unit; neg) = (unit&#39;; neg&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk4d"><span class="mi">1</span>: funext x y; <span class="nb">apply</span> eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">_</span> : SgOp G =&gt; {_ : MonUnit G &amp; Negate G})
  (path_forall op op&#39;
     ((<span class="kr">fun</span> <span class="nv">x</span> : G =&gt;
       path_forall (op x) (op&#39; x)
         ((<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; eq x y) : op x == op&#39; x))
      :
      op == op&#39;)) (unit; neg) = (unit&#39;; neg&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk4e"><span class="nb">rewrite</span> transport_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(unit; neg) = (unit&#39;; neg&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk4f"><span class="nb">pose</span> (f := Build_GroupHomomorphism
        (G:=Build_Group G op unit neg ax)
        (H:=Build_Group G op&#39; unit&#39; neg&#39; ax&#39;)
        idmap eq).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>{|
  grp_homo_map := idmap;
  issemigrouppreserving_grp_homo := eq
|}</span></span><span class="hyp-type"><b>: </b><span>GroupHomomorphism
  {|
    group_type := G;
    group_sgop := op;
    group_unit := unit;
    group_inverse := neg;
    group_isgroup := ax
  |}
  {|
    group_type := G;
    group_sgop := op&#39;;
    group_unit := unit&#39;;
    group_inverse := neg&#39;;
    group_isgroup := ax&#39;
  |}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(unit; neg) = (unit&#39;; neg&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk50">srefine (path_sigma&#39; _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>{|
  grp_homo_map := idmap;
  issemigrouppreserving_grp_homo := eq
|}</span></span><span class="hyp-type"><b>: </b><span>GroupHomomorphism
  {|
    group_type := G;
    group_sgop := op;
    group_unit := unit;
    group_inverse := neg;
    group_isgroup := ax
  |}
  {|
    group_type := G;
    group_sgop := op&#39;;
    group_unit := unit&#39;;
    group_inverse := neg&#39;;
    group_isgroup := ax&#39;
  |}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">unit = unit&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>{|
  grp_homo_map := idmap;
  issemigrouppreserving_grp_homo := eq
|}</span></span><span class="hyp-type"><b>: </b><span>GroupHomomorphism
  {|
    group_type := G;
    group_sgop := op;
    group_unit := unit;
    group_inverse := neg;
    group_isgroup := ax
  |}
  {|
    group_type := G;
    group_sgop := op&#39;;
    group_unit := unit&#39;;
    group_inverse := neg&#39;;
    group_isgroup := ax&#39;
  |}</span></span></span></span><br></div><label class="goal-separator" for="group-v-chk51"><hr></label><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">_</span> : MonUnit G =&gt; Negate G) <span class="nl">?p</span> neg =
neg&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk52"><span class="mi">1</span>: <span class="bp">exact</span> (grp_homo_unit f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>{|
  grp_homo_map := idmap;
  issemigrouppreserving_grp_homo := eq
|}</span></span><span class="hyp-type"><b>: </b><span>GroupHomomorphism
  {|
    group_type := G;
    group_sgop := op;
    group_unit := unit;
    group_inverse := neg;
    group_isgroup := ax
  |}
  {|
    group_type := G;
    group_sgop := op&#39;;
    group_unit := unit&#39;;
    group_inverse := neg&#39;;
    group_isgroup := ax&#39;
  |}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">_</span> : MonUnit G =&gt; Negate G)
  (grp_homo_unit f) neg = neg&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk53">lhs nrapply transport_const.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>{|
  grp_homo_map := idmap;
  issemigrouppreserving_grp_homo := eq
|}</span></span><span class="hyp-type"><b>: </b><span>GroupHomomorphism
  {|
    group_type := G;
    group_sgop := op;
    group_unit := unit;
    group_inverse := neg;
    group_isgroup := ax
  |}
  {|
    group_type := G;
    group_sgop := op&#39;;
    group_unit := unit&#39;;
    group_inverse := neg&#39;;
    group_isgroup := ax&#39;
  |}</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">neg = neg&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk54">funext x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>U</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>op</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>op'</var><span class="hyp-type"><b>: </b><span>SgOp G</span></span></span><br><span><var>unit'</var><span class="hyp-type"><b>: </b><span>MonUnit G</span></span></span><br><span><var>neg'</var><span class="hyp-type"><b>: </b><span>Negate G</span></span></span><br><span><var>ax'</var><span class="hyp-type"><b>: </b><span>IsGroup G</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>IsSemiGroupPreserving idmap</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span>{|
  grp_homo_map := idmap;
  issemigrouppreserving_grp_homo := eq
|}</span></span><span class="hyp-type"><b>: </b><span>GroupHomomorphism
  {|
    group_type := G;
    group_sgop := op;
    group_unit := unit;
    group_inverse := neg;
    group_isgroup := ax
  |}
  {|
    group_type := G;
    group_sgop := op&#39;;
    group_unit := unit&#39;;
    group_inverse := neg&#39;;
    group_isgroup := ax&#39;
  |}</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">neg x = neg&#39; x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_homo_inv f x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A version with nicer universe variables. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_group</span>@{u v | u &lt; v} {U : Univalence} {G H : Group@{u}}
  : GroupIsomorphism G H &lt;~&gt; (paths@{v} G H)
  := equiv_path_group&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Simple group equivalences *)</span>

<span class="sd">(** Left multiplication is an equivalence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk55"><span class="kn">Global Instance</span> <span class="nf">isequiv_group_left_op</span> {<span class="nv">G</span> : Group}
  : <span class="kr">forall</span> (<span class="nv">x</span> : G), IsEquiv (x *.).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, IsEquiv (sg_op x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk56"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, IsEquiv (sg_op x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk57"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (sg_op x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk58">srapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk59"><hr></label><div class="goal-conclusion">sg_op x o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk5a"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o sg_op x == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk5b"><span class="mi">1</span>: <span class="bp">exact</span> (-x *.).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sg_op x o sg_op (- x) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk5c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk5c"><hr></label><div class="goal-conclusion">sg_op (- x) o sg_op x == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk5d"><span class="kp">all</span>: <span class="nb">intro</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * (- x * y) = y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk5e"><hr></label><div class="goal-conclusion">- x * (x * y) = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk5f"><span class="kp">all</span>: <span class="nb">refine</span> (grp_assoc _ _ _ @ _ @ grp_unit_l y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * - x * y = mon_unit * y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk60"><hr></label><div class="goal-conclusion">- x * x * y = mon_unit * y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk61"><span class="kp">all</span>: <span class="nb">refine</span> (ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x * y) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * - x = mon_unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk62" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk62"><hr></label><div class="goal-conclusion">- x * x = mon_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk63"><span class="mi">1</span>: <span class="nb">apply</span> grp_inv_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- x * x = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_inv_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Right multiplication is an equivalence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk64"><span class="kn">Global Instance</span> <span class="nf">isequiv_group_right_op</span> (<span class="nv">G</span> : Group)
  : <span class="kr">forall</span> (<span class="nv">x</span> : G), IsEquiv (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y * x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, IsEquiv (<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk65"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, IsEquiv (<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk66"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk67">srapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk68" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk68"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x) o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk69" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk69"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o (<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk6a"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y * - x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x) o (<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * - x) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk6b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk6b"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * - x) o (<span class="kr">fun</span> <span class="nv">y</span> : G =&gt; y * x) == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk6c"><span class="kp">all</span>: <span class="nb">intro</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y * - x * x = y</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk6d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk6d"><hr></label><div class="goal-conclusion">y * x * - x = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk6e"><span class="kp">all</span>: <span class="nb">refine</span> ((grp_assoc _ _ _)^ @ _ @ grp_unit_r y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y * (- x * x) = y * mon_unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk6f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk6f"><hr></label><div class="goal-conclusion">y * (x * - x) = y * mon_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk70"><span class="kp">all</span>: <span class="nb">refine</span> (ap (y *.) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- x * x = mon_unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk71" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk71"><hr></label><div class="goal-conclusion">x * - x = mon_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk72"><span class="mi">1</span>: <span class="nb">apply</span> grp_inv_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x * - x = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_inv_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The operation inverting group elements is an equivalence. Note that, since the order of the operation will change after inversion, this isn&#39;t a group homomorphism. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk73"><span class="kn">Global Instance</span> <span class="nf">isequiv_group_inverse</span> {<span class="nv">G</span> : Group}
  : IsEquiv ((-) : G -&gt; G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (negate : G -&gt; G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk74"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (negate : G -&gt; G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk75">srapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk76" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk76"><hr></label><div class="goal-conclusion">negate o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk77" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk77"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o negate == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk78"><span class="mi">1</span>: <span class="nb">apply</span> (-).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">negate o negate == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk79" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk79"><hr></label><div class="goal-conclusion">negate o negate == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">intro</span>; <span class="nb">apply</span> negate_involutive.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Reasoning with equations in groups. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">GroupEquations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">G</span> : Group} (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Inverses are involutive. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_inv_inv</span> : --x = x := negate_involutive x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Inverses distribute over the group operation. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_inv_op</span> : - (x * y) = -y * -x := negate_sg_op x y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** The inverse of the unit is the unit. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_inv_unit</span> : -mon_unit = mon_unit := negate_mon_unit (G :=G).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">GroupEquations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Cancelation lemmas *)</span>

<span class="sd">(** Group elements can be cancelled both on the left and the right. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_cancelL</span> {<span class="nv">G</span> : Group} {<span class="nv">x</span> <span class="nv">y</span> : G} <span class="nv">z</span> : x = y &lt;~&gt; z * x = z * y
  := equiv_ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; z * x) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_cancelR</span> {<span class="nv">G</span> : Group} {<span class="nv">x</span> <span class="nv">y</span> : G} <span class="nv">z</span> : x = y &lt;~&gt; x * z = y * z
  := equiv_ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x * z) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Group movement lemmas *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">GroupMovement</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Since left/right multiplication is an equivalence, we can use lemmas about moving equivalences around to prove group movement lemmas. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">G</span> : Group} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Moving group elements *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveL_gM</span> : x * -z = y &lt;~&gt; x = y * z
    := equiv_moveL_equiv_M (f := <span class="kr">fun</span> <span class="nv">t</span> =&gt; t * z) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveL_Mg</span> : -y * x = z &lt;~&gt; x = y * z
    := equiv_moveL_equiv_M (f := <span class="kr">fun</span> <span class="nv">t</span> =&gt; y * t) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveR_gM</span> : x = z * -y &lt;~&gt; x * y = z
    := equiv_moveR_equiv_M (f := <span class="kr">fun</span> <span class="nv">t</span> =&gt; t * y) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveR_Mg</span> : y = -x * z &lt;~&gt; x * y = z
    := equiv_moveR_equiv_M (f := <span class="kr">fun</span> <span class="nv">t</span> =&gt; x * t) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Moving inverses.*)</span>
  <span class="sd">(** These are the inverses of the previous but are included here for completeness*)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveR_gV</span> : x = y * z &lt;~&gt; x * -z = y
    := equiv_moveR_equiv_V (f := <span class="kr">fun</span> <span class="nv">t</span> =&gt; t * z) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveR_Vg</span> : x = y * z &lt;~&gt; -y * x = z 
    := equiv_moveR_equiv_V (f := <span class="kr">fun</span> <span class="nv">t</span> =&gt; y * t) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveL_gV</span> :  x * y = z &lt;~&gt; x = z * -y
    := equiv_moveL_equiv_V (f := <span class="kr">fun</span> <span class="nv">t</span> =&gt; t * y) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveL_Vg</span> :  x * y = z &lt;~&gt; y = -x * z
    := equiv_moveL_equiv_V (f := <span class="kr">fun</span> <span class="nv">t</span> =&gt; x * t) _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We close the section here so the previous lemmas generalise their assumptions. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">GroupMovement</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">GroupMovement</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">G</span> : Group} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Moving elements equal to unit. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveL_1M</span> : x * -y = mon_unit &lt;~&gt; x = y
    := equiv_concat_r (grp_unit_l _) _ oE grp_moveL_gM.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveL_1V</span> : x * y = mon_unit &lt;~&gt; x = -y
    := equiv_concat_r (grp_unit_l _) _ oE grp_moveL_gV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveL_M1</span> : -y * x = mon_unit &lt;~&gt; x = y
    := equiv_concat_r (grp_unit_r _) _ oE grp_moveL_Mg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveR_1M</span> : mon_unit = y * (-x) &lt;~&gt; x = y
    := (equiv_concat_l (grp_unit_l _) _)^-<span class="mi">1</span>%equiv oE grp_moveR_gM.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_moveR_M1</span> : mon_unit = -x * y &lt;~&gt; x = y
    := (equiv_concat_l (grp_unit_r _) _)^-<span class="mi">1</span>%equiv oE grp_moveR_Mg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** *** Cancelling elements equal to unit. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_cancelL1</span> : x = mon_unit &lt;~&gt; z * x = z
    := (equiv_concat_r (grp_unit_r _) _ oE grp_cancelL z).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_cancelR1</span> : x = mon_unit &lt;~&gt; x * z = z
    := (equiv_concat_r (grp_unit_l _) _) oE grp_cancelR z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">GroupMovement</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Commutation *)</span>

<span class="sd">(** If [g] commutes with [h], then [g] commutes with the inverse [-h]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk7a"><span class="kn">Definition</span> <span class="nf">grp_commutes_inv</span> {<span class="nv">G</span> : Group} (<span class="nv">g</span> <span class="nv">h</span> : G) (<span class="nv">p</span> : g * h = h * g)
  : g * (-h) = (-h) * g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * - h = - h * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk7b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * - h = - h * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk7c"><span class="nb">apply</span> grp_moveR_gV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g = - h * g * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk7d">rhs_V <span class="nb">apply</span> simple_associativity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g = - h * (g * h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> grp_moveL_Vg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If [g] commutes with [h] and [h&#39;], then [g] commutes with their product [h * h&#39;]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk7e"><span class="kn">Definition</span> <span class="nf">grp_commutes_op</span> {<span class="nv">G</span> : Group} (<span class="nv">g</span> <span class="nv">h</span> <span class="nv">h&#39;</span> : G)
  (<span class="nv">p</span> : g * h = h * g) (<span class="nv">p&#39;</span> : g * h&#39; = h&#39; * g)
  : g * (h * h&#39;) = (h * h&#39;) * g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h, h'</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>g * h&#39; = h&#39; * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * (h * h&#39;) = h * h&#39; * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk7f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h, h'</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>g * h&#39; = h&#39; * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * (h * h&#39;) = h * h&#39; * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk80">lhs <span class="nb">apply</span> simple_associativity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h, h'</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>g * h&#39; = h&#39; * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * h * h&#39; = h * h&#39; * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk81">lhs nrapply (ap (.* h&#39;) p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h, h'</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>g * h&#39; = h&#39; * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * g * h&#39; = h * h&#39; * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk82">lhs_V <span class="nb">apply</span> simple_associativity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h, h'</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>g * h&#39; = h&#39; * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * (g * h&#39;) = h * h&#39; * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk83">lhs nrapply (ap (h *.) p&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h, h'</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>p'</var><span class="hyp-type"><b>: </b><span>g * h&#39; = h&#39; * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * (h&#39; * g) = h * h&#39; * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> simple_associativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Power operation *)</span>

<span class="sd">(** For a given [g : G] we can define the function [Int -&gt; G] sending an integer to that power of [g]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_pow</span> {<span class="nv">G</span> : Group} (<span class="nv">g</span> : G) (<span class="nv">n</span> : Int) : G
  := int_iter (g *.) n mon_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Any homomorphism respects [grp_pow]. In other words, [fun g =&gt; grp_pow g n] is natural. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk84"><span class="kn">Lemma</span> <span class="nf">grp_pow_natural</span> {<span class="nv">G</span> <span class="nv">H</span> : Group} (<span class="nv">f</span> : GroupHomomorphism G H) (<span class="nv">n</span> : Int) (<span class="nv">g</span> : G)
  : f (grp_pow g n) = grp_pow (f g) n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (grp_pow g n) = grp_pow (f g) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk85"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (grp_pow g n) = grp_pow (f g) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk86">lhs snrapply (int_iter_commute_map _ ((f g) *.)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; f (g * x)) == (<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; f g * f x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk87" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><label class="goal-separator" for="group-v-chk87"><hr></label><div class="goal-conclusion">int_iter (sg_op (f g)) n (f mon_unit) =
grp_pow (f g) n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk88"><span class="mi">1</span>: nrapply grp_homo_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G H</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">int_iter (sg_op (f g)) n (f mon_unit) =
grp_pow (f g) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (ap (int_iter _ n)), grp_homo_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** All powers of the unit are the unit. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk89"><span class="kn">Definition</span> <span class="nf">grp_pow_unit</span> {<span class="nv">G</span> : Group} (<span class="nv">n</span> : Int)
  : grp_pow (G:=G) mon_unit n = mon_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow mon_unit n = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk8a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow mon_unit n = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk8b">snrapply (int_iter_invariant n _ (<span class="kr">fun</span> <span class="nv">g</span> =&gt; g = mon_unit)); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G, x = mon_unit -&gt; mon_unit * x = mon_unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk8c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><label class="goal-separator" for="group-v-chk8c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
x = mon_unit -&gt; - mon_unit * x = mon_unit</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk8d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><label class="goal-separator" for="group-v-chk8d"><hr></label><div class="goal-conclusion">mon_unit = mon_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk8e"><span class="mi">1</span>, <span class="mi">2</span>: <span class="nb">apply</span> paths_ind_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mon_unit * mon_unit = mon_unit</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk8f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><label class="goal-separator" for="group-v-chk8f"><hr></label><div class="goal-conclusion">- mon_unit * mon_unit = mon_unit</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk90" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><label class="goal-separator" for="group-v-chk90"><hr></label><div class="goal-conclusion">mon_unit = mon_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk91">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mon_unit * mon_unit = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_unit_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk92">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- mon_unit * mon_unit = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk93">lhs nrapply grp_unit_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- mon_unit = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_inv_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk94">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mon_unit = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Note that powers don&#39;t preserve the group operation as it is not commutative. This does hold in an abelian group so such a result will appear later. *)</span>

<span class="sd">(** The next two results tell us how [grp_pow] unfolds. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_pow_succ</span> {<span class="nv">G</span> : Group} (<span class="nv">n</span> : Int) (<span class="nv">g</span> : G)
  : grp_pow g (n.+<span class="mi">1</span>)%int = g * grp_pow g n
  := int_iter_succ_l _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_pow_pred</span> {<span class="nv">G</span> : Group} (<span class="nv">n</span> : Int) (<span class="nv">g</span> : G)
  : grp_pow g (n.-<span class="mi">1</span>)%int = (- g) * grp_pow g n
  := int_iter_pred_l _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [grp_pow] satisfies an additive law of exponents. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk95"><span class="kn">Definition</span> <span class="nf">grp_pow_add</span> {<span class="nv">G</span> : Group} (<span class="nv">m</span> <span class="nv">n</span> : Int) (<span class="nv">g</span> : G)
  : grp_pow g (n + m)%int = grp_pow g n * grp_pow g m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (n + m)%int = grp_pow g n * grp_pow g m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk96"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (n + m)%int = grp_pow g n * grp_pow g m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk97">lhs nrapply int_iter_add.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">int_iter (sg_op g) n (int_iter (sg_op g) m mon_unit) =
grp_pow g n * grp_pow g m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk98"><span class="nb">induction</span> n; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">int_iter (sg_op g) m mon_unit = mon_unit * grp_pow g m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk99" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>int_iter (sg_op g) n (int_iter (sg_op g) m mon_unit) =
grp_pow g n * grp_pow g m</span></span></span><br></div><label class="goal-separator" for="group-v-chk99"><hr></label><div class="goal-conclusion">int_iter (sg_op g) n.+<span class="mi">1</span>%int
  (int_iter (sg_op g) m mon_unit) =
grp_pow g n.+<span class="mi">1</span>%int * grp_pow g m</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk9a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>int_iter (sg_op g) (- n)%int (int_iter (sg_op g) m mon_unit) =
grp_pow g (- n)%int * grp_pow g m</span></span></span><br></div><label class="goal-separator" for="group-v-chk9a"><hr></label><div class="goal-conclusion">int_iter (sg_op g) (- n).-<span class="mi">1</span>%int
  (int_iter (sg_op g) m mon_unit) =
grp_pow g (- n).-<span class="mi">1</span>%int * grp_pow g m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk9b"><span class="mi">1</span>: <span class="bp">exact</span> (grp_unit_l _)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>int_iter (sg_op g) n (int_iter (sg_op g) m mon_unit) =
grp_pow g n * grp_pow g m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">int_iter (sg_op g) n.+<span class="mi">1</span>%int
  (int_iter (sg_op g) m mon_unit) =
grp_pow g n.+<span class="mi">1</span>%int * grp_pow g m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk9c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>int_iter (sg_op g) (- n)%int (int_iter (sg_op g) m mon_unit) =
grp_pow g (- n)%int * grp_pow g m</span></span></span><br></div><label class="goal-separator" for="group-v-chk9c"><hr></label><div class="goal-conclusion">int_iter (sg_op g) (- n).-<span class="mi">1</span>%int
  (int_iter (sg_op g) m mon_unit) =
grp_pow g (- n).-<span class="mi">1</span>%int * grp_pow g m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk9d"><span class="mi">1</span>: <span class="nb">rewrite</span> int_iter_succ_l, grp_pow_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>int_iter (sg_op g) n (int_iter (sg_op g) m mon_unit) =
grp_pow g n * grp_pow g m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g *
int_iter (sg_op g) n (int_iter (sg_op g) m mon_unit) =
g * grp_pow g n * grp_pow g m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk9e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>int_iter (sg_op g) (- n)%int (int_iter (sg_op g) m mon_unit) =
grp_pow g (- n)%int * grp_pow g m</span></span></span><br></div><label class="goal-separator" for="group-v-chk9e"><hr></label><div class="goal-conclusion">int_iter (sg_op g) (- n).-<span class="mi">1</span>%int
  (int_iter (sg_op g) m mon_unit) =
grp_pow g (- n).-<span class="mi">1</span>%int * grp_pow g m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk9f"><span class="mi">2</span>: <span class="nb">rewrite</span> int_iter_pred_l, grp_pow_pred; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>int_iter (sg_op g) n (int_iter (sg_op g) m mon_unit) =
grp_pow g n * grp_pow g m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g *
int_iter (sg_op g) n (int_iter (sg_op g) m mon_unit) =
g * grp_pow g n * grp_pow g m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chka0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>int_iter (sg_op g) (- n)%int (int_iter (sg_op g) m mon_unit) =
grp_pow g (- n)%int * grp_pow g m</span></span></span><br></div><label class="goal-separator" for="group-v-chka0"><hr></label><div class="goal-conclusion">- g *
int_iter (sg_op g) (- n)%int
  (int_iter (sg_op g) m mon_unit) =
- g * grp_pow g (- n)%int * grp_pow g m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="mi">1</span>,<span class="mi">2</span> : rhs_V srapply associativity;
        <span class="nb">apply</span> ap, IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [grp_pow] commutes negative exponents to powers of the inverse *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka1"><span class="kn">Definition</span> <span class="nf">grp_pow_neg</span> {<span class="nv">G</span> : Group} (<span class="nv">n</span> : Int) (<span class="nv">g</span> : G)
  : grp_pow g (int_neg n) = grp_pow (- g) n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- n)%int = grp_pow (- g) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- n)%int = grp_pow (- g) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka3">lhs nrapply int_iter_neg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">int_iter (sg_op g)^-<span class="mi">1</span> n mon_unit = grp_pow (- g) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka4"><span class="nb">cbn</span>; <span class="nb">unfold</span> grp_pow.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">int_iter (sg_op (- g)) n mon_unit =
int_iter (sg_op (- g)) n mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* These agree, except for the proofs that [sg_op (-g)] is an equivalence. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> int_iter_agree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Using a negative power in [grp_pow] is the same as first using a positive power and then inverting the result. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka5"><span class="kn">Definition</span> <span class="nf">grp_pow_neg_inv</span> {<span class="nv">G</span>: Group} (<span class="nv">m</span> : Int) (<span class="nv">g</span> : G) : grp_pow g (- m)%int = - grp_pow g m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- m)%int = - grp_pow g m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- m)%int = - grp_pow g m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka7"><span class="nb">apply</span> grp_moveL_1V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- m)%int * grp_pow g m = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka8">lhs_V nrapply grp_pow_add.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- m + m)%int = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> int_add_neg_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Combining the two previous results gives that a power of an inverse is the inverse of the power. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chka9"><span class="kn">Definition</span> <span class="nf">grp_pow_neg_inv&#39;</span> {<span class="nv">G</span>: Group} (<span class="nv">n</span>: Int) (<span class="nv">g</span> : G) : grp_pow (- g) n = - grp_pow g n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (- g) n = - grp_pow g n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkaa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (- g) n = - grp_pow g n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkab">lhs_V nrapply grp_pow_neg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- n)%int = - grp_pow g n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_pow_neg_inv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [grp_pow] satisfies a multiplicative law of exponents. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkac"><span class="kn">Definition</span> <span class="nf">grp_pow_int_mul</span> {<span class="nv">G</span> : Group} (<span class="nv">m</span> <span class="nv">n</span> : Int) (<span class="nv">g</span> : G)
  : grp_pow g (m * n)%int = grp_pow (grp_pow g m) n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (m * n)%int = grp_pow (grp_pow g m) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkad"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (m * n)%int = grp_pow (grp_pow g m) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkae"><span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (m * <span class="mi">0</span>)%int = grp_pow (grp_pow g m) <span class="mi">0</span>%int</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chkaf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * n)%int = grp_pow (grp_pow g m) n</span></span></span><br></div><label class="goal-separator" for="group-v-chkaf"><hr></label><div class="goal-conclusion">grp_pow g (m * n.+<span class="mi">1</span>)%int =
grp_pow (grp_pow g m) n.+<span class="mi">1</span>%int</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chkb0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * - n)%int = grp_pow (grp_pow g m) (- n)%int</span></span></span><br></div><label class="goal-separator" for="group-v-chkb0"><hr></label><div class="goal-conclusion">grp_pow g (m * (- n).-<span class="mi">1</span>)%int =
grp_pow (grp_pow g m) (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (m * <span class="mi">0</span>)%int = grp_pow (grp_pow g m) <span class="mi">0</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb2"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (m * <span class="mi">0</span>)%int = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> int_mul_0_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * n)%int = grp_pow (grp_pow g m) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (m * n.+<span class="mi">1</span>)%int =
grp_pow (grp_pow g m) n.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb4"><span class="nb">rewrite</span> int_mul_succ_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * n)%int = grp_pow (grp_pow g m) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (m + m * n)%int =
grp_pow (grp_pow g m) n.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb5"><span class="nb">rewrite</span> grp_pow_add.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * n)%int = grp_pow (grp_pow g m) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g m * grp_pow g (m * n)%int =
grp_pow (grp_pow g m) n.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb6"><span class="nb">rewrite</span> grp_pow_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * n)%int = grp_pow (grp_pow g m) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g m * grp_pow g (m * n)%int =
grp_pow g m * grp_pow (grp_pow g m) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_cancelL, IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * - n)%int = grp_pow (grp_pow g m) (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (m * (- n).-<span class="mi">1</span>)%int =
grp_pow (grp_pow g m) (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb8"><span class="nb">rewrite</span> int_mul_pred_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * - n)%int = grp_pow (grp_pow g m) (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- m + m * - n)%int =
grp_pow (grp_pow g m) (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkb9"><span class="nb">rewrite</span> grp_pow_add.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * - n)%int = grp_pow (grp_pow g m) (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow g (- m)%int * grp_pow g (m * - n)%int =
grp_pow (grp_pow g m) (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkba"><span class="nb">rewrite</span> grp_pow_neg_inv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * - n)%int = grp_pow (grp_pow g m) (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- grp_pow g m * grp_pow g (m * - n)%int =
grp_pow (grp_pow g m) (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkbb"><span class="nb">rewrite</span> grp_pow_pred.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow g (m * - n)%int = grp_pow (grp_pow g m) (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- grp_pow g m * grp_pow g (m * - n)%int =
- grp_pow g m * grp_pow (grp_pow g m) (- n)%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_cancelL, IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If [h] commutes with [g], then [h] commutes with [grp_pow g n]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkbc"><span class="kn">Definition</span> <span class="nf">grp_pow_commutes</span> {<span class="nv">G</span> : Group} (<span class="nv">n</span> : Int) (<span class="nv">g</span> <span class="nv">h</span> : G)
  (<span class="nv">p</span> : h * g = g * h)
  : h * (grp_pow g n) = (grp_pow g n) * h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * grp_pow g n = grp_pow g n * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkbd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * grp_pow g n = grp_pow g n * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkbe"><span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * grp_pow g <span class="mi">0</span>%int = grp_pow g <span class="mi">0</span>%int * h</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chkbf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g n = grp_pow g n * h</span></span></span><br></div><label class="goal-separator" for="group-v-chkbf"><hr></label><div class="goal-conclusion">h * grp_pow g n.+<span class="mi">1</span>%int = grp_pow g n.+<span class="mi">1</span>%int * h</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chkc0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g (- n)%int = grp_pow g (- n)%int * h</span></span></span><br></div><label class="goal-separator" for="group-v-chkc0"><hr></label><div class="goal-conclusion">h * grp_pow g (- n).-<span class="mi">1</span>%int =
grp_pow g (- n).-<span class="mi">1</span>%int * h</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkc1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * grp_pow g <span class="mi">0</span>%int = grp_pow g <span class="mi">0</span>%int * h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_unit_r _ @ (grp_unit_l _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkc2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g n = grp_pow g n * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * grp_pow g n.+<span class="mi">1</span>%int = grp_pow g n.+<span class="mi">1</span>%int * h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkc3"><span class="nb">rewrite</span> grp_pow_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g n = grp_pow g n * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * (g * grp_pow g n) = g * grp_pow g n * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">nrapply grp_commutes_op; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkc4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g (- n)%int = grp_pow g (- n)%int * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * grp_pow g (- n).-<span class="mi">1</span>%int =
grp_pow g (- n).-<span class="mi">1</span>%int * h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkc5"><span class="nb">rewrite</span> grp_pow_pred.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g (- n)%int = grp_pow g (- n)%int * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * (- g * grp_pow g (- n)%int) =
- g * grp_pow g (- n)%int * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkc6">nrapply grp_commutes_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g (- n)%int = grp_pow g (- n)%int * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * - g = - g * h</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chkc7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g (- n)%int = grp_pow g (- n)%int * h</span></span></span><br></div><label class="goal-separator" for="group-v-chkc7"><hr></label><div class="goal-conclusion">h * grp_pow g (- n)%int = grp_pow g (- n)%int * h</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkc8"><span class="mi">2</span>: <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>h * g = g * h</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>h * grp_pow g (- n)%int = grp_pow g (- n)%int * h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * - g = - g * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_commutes_inv, p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [grp_pow g n] commutes with [g]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkc9"><span class="kn">Definition</span> <span class="nf">grp_pow_commutes&#39;</span> {<span class="nv">G</span> : Group} (<span class="nv">n</span> : Int) (<span class="nv">g</span> : G)
  : g * grp_pow g n = grp_pow g n * g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * grp_pow g n = grp_pow g n * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkca"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * grp_pow g n = grp_pow g n * g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> grp_pow_commutes.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If [g] and [h] commute, then [grp_pow (g * h) n] = (grp_pow g n) * (grp_pow h n)]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkcb"><span class="kn">Definition</span> <span class="nf">grp_pow_mul</span> {<span class="nv">G</span> : Group} (<span class="nv">n</span> : Int) (<span class="nv">g</span> <span class="nv">h</span> : G)
  (<span class="nv">c</span> : g * h = h * g)
  : grp_pow (g * h) n = (grp_pow g n) * (grp_pow h n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (g * h) n = grp_pow g n * grp_pow h n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkcc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (g * h) n = grp_pow g n * grp_pow h n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkcd"><span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (g * h) <span class="mi">0</span>%int =
grp_pow g <span class="mi">0</span>%int * grp_pow h <span class="mi">0</span>%int</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chkce" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><label class="goal-separator" for="group-v-chkce"><hr></label><div class="goal-conclusion">grp_pow (g * h) n.+<span class="mi">1</span>%int =
grp_pow g n.+<span class="mi">1</span>%int * grp_pow h n.+<span class="mi">1</span>%int</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chkcf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><label class="goal-separator" for="group-v-chkcf"><hr></label><div class="goal-conclusion">grp_pow (g * h) (- n).-<span class="mi">1</span>%int =
grp_pow g (- n).-<span class="mi">1</span>%int * grp_pow h (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (g * h) <span class="mi">0</span>%int =
grp_pow g <span class="mi">0</span>%int * grp_pow h <span class="mi">0</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd1"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mon_unit = mon_unit * mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; nrapply grp_unit_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (g * h) n.+<span class="mi">1</span>%int =
grp_pow g n.+<span class="mi">1</span>%int * grp_pow h n.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd3"><span class="nb">rewrite</span> <span class="mi">3</span> grp_pow_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * h * grp_pow (g * h) n =
g * grp_pow g n * (h * grp_pow h n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd4"><span class="nb">rewrite</span> IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * h * (grp_pow g n * grp_pow h n) =
g * grp_pow g n * (h * grp_pow h n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd5"><span class="nb">rewrite</span> <span class="mi">2</span> grp_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * h * grp_pow g n * grp_pow h n =
g * grp_pow g n * h * grp_pow h n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd6"><span class="nb">apply</span> grp_cancelR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * h * grp_pow g n = g * grp_pow g n * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd7"><span class="nb">rewrite</span> &lt;- <span class="mi">2</span> grp_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g * (h * grp_pow g n) = g * (grp_pow g n * h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd8"><span class="nb">apply</span> grp_cancelL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * grp_pow g n = grp_pow g n * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkd9"><span class="nb">apply</span> grp_pow_commutes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) n = grp_pow g n * grp_pow h n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h * g = g * h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> c^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkda">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (g * h) (- n).-<span class="mi">1</span>%int =
grp_pow g (- n).-<span class="mi">1</span>%int * grp_pow h (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkdb"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (g * h) (- n).-<span class="mi">1</span>%int =
grp_pow g (- n).-<span class="mi">1</span>%int * grp_pow h (- n).-<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkdc"><span class="nb">rewrite</span> <span class="mi">3</span> grp_pow_pred.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- (g * h) * grp_pow (g * h) (- n)%int =
- g * grp_pow g (- n)%int *
(- h * grp_pow h (- n)%int)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkdd"><span class="nb">rewrite</span> IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- (g * h) *
(grp_pow g (- n)%int * grp_pow h (- n)%int) =
- g * grp_pow g (- n)%int *
(- h * grp_pow h (- n)%int)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkde"><span class="nb">rewrite</span> <span class="mi">2</span> grp_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- (g * h) * grp_pow g (- n)%int * grp_pow h (- n)%int =
- g * grp_pow g (- n)%int * - h * grp_pow h (- n)%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkdf"><span class="nb">apply</span> grp_cancelR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- (g * h) * grp_pow g (- n)%int =
- g * grp_pow g (- n)%int * - h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke0"><span class="nb">rewrite</span> c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- (h * g) * grp_pow g (- n)%int =
- g * grp_pow g (- n)%int * - h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke1"><span class="nb">rewrite</span> grp_inv_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- g * - h * grp_pow g (- n)%int =
- g * grp_pow g (- n)%int * - h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke2"><span class="nb">rewrite</span> &lt;- <span class="mi">2</span> grp_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- g * (- h * grp_pow g (- n)%int) =
- g * (grp_pow g (- n)%int * - h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke3"><span class="nb">apply</span> grp_cancelL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- h * grp_pow g (- n)%int = grp_pow g (- n)%int * - h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke4"><span class="nb">apply</span> grp_pow_commutes.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>g, h</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>g * h = h * g</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>grp_pow (g * h) (- n)%int = grp_pow g (- n)%int * grp_pow h (- n)%int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- h * g = g * - h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> grp_commutes_inv, c.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The category of Groups *)</span>

<span class="sd">(** ** Groups together with homomorphisms form a 1-category whose equivalences are the group isomorphisms. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">isgraph_group</span> : IsGraph Group
  := Build_IsGraph Group GroupHomomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">is01cat_group</span> : Is01Cat Group :=
  Build_Is01Cat Group _ (@grp_homo_id) (@grp_homo_compose).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Helper notation so that the wildcat instances can easily be inferred. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">grp_homo_map&#39;</span> A B := (@grp_homo_map A B : _ -&gt; (group_type A $-&gt; _)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">is2graph_group</span> : Is2Graph Group
  := <span class="kr">fun</span> <span class="nv">A</span> <span class="nv">B</span> =&gt; isgraph_induced (grp_homo_map&#39; A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">isgraph_grouphomomorphism</span> {<span class="nv">A</span> <span class="nv">B</span> : Group} : IsGraph (A $-&gt; B)
  := isgraph_induced (grp_homo_map&#39; A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">is01cat_grouphomomorphism</span> {<span class="nv">A</span> <span class="nv">B</span> : Group} : Is01Cat (A $-&gt; B)
  := is01cat_induced (grp_homo_map&#39; A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">is0gpd_grouphomomorphism</span> {<span class="nv">A</span> <span class="nv">B</span> : Group}: Is0Gpd (A $-&gt; B)
  := is0gpd_induced (grp_homo_map&#39; A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke5"><span class="kn">Global Instance</span> <span class="nf">is0functor_postcomp_grouphomomorphism</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : Group} (<span class="nv">h</span> : B $-&gt; C)
  : Is0Functor (@cat_postcomp Group _ _ A B C h).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (cat_postcomp A h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (cat_postcomp A h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke7"><span class="nb">apply</span> Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>B $-&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A $-&gt; B,
(a $-&gt; b) -&gt; cat_postcomp A h a $-&gt; cat_postcomp A h b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> f g p a ; <span class="bp">exact</span> (ap h (p a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke8"><span class="kn">Global Instance</span> <span class="nf">is0functor_precomp_grouphomomorphism</span>
       {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : Group} (<span class="nv">h</span> : A $-&gt; B)
  : Is0Functor (@cat_precomp Group _ _ A B C h).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (cat_precomp C h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chke9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor (cat_precomp C h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkea"><span class="nb">apply</span> Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : B $-&gt; C,
(a $-&gt; b) -&gt; cat_precomp C h a $-&gt; cat_precomp C h b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [f ?] [g ?] p a ; <span class="bp">exact</span> (p (h a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group forms a 1Cat *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkeb"><span class="kn">Global Instance</span> <span class="nf">is1cat_group</span> : Is1Cat Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Cat Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkec"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Cat Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> rapply Build_Is1Cat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Under [Funext], the category of groups has morphism extensionality. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chked"><span class="kn">Global Instance</span> <span class="nf">hasmorext_group</span> `{Funext} : HasMorExt Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasMorExt Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkee"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">HasMorExt Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkef">srapply Build_HasMorExt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
IsEquiv GpdHom_path</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkf0"><span class="nb">intros</span> A B f g; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv GpdHom_path</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkf1">snrapply @isequiv_homotopic.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g -&gt; f == g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chkf2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><label class="goal-separator" for="group-v-chkf2"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?f</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chkf3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><label class="goal-separator" for="group-v-chkf3"><hr></label><div class="goal-conclusion"><span class="nl">?f</span> == GpdHom_path</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkf4"><span class="mi">1</span>: <span class="bp">exact</span> (equiv_path_grouphomomorphism^-<span class="mi">1</span>%equiv).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv equiv_path_grouphomomorphism^-<span class="mi">1</span>%equiv</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chkf5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><label class="goal-separator" for="group-v-chkf5"><hr></label><div class="goal-conclusion">equiv_path_grouphomomorphism^-<span class="mi">1</span>%equiv == GpdHom_path</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkf6"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_grouphomomorphism^-<span class="mi">1</span>%equiv == GpdHom_path</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> []; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group isomorphisms become equivalences in the category of groups. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkf7"><span class="kn">Global Instance</span> <span class="nf">hasequivs_group</span>
  : HasEquivs Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">HasEquivs Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkf8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">HasEquivs Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkf9"><span class="nb">unshelve</span> <span class="nb">econstructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group -&gt; Group -&gt; <span class="kt">Type</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, (a $-&gt; b) -&gt; <span class="kt">Type</span></div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, <span class="nl">?CatEquiv&#39;</span> a b -&gt; a $-&gt; b</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : a $-&gt; b),
<span class="nl">?CatIsEquiv&#39;</span> a b f -&gt; <span class="nl">?CatEquiv&#39;</span> a b</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, <span class="nl">?CatEquiv&#39;</span> a b -&gt; b $-&gt; a</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : <span class="nl">?CatEquiv&#39;</span> a b),
<span class="nl">?CatIsEquiv&#39;</span> a b (<span class="nl">?cate_fun&#39;</span> a b f)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">fe</span> : <span class="nl">?CatIsEquiv&#39;</span> a b f),
<span class="nl">?cate_fun&#39;</span> a b (<span class="nl">?cate_buildequiv&#39;</span> a b f fe) $== f</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : <span class="nl">?CatEquiv&#39;</span> a b),
<span class="nl">?cate_inv&#39;</span> a b f $o <span class="nl">?cate_fun&#39;</span> a b f $== Id a</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : <span class="nl">?CatEquiv&#39;</span> a b),
<span class="nl">?cate_fun&#39;</span> a b f $o <span class="nl">?cate_inv&#39;</span> a b f $== Id b</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; a),
f $o g $== Id b -&gt;
g $o f $== Id a -&gt; <span class="nl">?CatIsEquiv&#39;</span> a b f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkfa">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group -&gt; Group -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> GroupIsomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkfb">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, (a $-&gt; b) -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">G</span> <span class="nv">H</span> <span class="nv">f</span> =&gt; IsEquiv f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkfc">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, GroupIsomorphism a b -&gt; a $-&gt; b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> G H f; <span class="bp">exact</span> f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkfd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : a $-&gt; b),
(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f0</span> : G $-&gt; H) =&gt; IsEquiv f0) a b f -&gt;
GroupIsomorphism a b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> Build_GroupIsomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkfe">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, GroupIsomorphism a b -&gt; b $-&gt; a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> G H; <span class="bp">exact</span> grp_iso_inverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chkff">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : GroupIsomorphism a b),
(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f0</span> : G $-&gt; H) =&gt; IsEquiv f0) a b
  ((<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f0</span> : GroupIsomorphism G H) =&gt;
    grp_iso_homo G H f0) a b f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cbn</span>; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk100">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : a $-&gt; b)
(<span class="nv">fe</span> : (<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f0</span> : G $-&gt; H) =&gt; IsEquiv f0)
        a b f),
(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f0</span> : GroupIsomorphism G H) =&gt;
 grp_iso_homo G H f0) a b
  {| grp_iso_homo := f; isequiv_group_iso := fe |} $==
f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk101">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : GroupIsomorphism a b),
(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">x</span> : GroupIsomorphism G H) =&gt;
 grp_iso_homo H G (grp_iso_inverse x)) a b f $o
(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f0</span> : GroupIsomorphism G H) =&gt;
 grp_iso_homo G H f0) a b f $== Id a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ????; <span class="nb">apply</span> eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk102">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : GroupIsomorphism a b),
(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f0</span> : GroupIsomorphism G H) =&gt;
 grp_iso_homo G H f0) a b f $o
(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">x</span> : GroupIsomorphism G H) =&gt;
 grp_iso_homo H G (grp_iso_inverse x)) a b f $== Id b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ????; <span class="nb">apply</span> eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk103">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; a),
f $o g $== Id b -&gt;
g $o f $== Id a -&gt;
(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f0</span> : G $-&gt; H) =&gt; IsEquiv f0) a b f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk104"><span class="nb">intros</span> G H f g p q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>H $-&gt; G</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f $o g $== Id H</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>g $o f $== Id G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> (<span class="nv">G</span> <span class="nv">H</span> : Group) (<span class="nv">f</span> : G $-&gt; H) =&gt; IsEquiv f) G H f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (isequiv_adjointify f g p q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk105"><span class="kn">Global Instance</span> <span class="nf">is1cat_strong</span> `{Funext} : Is1Cat_Strong Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Cat_Strong Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk106"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Cat_Strong Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk107">rapply Build_Is1Cat_Strong.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : Group) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c)
(<span class="nv">h</span> : c $-&gt; d), h $o g $o f = h $o (g $o f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk108" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><label class="goal-separator" for="group-v-chk108"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> : Group) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c)
(<span class="nv">h</span> : c $-&gt; d), h $o (g $o f) = h $o g $o f</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk109" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><label class="goal-separator" for="group-v-chk109"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : a $-&gt; b), Id b $o f = f</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk10a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br></div><label class="goal-separator" for="group-v-chk10a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : Group) (<span class="nv">f</span> : a $-&gt; b), f $o Id a = f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">intros</span>; <span class="nb">apply</span> equiv_path_grouphomomorphism; <span class="nb">intro</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [group_type] map is a 1-functor. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk10b"><span class="kn">Global Instance</span> <span class="nf">is0functor_type_group</span> : Is0Functor group_type.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor group_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk10c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor group_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk10d"><span class="nb">apply</span> Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, (a $-&gt; b) -&gt; a $-&gt; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply @grp_homo_map.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk10e"><span class="kn">Global Instance</span> <span class="nf">is1functor_type_group</span> : Is1Functor group_type.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor group_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk10f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor group_type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Build_Is1Functor.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The [ptype_group] map is a 1-functor. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk110"><span class="kn">Global Instance</span> <span class="nf">is0functor_ptype_group</span> : Is0Functor ptype_group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor ptype_group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk111"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is0Functor ptype_group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk112"><span class="nb">apply</span> Build_Is0Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Group, (a $-&gt; b) -&gt; a $-&gt; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply @pmap_GroupHomomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk113"><span class="kn">Global Instance</span> <span class="nf">is1functor_ptype_group</span> : Is1Functor ptype_group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor ptype_group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk114"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor ptype_group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Build_Is1Functor; <span class="nb">intros</span>; <span class="bp">by</span> <span class="nb">apply</span> phomotopy_homotopy_hset.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given a group element [a0 : A] over [b : B], multiplication by [a] establishes an equivalence between the kernel and the fiber over [b]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk115"><span class="kn">Lemma</span> <span class="nf">equiv_grp_hfiber</span> {<span class="nv">A</span> <span class="nv">B</span> : Group} (<span class="nv">f</span> : GroupHomomorphism A B) (<span class="nv">b</span> : B)
  : <span class="kr">forall</span> (<span class="nv">a0</span> : hfiber f b), hfiber f b &lt;~&gt; hfiber f mon_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b -&gt; hfiber f b &lt;~&gt; hfiber f mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk116"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b -&gt; hfiber f b &lt;~&gt; hfiber f mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk117"><span class="nb">intros</span> [a0 p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b &lt;~&gt; hfiber f mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk118"><span class="nb">refine</span> (equiv_transport (hfiber f) (right_inverse b) oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b &lt;~&gt; hfiber f (b * - b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk119">snrapply Build_Equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b -&gt; hfiber f (b * - b)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk11a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br></div><label class="goal-separator" for="group-v-chk11a"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?equiv_fun</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk11b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber f b -&gt; hfiber f (b * - b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk11c">srapply (functor_hfiber (h := <span class="kr">fun</span> <span class="nv">t</span> =&gt; t * -a0) (k := <span class="kr">fun</span> <span class="nv">t</span> =&gt; t * -b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">t</span> : B =&gt; t * - b) o f ==
f o (<span class="kr">fun</span> <span class="nv">t</span> : A =&gt; t * - a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk11d"><span class="nb">intro</span> a; <span class="nb">cbn</span>; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (a * - a0) = f a * - b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk11e"><span class="nb">refine</span> (_ @ ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f a * (- x)) p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (a * - a0) = f a * - f a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_homo_op f _ _ @ ap (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f a * x) (grp_homo_inv f a0)).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk11f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  (functor_hfiber
     ((<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
       ((grp_homo_op f a (- a0) @
         ap (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f a * x) (grp_homo_inv f a0)) @
        ap (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f a * - x) p)^
       :
       f a * - b = f (a * - a0))
      :
      (<span class="kr">fun</span> <span class="nv">t</span> : B =&gt; t * - b) o f ==
      f o (<span class="kr">fun</span> <span class="nv">t</span> : A =&gt; t * - a0)) b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply isequiv_functor_hfiber.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The trivial group *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk120"><span class="kn">Definition</span> <span class="nf">grp_trivial</span> : Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk121"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk122"><span class="nb">refine</span> (Build_Group Unit (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; tt) tt (<span class="kr">fun</span> <span class="nv">_</span> =&gt; tt) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsGroup Unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> <span class="nb">split</span>; <span class="kp">try</span> <span class="bp">exact</span> _; <span class="bp">by</span> <span class="nb">intros</span> [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Map out of trivial group. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk123"><span class="kn">Definition</span> <span class="nf">grp_trivial_rec</span> (<span class="nv">G</span> : Group) : GroupHomomorphism grp_trivial G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism grp_trivial G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk124"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism grp_trivial G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk125">snrapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_trivial -&gt; G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk126" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk126"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk127"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; group_unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving
  (<span class="kr">fun</span> <span class="nv">_</span> : grp_trivial =&gt; group_unit)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ??; <span class="nb">symmetry</span>; <span class="nb">apply</span> grp_unit_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Map into trivial group. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk128"><span class="kn">Definition</span> <span class="nf">grp_trivial_corec</span> (<span class="nv">G</span> : Group) : GroupHomomorphism G grp_trivial.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism G grp_trivial</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk129"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism G grp_trivial</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk12a">snrapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">G -&gt; grp_trivial</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk12b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk12b"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk12c"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; tt).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">_</span> : G =&gt; tt)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ??; <span class="nb">symmetry</span>; <span class="bp">exact</span> (grp_unit_l _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Group is a pointed category. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk12d"><span class="kn">Global Instance</span> <span class="nf">ispointedcat_group</span> : IsPointedCat Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPointedCat Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk12e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPointedCat Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk12f">snrapply Build_IsPointedCat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInitial <span class="nl">?zero_object</span></div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTerminal <span class="nl">?zero_object</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk130">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_trivial.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk131">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInitial grp_trivial</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk132"><span class="nb">intro</span> G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : grp_trivial $-&gt; G &amp;
<span class="kr">forall</span> <span class="nv">g</span> : grp_trivial $-&gt; G, f $== g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk133"><span class="kr">exists</span> (<span class="nv">grp_trivial_rec</span> <span class="nv">G</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : grp_trivial $-&gt; G, grp_trivial_rec G $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk134"><span class="nb">intros</span> g []; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>grp_trivial $-&gt; G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_unit = g tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_homo_unit g)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk135">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTerminal grp_trivial</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk136"><span class="nb">intro</span> G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : G $-&gt; grp_trivial &amp;
<span class="kr">forall</span> <span class="nv">g</span> : G $-&gt; grp_trivial, f $== g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk137"><span class="kr">exists</span> (<span class="nv">grp_trivial_corec</span> <span class="nv">G</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : G $-&gt; grp_trivial,
grp_trivial_corec G $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk138"><span class="nb">intros</span> g x; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; grp_trivial</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tt = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_homo_const</span> {<span class="nv">G</span> <span class="nv">H</span> : Group} : GroupHomomorphism G H
  := zero_morphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The direct product of groups *)</span>

<span class="sd">(** The cartesian product of the underlying sets of two groups has a natural group structure. We call this the direct product of groups. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk139"><span class="kn">Definition</span> <span class="nf">grp_prod</span> : Group -&gt; Group -&gt; Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group -&gt; Group -&gt; Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk13a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Group -&gt; Group -&gt; Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk13b"><span class="nb">intros</span> G H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk13c">srapply (Build_Group (G * H)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp (G * H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk13d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk13d"><hr></label><div class="goal-conclusion">MonUnit (G * H)</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk13e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk13e"><hr></label><div class="goal-conclusion">Negate (G * H)</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk13f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk13f"><hr></label><div class="goal-conclusion">IsGroup (G * H)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Operation *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk140">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SgOp (G * H)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk141"><span class="nb">intros</span> [g1 h1] [g2 h2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br><span><var>g2</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(G * H)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (g1 * g2, h1 * h2).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk142">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MonUnit (G * H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk143" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk143"><hr></label><div class="goal-conclusion">Negate (G * H)</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk144" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk144"><hr></label><div class="goal-conclusion">IsGroup (G * H)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Unit *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk145"><span class="mi">1</span>: <span class="bp">exact</span> (mon_unit, mon_unit).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Negate (G * H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk146" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk146"><hr></label><div class="goal-conclusion">IsGroup (G * H)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="sd">(** Inverse *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk147">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Negate (G * H)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk148"><span class="nb">intros</span> [g h].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(G * H)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (-g, -h).</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk149">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsGroup (G * H)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk14a"><span class="kp">repeat</span> <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHSet (G * H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk14b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk14b"><hr></label><div class="goal-conclusion">Associative sg_op</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk14c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk14c"><hr></label><div class="goal-conclusion">LeftIdentity sg_op mon_unit</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk14d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk14d"><hr></label><div class="goal-conclusion">RightIdentity sg_op mon_unit</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk14e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk14e"><hr></label><div class="goal-conclusion">LeftInverse sg_op negate mon_unit</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk14f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk14f"><hr></label><div class="goal-conclusion">RightInverse sg_op negate mon_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk150"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Associative sg_op</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk151" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk151"><hr></label><div class="goal-conclusion">LeftIdentity sg_op mon_unit</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk152" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk152"><hr></label><div class="goal-conclusion">RightIdentity sg_op mon_unit</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk153" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk153"><hr></label><div class="goal-conclusion">LeftInverse sg_op negate mon_unit</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk154" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk154"><hr></label><div class="goal-conclusion">RightInverse sg_op negate mon_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: grp_auto.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Maps into the direct product can be built by mapping separately into each factor. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk155"><span class="kn">Proposition</span> <span class="nf">grp_prod_corec</span> {<span class="nv">G</span> <span class="nv">H</span> <span class="nv">K</span> : Group} (<span class="nv">f</span> : K $-&gt; G) (<span class="nv">g</span> : K $-&gt; H)
  : K $-&gt; (grp_prod G H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">K $-&gt; grp_prod G H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk156"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">K $-&gt; grp_prod G H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk157">snrapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">K -&gt; grp_prod G H</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk158" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br></div><label class="goal-separator" for="group-v-chk158"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk159">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">K -&gt; grp_prod G H</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> : K =&gt; (f x, g x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk15a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">x</span> : K =&gt; (f x, g x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk15b"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f (x * y), g (x * y)) = (f x, g x) * (f y, g y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_prod&#39;; <span class="nb">apply</span> grp_homo_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [grp_prod_corec] satisfies a definitional naturality property. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_prod_corec_natural</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">A</span> <span class="nv">B</span> : Group}
  (<span class="nv">f</span> : X $-&gt; Y) (<span class="nv">g0</span> : Y $-&gt; A) (<span class="nv">g1</span> : Y $-&gt; B)
  : grp_prod_corec g0 g1 $o f $== grp_prod_corec (g0 $o f) (g1 $o f)
  := <span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The left factor injects into the direct product. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_prod_inl</span> {<span class="nv">H</span> <span class="nv">K</span> : Group}
  : H $-&gt; (grp_prod H K)
  := grp_prod_corec grp_homo_id grp_homo_const.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The left injection is an embedding. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk15c"><span class="kn">Global Instance</span> <span class="nf">isembedding_grp_prod_inl</span> {<span class="nv">H</span> <span class="nv">K</span> : Group}
  : IsEmbedding (@grp_prod_inl H K).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding grp_prod_inl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk15d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding grp_prod_inl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk15e"><span class="nb">apply</span> isembedding_isinj_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInjective grp_prod_inl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk15f"><span class="nb">intros</span> h0 h1 p; <span class="nb">cbn</span> <span class="kr">in</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>h0, h1</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>(h0, group_unit) = (h1, group_unit)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h0 = h1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (fst ((equiv_path_prod _ _)^-<span class="mi">1</span> p)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The right factor injects into the direct product. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_prod_inr</span> {<span class="nv">H</span> <span class="nv">K</span> : Group}
  : K $-&gt; (grp_prod H K)
  := grp_prod_corec grp_homo_const grp_homo_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The right injection is an embedding. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk160"><span class="kn">Global Instance</span> <span class="nf">isembedding_grp_prod_inr</span> {<span class="nv">H</span> <span class="nv">K</span> : Group}
  : IsEmbedding (@grp_prod_inr H K).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding grp_prod_inr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk161"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding grp_prod_inr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk162"><span class="nb">apply</span> isembedding_isinj_hset.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInjective grp_prod_inr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk163"><span class="nb">intros</span> k0 k1 q; <span class="nb">cbn</span> <span class="kr">in</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>k0, k1</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>(group_unit, k0) = (group_unit, k1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">k0 = k1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (snd ((equiv_path_prod _ _)^-<span class="mi">1</span> q)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given two pairs of isomorphic groups, their pairwise direct products are isomorphic. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk164"><span class="kn">Definition</span> <span class="nf">grp_iso_prod</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : Group}
  : A ‚âÖ B -&gt; C ‚âÖ D -&gt; (grp_prod A C) ‚âÖ (grp_prod B D).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A ‚âÖ B -&gt; C ‚âÖ D -&gt; grp_prod A C ‚âÖ grp_prod B D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk165"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A ‚âÖ B -&gt; C ‚âÖ D -&gt; grp_prod A C ‚âÖ grp_prod B D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk166"><span class="nb">intros</span> f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod A C ‚âÖ grp_prod B D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk167">srapply Build_GroupIsomorphism&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod A C &lt;~&gt; grp_prod B D</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk168" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br></div><label class="goal-separator" for="group-v-chk168"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?f</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk169"><span class="mi">1</span>: srapply (equiv_functor_prod (f:=f) (g:=g)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving equiv_functor_prod</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk16a"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (functor_prod f g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk16b"><span class="nb">unfold</span> functor_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving
  (<span class="kr">fun</span> <span class="nv">z</span> : A * C =&gt; (f (fst z), g (snd z)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk16c"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>(A * C)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f (fst (x * y)), g (snd (x * y))) =
(f (fst x), g (snd x)) * (f (fst y), g (snd y))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk16d"><span class="nb">apply</span> path_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>(A * C)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst (f (fst (x * y)), g (snd (x * y))) =
fst ((f (fst x), g (snd x)) * (f (fst y), g (snd y)))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk16e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C, D</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A ‚âÖ B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>C ‚âÖ D</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>(A * C)%type</span></span></span><br></div><label class="goal-separator" for="group-v-chk16e"><hr></label><div class="goal-conclusion">snd (f (fst (x * y)), g (snd (x * y))) =
snd ((f (fst x), g (snd x)) * (f (fst y), g (snd y)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="mi">1</span>,<span class="mi">2</span>: <span class="nb">apply</span> grp_homo_op.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The first projection of the direct product. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk16f"><span class="kn">Definition</span> <span class="nf">grp_prod_pr1</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  : GroupHomomorphism (grp_prod G H) G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (grp_prod G H) G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk170"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (grp_prod G H) G</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk171">snrapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod G H -&gt; G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk172" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk172"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk173"><span class="mi">1</span>: <span class="bp">exact</span> fst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving fst</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? ?; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The first projection is a surjection. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">issurj_grp_prod_pr1</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  : IsSurjection (@grp_prod_pr1 G H)
  := issurj_retr grp_prod_inl (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The second projection of the direct product. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk174"><span class="kn">Definition</span> <span class="nf">grp_prod_pr2</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  : GroupHomomorphism (grp_prod G H) H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (grp_prod G H) H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk175"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism (grp_prod G H) H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk176">snrapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod G H -&gt; H</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk177" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk177"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk178"><span class="mi">1</span>: <span class="bp">exact</span> snd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving snd</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> ? ?; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Pairs in direct products can be decomposed *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk179"><span class="kn">Definition</span> <span class="nf">grp_prod_decompose</span> {<span class="nv">G</span> <span class="nv">H</span> : Group} (<span class="nv">g</span> : G) (<span class="nv">h</span> : H)
  : (g, h) = ((g, group_unit) : grp_prod G H) * (group_unit, h).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g, h) =
((g, group_unit) : grp_prod G H) * (group_unit, h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk17a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(g, h) =
((g, group_unit) : grp_prod G H) * (group_unit, h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk17b">snrapply path_prod; <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst
  (((g, group_unit) : grp_prod G H) * (group_unit, h)) =
fst (g, h)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk17c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><label class="goal-separator" for="group-v-chk17c"><hr></label><div class="goal-conclusion">snd
  (((g, group_unit) : grp_prod G H) * (group_unit, h)) =
snd (g, h)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk17d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst
  (((g, group_unit) : grp_prod G H) * (group_unit, h)) =
fst (g, h)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">snrapply grp_unit_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk17e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd
  (((g, group_unit) : grp_prod G H) * (group_unit, h)) =
snd (g, h)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">snrapply grp_unit_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The second projection is a surjection. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">issurj_grp_prod_pr2</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  : IsSurjection (@grp_prod_pr2 G H)
  := issurj_retr grp_prod_inr (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [Group] is a category with binary products given by the direct product. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk17f"><span class="kn">Global Instance</span> <span class="nf">hasbinaryproducts_group</span> : HasBinaryProducts Group.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">HasBinaryProducts Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk180"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">HasBinaryProducts Group</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk181"><span class="nb">intros</span> G H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">BinaryProduct G H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk182">snrapply Build_BinaryProduct.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk183" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk183"><hr></label><div class="goal-conclusion"><span class="nl">?cat_binprod</span> $-&gt; G</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk184" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk184"><hr></label><div class="goal-conclusion"><span class="nl">?cat_binprod</span> $-&gt; H</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk185" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk185"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : Group,
(z $-&gt; G) -&gt; (z $-&gt; H) -&gt; z $-&gt; <span class="nl">?cat_binprod</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk186" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk186"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : Group) (<span class="nv">f</span> : z $-&gt; G) (<span class="nv">g</span> : z $-&gt; H),
<span class="nl">?cat_pr1</span> $o <span class="nl">?cat_binprod_corec</span> z f g $== f</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk187" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk187"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : Group) (<span class="nv">f</span> : z $-&gt; G) (<span class="nv">g</span> : z $-&gt; H),
<span class="nl">?cat_pr2</span> $o <span class="nl">?cat_binprod_corec</span> z f g $== g</div></blockquote><input class="alectryon-extra-goal-toggle" id="group-v-chk188" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk188"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : Group) (<span class="nv">f</span> <span class="nv">g</span> : z $-&gt; <span class="nl">?cat_binprod</span>),
<span class="nl">?cat_pr1</span> $o f $== <span class="nl">?cat_pr1</span> $o g -&gt;
<span class="nl">?cat_pr2</span> $o f $== <span class="nl">?cat_pr2</span> $o g -&gt; f $== g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk189">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Group</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (grp_prod G H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk18a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod G H $-&gt; G</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_prod_pr1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk18b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod G H $-&gt; H</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_prod_pr2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk18c" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk18c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">z</span> : Group,
(z $-&gt; G) -&gt; (z $-&gt; H) -&gt; z $-&gt; grp_prod G H</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk18d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk18d"><span class="nb">intros</span> K.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(K $-&gt; G) -&gt; (K $-&gt; H) -&gt; K $-&gt; grp_prod G H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> grp_prod_corec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk18e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : Group) (<span class="nv">f</span> : z $-&gt; G) (<span class="nv">g</span> : z $-&gt; H),
grp_prod_pr1 $o
(<span class="kr">fun</span> <span class="nv">K</span> : Group =&gt; grp_prod_corec) z f g $== f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk18f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk18f"><span class="nb">intros</span> K f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod_pr1 $o
(<span class="kr">fun</span> <span class="nv">K</span> : Group =&gt; grp_prod_corec) K f g $== f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Id _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk190">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : Group) (<span class="nv">f</span> : z $-&gt; G) (<span class="nv">g</span> : z $-&gt; H),
grp_prod_pr2 $o
(<span class="kr">fun</span> <span class="nv">K</span> : Group =&gt; grp_prod_corec) z f g $== g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk191" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk191"><span class="nb">intros</span> K f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>K $-&gt; G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>K $-&gt; H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_prod_pr2 $o
(<span class="kr">fun</span> <span class="nv">K</span> : Group =&gt; grp_prod_corec) K f g $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Id _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk192" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk192">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">z</span> : Group) (<span class="nv">f</span> <span class="nv">g</span> : z $-&gt; grp_prod G H),
grp_prod_pr1 $o f $== grp_prod_pr1 $o g -&gt;
grp_prod_pr2 $o f $== grp_prod_pr2 $o g -&gt; f $== g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk193"><span class="nb">intros</span> K f g p q a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H, K</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>K $-&gt; grp_prod G H</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_prod_pr1 $o f $== grp_prod_pr1 $o g</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>grp_prod_pr2 $o f $== grp_prod_pr2 $o g</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>K</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a = g a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (path_prod&#39; (p a) (q a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Properties of maps to and from the trivial group *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk194" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk194"><span class="kn">Global Instance</span> <span class="nf">isinitial_grp_trivial</span> : IsInitial grp_trivial.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInitial grp_trivial</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk195" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk195"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInitial grp_trivial</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk196"><span class="nb">intro</span> G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : grp_trivial $-&gt; G &amp;
<span class="kr">forall</span> <span class="nv">g</span> : grp_trivial $-&gt; G, f $== g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk197"><span class="kr">exists</span> (<span class="nv">grp_trivial_rec</span> <span class="nv">_</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : grp_trivial $-&gt; G, grp_trivial_rec G $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk198"><span class="nb">intros</span> g [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>grp_trivial $-&gt; G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_trivial_rec G tt = g tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (grp_homo_unit g)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk199"><span class="kn">Global Instance</span> <span class="nf">contr_grp_homo_trivial_source</span> `{Funext} G
  : Contr (GroupHomomorphism grp_trivial G).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (GroupHomomorphism grp_trivial G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk19a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (GroupHomomorphism grp_trivial G)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk19b">snrapply Build_Contr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism grp_trivial G</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk19c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk19c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : GroupHomomorphism grp_trivial G,
<span class="nl">?center</span> = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk19d"><span class="mi">1</span>: <span class="bp">exact</span> (grp_trivial_rec _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : GroupHomomorphism grp_trivial G,
grp_trivial_rec G = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk19e" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk19e"><span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism grp_trivial G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_trivial_rec G = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk19f">rapply equiv_path_grouphomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism grp_trivial G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_trivial_rec G == g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a0"><span class="nb">intros</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism grp_trivial G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_trivial_rec G tt = g tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a1"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism grp_trivial G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g tt = grp_trivial_rec G tt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">rapply grp_homo_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a2"><span class="kn">Global Instance</span> <span class="nf">isterminal_grp_trivial</span> : IsTerminal grp_trivial.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTerminal grp_trivial</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTerminal grp_trivial</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a4"><span class="nb">intro</span> G.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : G $-&gt; grp_trivial &amp;
<span class="kr">forall</span> <span class="nv">g</span> : G $-&gt; grp_trivial, f $== g}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a5"><span class="kr">exists</span> (<span class="nv">grp_trivial_corec</span> <span class="nv">_</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : G $-&gt; grp_trivial,
grp_trivial_corec G $== g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a6"><span class="nb">intros</span> g x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G $-&gt; grp_trivial</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_trivial_corec G x = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_contr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a7"><span class="kn">Global Instance</span> <span class="nf">contr_grp_homo_trivial_target</span> `{Funext} G
  : Contr (GroupHomomorphism G grp_trivial).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (GroupHomomorphism G grp_trivial)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (GroupHomomorphism G grp_trivial)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1a9">snrapply Build_Contr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism G grp_trivial</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk1aa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><label class="goal-separator" for="group-v-chk1aa"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : GroupHomomorphism G grp_trivial,
<span class="nl">?center</span> = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ab" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ab"><span class="mi">1</span>: <span class="bp">exact</span> (pr1 (isterminal_grp_trivial _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : GroupHomomorphism G grp_trivial,
(isterminal_grp_trivial G).<span class="mi">1</span> = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ac" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ac"><span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G grp_trivial</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(isterminal_grp_trivial G).<span class="mi">1</span> = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ad" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ad">rapply equiv_path_grouphomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G grp_trivial</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(isterminal_grp_trivial G).<span class="mi">1</span> == g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ae" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ae"><span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism G grp_trivial</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(isterminal_grp_trivial G).<span class="mi">1</span> x = g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_contr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1af"><span class="kn">Global Instance</span> <span class="nf">ishprop_grp_iso_trivial</span> `{Funext} (G : Group)
  : IsHProp (G ‚âÖ grp_trivial).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (G ‚âÖ grp_trivial)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (G ‚âÖ grp_trivial)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b1"><span class="nb">apply</span> equiv_hprop_allpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : G ‚âÖ grp_trivial, x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b2"><span class="nb">intros</span> f g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>G ‚âÖ grp_trivial</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_path_groupisomorphism; <span class="nb">intro</span>; <span class="nb">apply</span> path_ishprop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Free groups *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">FactorsThroughFreeGroup</span> (<span class="nv">S</span> : <span class="kt">Type</span>) (<span class="nv">F_S</span> : Group)
  (<span class="nv">i</span> : S -&gt; F_S) (<span class="nv">A</span> : Group) (<span class="nv">g</span> : S -&gt; A) : <span class="kt">Type</span>
  := {f : F_S $-&gt; A &amp; f o i == g}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Universal property of a free group on a set (type). *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsFreeGroupOn</span> (<span class="nv">S</span> : <span class="kt">Type</span>) (<span class="nv">F_S</span> : Group) (<span class="nv">i</span> : S -&gt; F_S)
  := contr_isfreegroupon : <span class="kr">forall</span> (<span class="nv">A</span> : Group) (<span class="nv">g</span> : S -&gt; A),
      Contr (FactorsThroughFreeGroup S F_S i A g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Existing Instance</span> <span class="nf">contr_isfreegroupon</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A group is free if there exists a generating type on which it is a free group. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsFreeGroup</span> (<span class="nv">F_S</span> : Group)
  := isfreegroup : {S : _ &amp; {i : _ &amp; IsFreeGroupOn S F_S i}}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">isfreegroup_isfreegroupon</span> (<span class="nv">S</span> : <span class="kt">Type</span>) (<span class="nv">F_S</span> : Group) (<span class="nv">i</span> : S -&gt; F_S)
  {<span class="nv">H</span> : IsFreeGroupOn S F_S i}
  : IsFreeGroup F_S
  := (S; i; H).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** ** Further properties of group homomorphisms. *)</span>

<span class="sd">(** Characterisation of injective group homomorphisms. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b3"><span class="kn">Lemma</span> <span class="nf">isembedding_grouphomomorphism</span> {<span class="nv">A</span> <span class="nv">B</span> : Group} (<span class="nv">f</span> : A $-&gt; B)
  : (<span class="kr">forall</span> <span class="nv">a</span>, f a = group_unit -&gt; a = group_unit) &lt;-&gt; IsEmbedding f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, f a = group_unit -&gt; a = group_unit) &lt;-&gt;
IsEmbedding f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, f a = group_unit -&gt; a = group_unit) &lt;-&gt;
IsEmbedding f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b5"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, f a = group_unit -&gt; a = group_unit) -&gt;
IsEmbedding f</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="group-v-chk1b6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><label class="goal-separator" for="group-v-chk1b6"><hr></label><div class="goal-conclusion">IsEmbedding f -&gt;
<span class="kr">forall</span> <span class="nv">a</span> : A, f a = group_unit -&gt; a = group_unit</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : A, f a = group_unit -&gt; a = group_unit) -&gt;
IsEmbedding f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b8"><span class="nb">intros</span> h b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, f a = group_unit -&gt; a = group_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsHProp (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1b9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1b9"><span class="nb">apply</span> hprop_allpath.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, f a = group_unit -&gt; a = group_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : hfiber f b, x = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ba" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ba"><span class="nb">intros</span> [a0 p0] [a1 p1].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, f a = group_unit -&gt; a = group_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>f a1 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a0; p0) = (a1; p1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1bb">srapply path_sigma_hprop; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, f a = group_unit -&gt; a = group_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>f a1 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a0 = a1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1bc" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1bc"><span class="nb">apply</span> grp_moveL_1M.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, f a = group_unit -&gt; a = group_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>f a1 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a0 * - a1 = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1bd" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1bd"><span class="nb">apply</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, f a = group_unit -&gt; a = group_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>f a1 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (a0 * - a1) = group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1be" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1be"><span class="nb">rewrite</span> grp_homo_op, grp_homo_inv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, f a = group_unit -&gt; a = group_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>f a1 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a0 * - f a1 = group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1bf"><span class="nb">rewrite</span> p0, p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, f a = group_unit -&gt; a = group_unit</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>f a0 = b</span></span></span><br><span><var>a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>f a1 = b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b * - b = group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> right_inverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding f -&gt;
<span class="kr">forall</span> <span class="nv">a</span> : A, f a = group_unit -&gt; a = group_unit</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c1"><span class="nb">intros</span> E a p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = group_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c2">rapply (isinj_embedding f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>E</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f a = group_unit</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a = f group_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p @ (grp_homo_unit f)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Commutativity can be transferred across isomorphisms. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c3" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c3"><span class="kn">Definition</span> <span class="nf">commutative_iso_commutative</span> {<span class="nv">G</span> <span class="nv">H</span> : Group}
  {<span class="nv">C</span> : Commutative (@group_sgop G)} (<span class="nv">f</span> : GroupIsomorphism G H)
  : Commutative (@group_sgop H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Commutative group_sgop</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Commutative group_sgop</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c4" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Commutative group_sgop</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Commutative group_sgop</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c5" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c5"><span class="nb">unfold</span> Commutative.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Commutative group_sgop</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : H, group_sgop x y = group_sgop y x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c6" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c6">rapply (equiv_ind f); <span class="nb">intro</span> g1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Commutative group_sgop</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br><span><var>g1</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : H,
group_sgop (f g1) y = group_sgop y (f g1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c7" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c7">rapply (equiv_ind f); <span class="nb">intro</span> g2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Commutative group_sgop</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br><span><var>g1, g2</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">group_sgop (f g1) (f g2) = group_sgop (f g2) (f g1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c8"><span class="nb">refine</span> ((preserves_sg_op _ _)^ @ _ @ (preserves_sg_op _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Commutative group_sgop</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br><span><var>g1, g2</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (g1 * g2) = f (g2 * g1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1c9"><span class="nb">refine</span> (ap f _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Commutative group_sgop</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism G H</span></span></span><br><span><var>g1, g2</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g1 * g2 = g2 * g1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> C.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If two group homomorphisms agree on two elements, then they agree on their product. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ca" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ca"><span class="kn">Definition</span> <span class="nf">grp_homo_op_agree</span> {<span class="nv">G</span> <span class="nv">G&#39;</span> <span class="nv">H</span> : Group} (<span class="nv">f</span> : G $-&gt; H) (<span class="nv">f&#39;</span> : G&#39; $-&gt; H)
  {<span class="nv">x</span> <span class="nv">y</span> : G} {<span class="nv">x&#39;</span> <span class="nv">y&#39;</span> : G&#39;} (<span class="nv">p</span> : f x = f&#39; x&#39;) (<span class="nv">q</span> : f y = f&#39; y&#39;)
  : f (x * y) = f&#39; (x&#39; * y&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, G', H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>G&#39; $-&gt; H</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x', y'</var><span class="hyp-type"><b>: </b><span>G&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = f&#39; x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f y = f&#39; y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (x * y) = f&#39; (x&#39; * y&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1cb" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1cb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, G', H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>G&#39; $-&gt; H</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x', y'</var><span class="hyp-type"><b>: </b><span>G&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = f&#39; x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f y = f&#39; y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (x * y) = f&#39; (x&#39; * y&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1cc" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1cc">lhs nrapply grp_homo_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, G', H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>G&#39; $-&gt; H</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x', y'</var><span class="hyp-type"><b>: </b><span>G&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = f&#39; x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f y = f&#39; y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x * f y = f&#39; (x&#39; * y&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1cd" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1cd">rhs nrapply grp_homo_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G, G', H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; H</span></span></span><br><span><var>f'</var><span class="hyp-type"><b>: </b><span>G&#39; $-&gt; H</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x', y'</var><span class="hyp-type"><b>: </b><span>G&#39;</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>f x = f&#39; x&#39;</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f y = f&#39; y&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x * f y = f&#39; x&#39; * f&#39; y&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap011 _ p q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The group movement lemmas can be extended to when there is a homomorphism involved.  For now, we only include these two. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">grp_homo_moveL_1V</span> {<span class="nv">A</span> <span class="nv">B</span> : Group} (<span class="nv">f</span> : GroupHomomorphism A B) (<span class="nv">x</span> <span class="nv">y</span> : A)
  : f (x * y) = group_unit &lt;~&gt; (f x = - f y)
  := grp_moveL_1V oE equiv_concat_l (grp_homo_op f x y)^ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1ce" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1ce"><span class="kn">Definition</span> <span class="nf">grp_homo_moveL_1M</span>  {<span class="nv">A</span> <span class="nv">B</span> : Group} (<span class="nv">f</span> : GroupHomomorphism A B) (<span class="nv">x</span> <span class="nv">y</span> : A)
  : f (x * -y) = group_unit &lt;~&gt; (f x = f y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (x * - y) = group_unit &lt;~&gt; f x = f y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1cf" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1cf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (x * - y) = group_unit &lt;~&gt; f x = f y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1d0" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1d0"><span class="nb">refine</span> (grp_moveL_1M oE equiv_concat_l _^ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (x * - y) = f x * - f y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="group-v-chk1d1" style="display: none" type="checkbox"><label class="alectryon-input" for="group-v-chk1d1">lhs nrapply grp_homo_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x * f (- y) = f x * - f y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, grp_homo_inv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
