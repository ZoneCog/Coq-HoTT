<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Universe.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* -*- mode: coq; mode: visual-line -*- *)</span>
<span class="sd">(** * Theorems about the universe, including the Univalence Axiom. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk7e"><span class="kn">Require Import</span> HoTT.Basics.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Types.Sigma Types.Forall Types.Arrow Types.Paths Types.Equiv Types.Bool Types.Prod.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable Variables</span> <span class="nf">A</span> B f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Paths *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>@{u}) (<span class="nv">p</span> : A = B) : A &lt;~&gt; B
  := equiv_transport (<span class="kr">fun</span> <span class="nv">X</span> =&gt; X) p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk7f"><span class="kn">Definition</span> <span class="nf">equiv_path_V</span> `{Funext} (A B : <span class="kt">Type</span>) (p : A = B) :
  equiv_path B A (p^) = (equiv_path A B p)^-<span class="mi">1</span>%equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path B A p^ = (equiv_path A B p)^-<span class="mi">1</span>%equiv</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk80"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path B A p^ = (equiv_path A B p)^-<span class="mi">1</span>%equiv</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk81"><span class="nb">apply</span> path_equiv.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path B A p^ = (equiv_path A B p)^-<span class="mi">1</span>%equiv</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** See the note by [Funext] in Overture.v *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Monomorphic</span> <span class="kn">Axiom</span> <span class="nv">Univalence</span> : Type0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Existing Class</span> <span class="nf">Univalence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Mark this axiom as a &quot;global axiom&quot;, which some of our tactics will automatically handle. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">is_global_axiom_univalence</span> : IsGlobalAxiom Univalence := {}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">isequiv_equiv_path</span> : <span class="kr">forall</span> `{Univalence} (A B : <span class="kt">Type</span>@{u}), IsEquiv (equiv_path A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Existing Instance</span> <span class="nf">isequiv_equiv_path</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A proof that univalence implies function extensionality can be found in the metatheory file [UnivalenceImpliesFunext], but that actual proof can&#39;t be used on our dummy typeclasses.  So we assert the following axiomatic instance.  *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk82"><span class="kn">Global Instance</span> <span class="nf">Univalence_implies_Funext</span> `{Univalence} : Funext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Funext</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">Univalence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Univalence}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_universe_uncurried</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B) : A = B
  := (equiv_path A B)^-<span class="mi">1</span> f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_universe</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">feq</span> : IsEquiv f} : (A = B)
  := path_universe_uncurried (Build_Equiv _ _ f feq).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global</span> <span class="kn">Arguments</span> path_universe {A B}%_type_scope f%_function_scope {feq}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eta_path_universe</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">p</span> : A = B)
  : path_universe (equiv_path A B p) = p
  := eissect (equiv_path A B) p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eta_path_universe_uncurried</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">p</span> : A = B)
  : path_universe_uncurried (equiv_path A B p) = p
  := eissect (equiv_path A B) p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isequiv_path_universe</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>}
  : IsEquiv (@path_universe_uncurried A B)
 := _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_universe</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) : (A &lt;~&gt; B) &lt;~&gt; (A = B)
  := Build_Equiv _ _ (@path_universe_uncurried A B) isequiv_path_universe.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_equiv_path</span>  (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) : (A = B) &lt;~&gt; (A &lt;~&gt; B)
  := (equiv_path_universe A B)^-<span class="mi">1</span>%equiv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** These operations have too many names, making [rewrite] a pain.  So we give lots of names to the computation laws. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_universe_equiv_path</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">p</span> : A = B)
  : path_universe (equiv_path A B p) = p
  := eissect (equiv_path A B) p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_universe_uncurried_equiv_path</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">p</span> : A = B)
  : path_universe_uncurried (equiv_path A B p) = p
  := eissect (equiv_path A B) p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_universe_transport_idmap</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">p</span> : A = B)
  : path_universe (transport idmap p) = p
  := eissect (equiv_path A B) p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_universe_uncurried_transport_idmap</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">p</span> : A = B)
  : path_universe_uncurried (equiv_transport idmap p) = p
  := eissect (equiv_path A B) p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_path_universe</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B)
  : equiv_path A B (path_universe f) = f
  := eisretr (equiv_path A B) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_path_universe_uncurried</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B)
  : equiv_path A B (path_universe_uncurried f) = f
  := eisretr (equiv_path A B) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_idmap_path_universe</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B)
  : transport idmap (path_universe f) = f
  := ap equiv_fun (eisretr (equiv_path A B) f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_idmap_path_universe_uncurried</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B)
  : transport idmap (path_universe_uncurried f) = f
  := ap equiv_fun (eisretr (equiv_path A B) f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Behavior on path operations *)</span>

<span class="c">(* We explicitly assume [Funext] here, since this result doesn&#39;t use [Univalence]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk83"><span class="kn">Definition</span> <span class="nf">equiv_path_pp</span> `{Funext} {A B C : <span class="kt">Type</span>} (p : A = B) (q : B = C)
: equiv_path A C (p @ q) = equiv_path B C q oE equiv_path A B p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>B = C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path A C (p @ q) =
equiv_path B C q oE equiv_path A B p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk84"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>B = C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path A C (p @ q) =
equiv_path B C q oE equiv_path A B p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk85"><span class="nb">apply</span> path_equiv, path_arrow.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>B = C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path A C (p @ q) ==
equiv_path B C q oE equiv_path A B p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">nrapply transport_pp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk86"><span class="kn">Definition</span> <span class="nf">path_universe_compose_uncurried</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>}
           (<span class="nv">f</span> : A &lt;~&gt; B) (<span class="nv">g</span> : B &lt;~&gt; C)
: path_universe_uncurried (equiv_compose g f)
= path_universe_uncurried f @ path_universe_uncurried g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_universe_uncurried (equiv_compose g f) =
path_universe_uncurried f @ path_universe_uncurried g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk87"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_universe_uncurried (equiv_compose g f) =
path_universe_uncurried f @ path_universe_uncurried g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk88"><span class="nb">revert</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : A &lt;~&gt; B,
path_universe_uncurried (equiv_compose g f) =
path_universe_uncurried f @ path_universe_uncurried g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk89">equiv_intro (equiv_path A B) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; C</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_universe_uncurried
  (equiv_compose g (equiv_path A B f)) =
path_universe_uncurried (equiv_path A B f) @
path_universe_uncurried g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk8a"><span class="nb">revert</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">g</span> : B &lt;~&gt; C,
path_universe_uncurried
  (equiv_compose g (equiv_path A B f)) =
path_universe_uncurried (equiv_path A B f) @
path_universe_uncurried g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk8b">equiv_intro (equiv_path B C) g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B = C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_universe_uncurried
  (equiv_compose (equiv_path B C g) (equiv_path A B f)) =
path_universe_uncurried (equiv_path A B f) @
path_universe_uncurried (equiv_path B C g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk8c"><span class="nb">refine</span> ((ap path_universe_uncurried (equiv_path_pp f g))^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B = C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_universe_uncurried (equiv_path A C (f @ g)) =
path_universe_uncurried (equiv_path A B f) @
path_universe_uncurried (equiv_path B C g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk8d"><span class="nb">refine</span> (eta_path_universe (f @ g) @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B = C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f @ g =
path_universe_uncurried (equiv_path A B f) @
path_universe_uncurried (equiv_path B C g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> concat2; <span class="nb">symmetry</span>; <span class="nb">apply</span> eta_path_universe.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_universe_compose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>}
           (<span class="nv">f</span> : A &lt;~&gt; B) (<span class="nv">g</span> : B &lt;~&gt; C)
  : path_universe (g o f) = path_universe f @ path_universe g
  := path_universe_compose_uncurried f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_universe_1</span> {<span class="nv">A</span> : <span class="kt">Type</span>}
  : path_universe (equiv_idmap A) = <span class="mi">1</span>
  := eta_path_universe <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk8e"><span class="kn">Definition</span> <span class="nf">path_universe_V_uncurried</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B)
  : path_universe_uncurried f^-<span class="mi">1</span> = (path_universe_uncurried f)^.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_universe_uncurried f^-<span class="mi">1</span> =
(path_universe_uncurried f)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk8f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_universe_uncurried f^-<span class="mi">1</span> =
(path_universe_uncurried f)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk90"><span class="nb">revert</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : A &lt;~&gt; B,
path_universe_uncurried f^-<span class="mi">1</span> =
(path_universe_uncurried f)^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk91">equiv_intro ((equiv_path_universe A B)^-<span class="mi">1</span>) p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_universe_uncurried
  ((equiv_path_universe A B)^-<span class="mi">1</span>%function p)^-<span class="mi">1</span> =
(path_universe_uncurried
   ((equiv_path_universe A B)^-<span class="mi">1</span>%function p))^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk92"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_universe_uncurried (equiv_path A B p)^-<span class="mi">1</span> =
(path_universe_uncurried (equiv_path A B p))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk93"><span class="nb">transitivity</span> (p^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_universe_uncurried (equiv_path A B p)^-<span class="mi">1</span> = p^</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="universe-v-chk94" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><label class="goal-separator" for="universe-v-chk94"><hr></label><div class="goal-conclusion">p^ = (path_universe_uncurried (equiv_path A B p))^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk95"><span class="mi">2</span>: <span class="bp">exact</span> (inverse2 (eisretr (equiv_path_universe A B) p)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_universe_uncurried (equiv_path A B p)^-<span class="mi">1</span> = p^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk96"><span class="nb">transitivity</span> (path_universe_uncurried (equiv_path B A p^)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_universe_uncurried (equiv_path A B p)^-<span class="mi">1</span> =
path_universe_uncurried (equiv_path B A p^)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="universe-v-chk97" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><label class="goal-separator" for="universe-v-chk97"><hr></label><div class="goal-conclusion">path_universe_uncurried (equiv_path B A p^) = p^</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk98">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_universe_uncurried (equiv_path A B p)^-<span class="mi">1</span> =
path_universe_uncurried (equiv_path B A p^)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">refine</span> (ap _ (equiv_path_V A B p)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk99">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">path_universe_uncurried (equiv_path B A p^) = p^</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">refine</span> (eissect (equiv_path B A) p^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path_universe_V</span> `(f : A -&gt; B) `{IsEquiv A B f}
  : path_universe (f^-<span class="mi">1</span>) = (path_universe f)^
  := path_universe_V_uncurried (Build_Equiv A B f _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Path operations vs Type operations *)</span>

<span class="sd">(** [ap (Equiv A)] behaves like postcomposition. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk9a"><span class="kn">Definition</span> <span class="nf">ap_equiv_path_universe</span> <span class="nv">A</span> {<span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : B &lt;~&gt; C)
: equiv_path (A &lt;~&gt; B) (A &lt;~&gt; C) (ap (Equiv A) (path_universe f))
  = equiv_functor_equiv (equiv_idmap A) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (A &lt;~&gt; B) (A &lt;~&gt; C)
  (ap (Equiv A) (path_universe f)) =
equiv_functor_equiv <span class="mi">1</span> f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk9b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (A &lt;~&gt; B) (A &lt;~&gt; C)
  (ap (Equiv A) (path_universe f)) =
equiv_functor_equiv <span class="mi">1</span> f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk9c"><span class="nb">revert</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : B &lt;~&gt; C,
equiv_path (A &lt;~&gt; B) (A &lt;~&gt; C)
  (ap (Equiv A) (path_universe f)) =
equiv_functor_equiv <span class="mi">1</span> f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk9d">equiv_intro (equiv_path B C) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B = C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (A &lt;~&gt; B) (A &lt;~&gt; C)
  (ap (Equiv A) (path_universe (equiv_path B C f))) =
equiv_functor_equiv <span class="mi">1</span> (equiv_path B C f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk9e"><span class="nb">rewrite</span> (eissect (equiv_path B C) f : path_universe (equiv_path B C f) = f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B = C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (A &lt;~&gt; B) (A &lt;~&gt; C) (ap (Equiv A) f) =
equiv_functor_equiv <span class="mi">1</span> (equiv_path B C f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk9f"><span class="nb">destruct</span> f; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (A &lt;~&gt; B) (A &lt;~&gt; B) <span class="mi">1</span> =
equiv_functor_equiv <span class="mi">1</span> (equiv_path B B <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chka0"><span class="nb">apply</span> path_equiv, path_forall; <span class="nb">intros</span> g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (A &lt;~&gt; B) (A &lt;~&gt; B) <span class="mi">1</span> g =
equiv_functor_equiv <span class="mi">1</span> (equiv_path B B <span class="mi">1</span>) g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chka1"><span class="nb">apply</span> path_equiv, path_forall; <span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (A &lt;~&gt; B) (A &lt;~&gt; B) <span class="mi">1</span> g a =
equiv_functor_equiv <span class="mi">1</span> (equiv_path B B <span class="mi">1</span>) g a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [ap (prod A)] behaves like [equiv_functor_prod_l]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chka2"><span class="kn">Definition</span> <span class="nf">ap_prod_l_path_universe</span> <span class="nv">A</span> {<span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : B &lt;~&gt; C)
  : equiv_path (A * B) (A * C) (ap (prod A) (path_universe f))
    = equiv_functor_prod_l f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (A * B) (A * C)
  (ap (prod A) (path_universe f)) =
equiv_functor_prod_l f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chka3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (A * B) (A * C)
  (ap (prod A) (path_universe f)) =
equiv_functor_prod_l f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chka4"><span class="nb">revert</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : B &lt;~&gt; C,
equiv_path (A * B) (A * C)
  (ap (prod A) (path_universe f)) =
equiv_functor_prod_l f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chka5">equiv_intro (equiv_path B C) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B = C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (A * B) (A * C)
  (ap (prod A) (path_universe (equiv_path B C f))) =
equiv_functor_prod_l (equiv_path B C f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chka6"><span class="nb">rewrite</span> (eissect (equiv_path B C) f : path_universe (equiv_path B C f) = f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B = C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (A * B) (A * C) (ap (prod A) f) =
equiv_functor_prod_l (equiv_path B C f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chka7"><span class="nb">destruct</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (A * B) (A * B) (ap (prod A) <span class="mi">1</span>) =
equiv_functor_prod_l (equiv_path B B <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_equiv, path_arrow; <span class="nb">intros</span> x; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [ap (fun Z =&gt; Z * A)] behaves like [equiv_functor_prod_r]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chka8"><span class="kn">Definition</span> <span class="nf">ap_prod_r_path_universe</span> <span class="nv">A</span> {<span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : B &lt;~&gt; C)
  : equiv_path (B * A) (C * A) (ap (<span class="kr">fun</span> <span class="nv">Z</span> =&gt; Z * A) (path_universe f))
    = equiv_functor_prod_r f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (B * A) (C * A)
  (ap (<span class="kr">fun</span> <span class="nv">Z</span> : <span class="kt">Type</span> =&gt; Z * A) (path_universe f)) =
equiv_functor_prod_r f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chka9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (B * A) (C * A)
  (ap (<span class="kr">fun</span> <span class="nv">Z</span> : <span class="kt">Type</span> =&gt; Z * A) (path_universe f)) =
equiv_functor_prod_r f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkaa"><span class="nb">revert</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : B &lt;~&gt; C,
equiv_path (B * A) (C * A)
  (ap (<span class="kr">fun</span> <span class="nv">Z</span> : <span class="kt">Type</span> =&gt; Z * A) (path_universe f)) =
equiv_functor_prod_r f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkab">equiv_intro (equiv_path B C) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B = C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (B * A) (C * A)
  (ap (<span class="kr">fun</span> <span class="nv">Z</span> : <span class="kt">Type</span> =&gt; Z * A)
     (path_universe (equiv_path B C f))) =
equiv_functor_prod_r (equiv_path B C f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkac"><span class="nb">rewrite</span> (eissect (equiv_path B C) f : path_universe (equiv_path B C f) = f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B = C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (B * A) (C * A)
  (ap (<span class="kr">fun</span> <span class="nv">Z</span> : <span class="kt">Type</span> =&gt; Z * A) f) =
equiv_functor_prod_r (equiv_path B C f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkad"><span class="nb">destruct</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path (B * A) (B * A)
  (ap (<span class="kr">fun</span> <span class="nv">Z</span> : <span class="kt">Type</span> =&gt; Z * A) <span class="mi">1</span>) =
equiv_functor_prod_r (equiv_path B B <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_equiv, path_arrow; <span class="nb">intros</span> x; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Transport *)</span>

<span class="sd">(** There are two ways we could define [transport_path_universe]: we could give an explicit definition, or we could reduce it to paths by [equiv_ind] and give an explicit definition there.  The two should be equivalent, but we choose the second for now as it makes the currently needed coherence lemmas easier to prove. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkae"><span class="kn">Definition</span> <span class="nf">transport_path_universe_uncurried</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B) (<span class="nv">z</span> : A)
  : transport (<span class="kr">fun</span> <span class="nv">X</span>:<span class="kt">Type</span> =&gt; X) (path_universe_uncurried f) z = f z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap (path_universe_uncurried f) z = f z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkaf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap (path_universe_uncurried f) z = f z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkb0"><span class="nb">revert</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : A &lt;~&gt; B,
transport idmap (path_universe_uncurried f) z = f z</div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkb1">equiv_intro (equiv_path A B) p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap
  (path_universe_uncurried (equiv_path A B p)) z =
equiv_path A B p z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (<span class="kr">fun</span> <span class="nv">s</span> =&gt; transport idmap s z) (eissect _ p)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Alternatively, [apply ap10, transport_idmap_path_universe_uncurried.], but then some later proofs would have to change. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_path_universe</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">feq</span> : IsEquiv f} (<span class="nv">z</span> : A)
  : transport (<span class="kr">fun</span> <span class="nv">X</span>:<span class="kt">Type</span> =&gt; X) (path_universe f) z = f z
  := transport_path_universe_uncurried (Build_Equiv A B f feq) z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Alternatively, [ap10_equiv (eisretr (equiv_path A B) (Build_Equiv _ _ f feq)) z]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_path_universe_equiv_path</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">p</span> : A = B) (<span class="nv">z</span> : A)
  : transport_path_universe (equiv_path A B p) z =
    (ap (<span class="kr">fun</span> <span class="nv">s</span> =&gt; transport idmap s z) (eissect _ p))
  := equiv_ind_comp _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* This somewhat fancier version is useful when working with HITs. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_path_universe&#39;</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y)
  (<span class="nv">f</span> : P x &lt;~&gt; P y) (<span class="nv">q</span> : ap P p = path_universe f) (<span class="nv">u</span> : P x)
  : transport P p u = f u
  := transport_compose idmap P p u
   @ ap10 (ap (transport idmap) q) u
   @ transport_path_universe f u.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** And a version for transporting backwards. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkb2"><span class="kn">Definition</span> <span class="nf">transport_path_universe_V_uncurried</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B) (<span class="nv">z</span> : B)
  : transport (<span class="kr">fun</span> <span class="nv">X</span>:<span class="kt">Type</span> =&gt; X) (path_universe_uncurried f)^ z = f^-<span class="mi">1</span> z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap (path_universe_uncurried f)^ z =
f^-<span class="mi">1</span> z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkb3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap (path_universe_uncurried f)^ z =
f^-<span class="mi">1</span> z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkb4"><span class="nb">revert</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : A &lt;~&gt; B,
transport idmap (path_universe_uncurried f)^ z =
f^-<span class="mi">1</span> z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkb5">equiv_intro (equiv_path A B) p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap
  (path_universe_uncurried (equiv_path A B p))^ z =
(equiv_path A B p)^-<span class="mi">1</span> z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap (<span class="kr">fun</span> <span class="nv">s</span> =&gt; transport idmap s z) (inverse2 (eissect _ p))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_path_universe_V</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">feq</span> : IsEquiv f} (<span class="nv">z</span> : B)
  : transport (<span class="kr">fun</span> <span class="nv">X</span>:<span class="kt">Type</span> =&gt; X) (path_universe f)^ z = f^-<span class="mi">1</span> z
  := transport_path_universe_V_uncurried (Build_Equiv _ _ f feq) z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Alternatively, [(transport2 idmap (path_universe_V f) z)^ @ (transport_path_universe (f^-1) z)]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_path_universe_V_equiv_path</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">p</span> : A = B) (<span class="nv">z</span> : B)
  : transport_path_universe_V (equiv_path A B p) z =
    ap (<span class="kr">fun</span> <span class="nv">s</span> =&gt; transport idmap s z) (inverse2 (eissect _ p))
  := equiv_ind_comp _ _ _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** And some coherence for it. *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkb6"><span class="kn">Definition</span> <span class="nf">transport_path_universe_Vp_uncurried</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B) (<span class="nv">z</span> : A)
: ap (transport idmap (path_universe f)^) (transport_path_universe f z)
  @ transport_path_universe_V f (f z)
  @ eissect f z
  = transport_Vp idmap (path_universe f) z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (transport idmap (path_universe f)^)
   (transport_path_universe f z) @
 transport_path_universe_V f (f z)) @ eissect f z =
transport_Vp idmap (path_universe f) z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkb7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap (transport idmap (path_universe f)^)
   (transport_path_universe f z) @
 transport_path_universe_V f (f z)) @ eissect f z =
transport_Vp idmap (path_universe f) z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkb8"><span class="nb">pattern</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">e</span> : A &lt;~&gt; B =&gt;
 (ap (transport idmap (path_universe e)^)
    (transport_path_universe e z) @
  transport_path_universe_V e (e z)) @ eissect e z =
 transport_Vp idmap (path_universe e) z) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkb9"><span class="nb">refine</span> (equiv_ind (equiv_path A B) _ _ _); <span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap
   (transport idmap
      (path_universe (equiv_path A B p))^)
   (transport_path_universe (equiv_path A B p) z) @
 transport_path_universe_V (equiv_path A B p)
   (equiv_path A B p z)) @
eissect (equiv_path A B p) z =
transport_Vp idmap (path_universe (equiv_path A B p))
  z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Something slightly sneaky happens here: by definition of [equiv_path], [eissect (equiv_path A B p)] is judgmentally equal to [transport_Vp idmap p].  Thus, we can apply [ap_transport_Vp_idmap]. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkba"><span class="nb">refine</span> (_ @ ap_transport_Vp_idmap p (path_universe (equiv_path A B p))
            (eissect (equiv_path A B) p) z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap
   (transport idmap
      (path_universe (equiv_path A B p))^)
   (transport_path_universe (equiv_path A B p) z) @
 transport_path_universe_V (equiv_path A B p)
   (equiv_path A B p z)) @
eissect (equiv_path A B p) z =
(ap
   (transport idmap
      (path_universe (equiv_path A B p))^)
   (ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s z)
      (eissect (equiv_path A B) p)) @
 ap
   (<span class="kr">fun</span> <span class="nv">s</span> : B = A =&gt;
    transport idmap s (transport idmap p z))
   (inverse2 (eissect (equiv_path A B) p))) @
transport_Vp idmap p z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkbb"><span class="nb">apply</span> whiskerR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (transport idmap (path_universe (equiv_path A B p))^)
  (transport_path_universe (equiv_path A B p) z) @
transport_path_universe_V (equiv_path A B p)
  (equiv_path A B p z) =
ap
  (transport idmap (path_universe (equiv_path A B p))^)
  (ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s z)
     (eissect (equiv_path A B) p)) @
ap
  (<span class="kr">fun</span> <span class="nv">s</span> : B = A =&gt;
   transport idmap s (transport idmap p z))
  (inverse2 (eissect (equiv_path A B) p))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkbc"><span class="nb">apply</span> concat2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (transport idmap (path_universe (equiv_path A B p))^)
  (transport_path_universe (equiv_path A B p) z) =
ap
  (transport idmap (path_universe (equiv_path A B p))^)
  (ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s z)
     (eissect (equiv_path A B) p))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="universe-v-chkbd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><label class="goal-separator" for="universe-v-chkbd"><hr></label><div class="goal-conclusion">transport_path_universe_V (equiv_path A B p)
  (equiv_path A B p z) =
ap
  (<span class="kr">fun</span> <span class="nv">s</span> : B = A =&gt;
   transport idmap s (transport idmap p z))
  (inverse2 (eissect (equiv_path A B) p))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkbe">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (transport idmap (path_universe (equiv_path A B p))^)
  (transport_path_universe (equiv_path A B p) z) =
ap
  (transport idmap (path_universe (equiv_path A B p))^)
  (ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s z)
     (eissect (equiv_path A B) p))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkbf"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_path_universe (equiv_path A B p) z =
ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s z)
  (eissect (equiv_path A B) p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_path_universe_equiv_path.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkc0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_path_universe_V (equiv_path A B p)
  (equiv_path A B p z) =
ap
  (<span class="kr">fun</span> <span class="nv">s</span> : B = A =&gt;
   transport idmap s (transport idmap p z))
  (inverse2 (eissect (equiv_path A B) p))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_path_universe_V_equiv_path.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_path_universe_Vp</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">feq</span> : IsEquiv f} (<span class="nv">z</span> : A)
: ap (transport idmap (path_universe f)^) (transport_path_universe f z)
  @ transport_path_universe_V f (f z)
  @ eissect f z
  = transport_Vp idmap (path_universe f) z
  := transport_path_universe_Vp_uncurried (Build_Equiv A B f feq) z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** *** Transporting in particular type families *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkc1"><span class="kn">Theorem</span> <span class="nf">transport_arrow_toconst_path_universe</span> {<span class="nv">A</span> <span class="nv">U</span> <span class="nv">V</span> : <span class="kt">Type</span>} (<span class="nv">w</span> : U &lt;~&gt; V)
  : <span class="kr">forall</span> <span class="nv">f</span> : U -&gt; A, transport (<span class="kr">fun</span> <span class="nv">E</span> : <span class="kt">Type</span> =&gt; E -&gt; A) (path_universe w) f = (f o w^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, U, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>U &lt;~&gt; V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : U -&gt; A,
transport (<span class="kr">fun</span> <span class="nv">E</span> : <span class="kt">Type</span> =&gt; E -&gt; A) (path_universe w) f =
f o w^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkc2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, U, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>U &lt;~&gt; V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">f</span> : U -&gt; A,
transport (<span class="kr">fun</span> <span class="nv">E</span> : <span class="kt">Type</span> =&gt; E -&gt; A) (path_universe w) f =
f o w^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkc3"><span class="nb">intros</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, U, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>U &lt;~&gt; V</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>U -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">E</span> : <span class="kt">Type</span> =&gt; E -&gt; A) (path_universe w) f =
f o w^-<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkc4">funext y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, U, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>U &lt;~&gt; V</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>U -&gt; A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">E</span> : <span class="kt">Type</span> =&gt; E -&gt; A) (path_universe w) f
  y = f (w^-<span class="mi">1</span> y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkc5"><span class="nb">refine</span> (transport_arrow_toconst _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, U, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>U &lt;~&gt; V</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>U -&gt; A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (transport idmap (path_universe w)^ y) = f (w^-<span class="mi">1</span> y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkc6"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, U, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>U &lt;~&gt; V</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>U -&gt; A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport idmap (path_universe w)^ y = w^-<span class="mi">1</span> y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_path_universe_V.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** 2-paths *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkc7"><span class="kn">Definition</span> <span class="nf">equiv_path2_universe</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : A &lt;~&gt; B)
: (f == g) &lt;~&gt; (path_universe f = path_universe g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g &lt;~&gt; path_universe f = path_universe g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkc8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f == g &lt;~&gt; path_universe f = path_universe g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkc9"><span class="nb">refine</span> (_ oE equiv_path_arrow f g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g &lt;~&gt; path_universe f = path_universe g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkca"><span class="nb">refine</span> (_ oE equiv_path_equiv f g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f = g &lt;~&gt; path_universe f = path_universe g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_ap (equiv_path A B)^-<span class="mi">1</span> _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path2_universe</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> : A &lt;~&gt; B}
: (f == g) -&gt; (path_universe f = path_universe g)
  := equiv_path2_universe f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkcb"><span class="kn">Definition</span> <span class="nf">equiv_path2_universe_1</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B)
: equiv_path2_universe f f (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="mi">1</span>) = <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path2_universe f f (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="mi">1</span>) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkcc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path2_universe f f (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="mi">1</span>) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkcd"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (equiv_path A B)^-<span class="mi">1</span>
  ((<span class="mi">1</span> @
    ap
      (<span class="kr">fun</span> <span class="nv">u</span> : {f : A -&gt; B &amp; IsEquiv f} =&gt;
       {| equiv_fun := u.<span class="mi">1</span>; equiv_isequiv := u.<span class="mi">2</span> |})
      (path_sigma_hprop (f; equiv_isequiv f)
         (f; equiv_isequiv f)
         (path_forall f f (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="mi">1</span>)))) @ <span class="mi">1</span>) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkce"><span class="nb">rewrite</span> concat_1p, concat_p1, path_forall_1, path_sigma_hprop_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (equiv_path A B)^-<span class="mi">1</span>
  (ap
     (<span class="kr">fun</span> <span class="nv">u</span> : {f : A -&gt; B &amp; IsEquiv f} =&gt;
      {| equiv_fun := u.<span class="mi">1</span>; equiv_isequiv := u.<span class="mi">2</span> |}) <span class="mi">1</span>) =
<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path2_universe_1</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B)
: @path2_universe _ _ f f (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="mi">1</span>) = <span class="mi">1</span>
  := equiv_path2_universe_1 f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** There ought to be a lemma which says something like this:</span>

<span class="sd">&lt;&lt;</span>
<span class="sd">Definition path2_universe_postcompose</span>
<span class="sd">           {A B C : Type} {f1 f2 : A &lt;~&gt; B} (p : f1 == f2)</span>
<span class="sd">           (g : B &lt;~&gt; C)</span>
<span class="sd">: equiv_path2_universe (g o f1)</span>
<span class="sd">                       (g o f2)</span>
<span class="sd">                       (fun a =&gt; ap g (p a))</span>
<span class="sd">  = path_universe_compose f1 g</span>
<span class="sd">    @ whiskerR (path2_universe p) (path_universe g)</span>
<span class="sd">    @ (path_universe_compose f2 g)^.</span>
<span class="sd">&gt;&gt;</span>

<span class="sd">and similarly</span>

<span class="sd">&lt;&lt;</span>
<span class="sd">Definition path2_universe_precompose</span>
<span class="sd">           {A B C : Type} {f1 f2 : B &lt;~&gt; C} (p : f1 == f2)</span>
<span class="sd">           (g : A &lt;~&gt; B)</span>
<span class="sd">: equiv_path2_universe (f1 o g)</span>
<span class="sd">                       (f2 o g)</span>
<span class="sd">                       (fun a =&gt; (p (g a)))</span>
<span class="sd">  = path_universe_compose g f1</span>
<span class="sd">    @ whiskerL (path_universe g) (path2_universe p)</span>
<span class="sd">    @ (path_universe_compose g f2)^.</span>
<span class="sd">&gt;&gt;</span>

<span class="sd">but I haven&#39;t managed to prove them yet.  Fortunately, for existing applications what we actually need is the following rather different-looking version that applies only when [f1] and [f2] are identities. *)</span>

<span class="sd">(** Coq is too eager about unfolding [equiv_path_equiv] in the following proofs, so we tell it not to.  We go into a section in order to limit the scope of the [simpl never] command. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">PathEquivSimplNever</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Arguments</span> equiv_path_equiv : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkcf"><span class="kn">Definition</span> <span class="nf">path2_universe_postcompose_idmap</span>
             {<span class="nv">A</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">a</span>:A, a = a)
             (<span class="nv">g</span> : A &lt;~&gt; C)
  : equiv_path2_universe g g (<span class="kr">fun</span> <span class="nv">a</span> =&gt; ap g (p a))
    = (concat_1p _)^
      @ whiskerR (path_universe_1)^ (path_universe g)
      @ whiskerR (equiv_path2_universe (equiv_idmap A) (equiv_idmap A) p)
        (path_universe g)
      @ whiskerR path_universe_1 (path_universe g)
      @ concat_1p _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path2_universe g g (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; ap g (p a)) =
((((concat_1p (path_universe g))^ @
   whiskerR path_universe_1^ (path_universe g)) @
  whiskerR (equiv_path2_universe <span class="mi">1</span> <span class="mi">1</span> p)
    (path_universe g)) @
 whiskerR path_universe_1 (path_universe g)) @
concat_1p (path_universe g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkd0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path2_universe g g (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; ap g (p a)) =
((((concat_1p (path_universe g))^ @
   whiskerR path_universe_1^ (path_universe g)) @
  whiskerR (equiv_path2_universe <span class="mi">1</span> <span class="mi">1</span> p)
    (path_universe g)) @
 whiskerR path_universe_1 (path_universe g)) @
concat_1p (path_universe g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkd1"><span class="nb">transitivity</span> ((eta_path_universe (path_universe g))^
                  @ equiv_path2_universe
                    (equiv_path A C (path_universe g))
                    (equiv_path A C (path_universe g))
                    (<span class="kr">fun</span> <span class="nv">a</span> =&gt; ap (equiv_path A C (path_universe g)) (p a))
                    @ eta_path_universe (path_universe g)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path2_universe g g (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; ap g (p a)) =
((eta_path_universe (path_universe g))^ @
 equiv_path2_universe
   (equiv_path A C (path_universe g))
   (equiv_path A C (path_universe g))
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    ap (equiv_path A C (path_universe g)) (p a))) @
eta_path_universe (path_universe g)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="universe-v-chkd2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br></div><label class="goal-separator" for="universe-v-chkd2"><hr></label><div class="goal-conclusion">((eta_path_universe (path_universe g))^ @
 equiv_path2_universe
   (equiv_path A C (path_universe g))
   (equiv_path A C (path_universe g))
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    ap (equiv_path A C (path_universe g)) (p a))) @
eta_path_universe (path_universe g) =
((((concat_1p (path_universe g))^ @
   whiskerR path_universe_1^ (path_universe g)) @
  whiskerR (equiv_path2_universe <span class="mi">1</span> <span class="mi">1</span> p)
    (path_universe g)) @
 whiskerR path_universe_1 (path_universe g)) @
concat_1p (path_universe g)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkd3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path2_universe g g (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; ap g (p a)) =
((eta_path_universe (path_universe g))^ @
 equiv_path2_universe
   (equiv_path A C (path_universe g))
   (equiv_path A C (path_universe g))
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    ap (equiv_path A C (path_universe g)) (p a))) @
eta_path_universe (path_universe g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkd4"><span class="nb">refine</span> ((apD (<span class="kr">fun</span> <span class="nv">g&#39;</span> =&gt; equiv_path2_universe g&#39; g&#39;
                                (<span class="kr">fun</span> <span class="nv">a</span> =&gt; ap g&#39; (p a)))
                   (eisretr (equiv_path A C) g))^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">g&#39;</span> : A &lt;~&gt; C =&gt;
   path_universe g&#39; = path_universe g&#39;)
  (eisretr (equiv_path A C) g)
  (equiv_path2_universe
     (equiv_path A C ((equiv_path A C)^-<span class="mi">1</span> g))
     (equiv_path A C ((equiv_path A C)^-<span class="mi">1</span> g))
     (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
      ap (equiv_path A C ((equiv_path A C)^-<span class="mi">1</span> g))
        (p a))) =
((eta_path_universe (path_universe g))^ @
 equiv_path2_universe
   (equiv_path A C (path_universe g))
   (equiv_path A C (path_universe g))
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    ap (equiv_path A C (path_universe g)) (p a))) @
eta_path_universe (path_universe g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkd5"><span class="nb">refine</span> (transport_paths_FlFr (eisretr (equiv_path A C) g) _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ap path_universe_uncurried
    (eisretr (equiv_path A C) g))^ @
 equiv_path2_universe
   (equiv_path A C ((equiv_path A C)^-<span class="mi">1</span> g))
   (equiv_path A C ((equiv_path A C)^-<span class="mi">1</span> g))
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    ap (equiv_path A C ((equiv_path A C)^-<span class="mi">1</span> g)) (p a))) @
ap path_universe_uncurried
  (eisretr (equiv_path A C) g) =
((eta_path_universe (path_universe g))^ @
 equiv_path2_universe
   (equiv_path A C (path_universe g))
   (equiv_path A C (path_universe g))
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    ap (equiv_path A C (path_universe g)) (p a))) @
eta_path_universe (path_universe g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkd6"><span class="nb">apply</span> concat2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap path_universe_uncurried
   (eisretr (equiv_path A C) g))^ @
equiv_path2_universe
  (equiv_path A C ((equiv_path A C)^-<span class="mi">1</span> g))
  (equiv_path A C ((equiv_path A C)^-<span class="mi">1</span> g))
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
   ap (equiv_path A C ((equiv_path A C)^-<span class="mi">1</span> g)) (p a)) =
(eta_path_universe (path_universe g))^ @
equiv_path2_universe
  (equiv_path A C (path_universe g))
  (equiv_path A C (path_universe g))
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
   ap (equiv_path A C (path_universe g)) (p a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="universe-v-chkd7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br></div><label class="goal-separator" for="universe-v-chkd7"><hr></label><div class="goal-conclusion">ap path_universe_uncurried
  (eisretr (equiv_path A C) g) =
eta_path_universe (path_universe g)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkd8">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap path_universe_uncurried
   (eisretr (equiv_path A C) g))^ @
equiv_path2_universe
  (equiv_path A C ((equiv_path A C)^-<span class="mi">1</span> g))
  (equiv_path A C ((equiv_path A C)^-<span class="mi">1</span> g))
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
   ap (equiv_path A C ((equiv_path A C)^-<span class="mi">1</span> g)) (p a)) =
(eta_path_universe (path_universe g))^ @
equiv_path2_universe
  (equiv_path A C (path_universe g))
  (equiv_path A C (path_universe g))
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
   ap (equiv_path A C (path_universe g)) (p a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkd9"><span class="nb">apply</span> whiskerR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap path_universe_uncurried
   (eisretr (equiv_path A C) g))^ =
(eta_path_universe (path_universe g))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkda"><span class="nb">apply</span> inverse2, <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta_path_universe (path_universe g) =
ap path_universe_uncurried
  (eisretr (equiv_path A C) g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (eisadj (equiv_path A C)^-<span class="mi">1</span> g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkdb">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap path_universe_uncurried
  (eisretr (equiv_path A C) g) =
eta_path_universe (path_universe g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">refine</span> (eisadj (equiv_path A C)^-<span class="mi">1</span> g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkdc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eta_path_universe (path_universe g))^ @
 equiv_path2_universe
   (equiv_path A C (path_universe g))
   (equiv_path A C (path_universe g))
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    ap (equiv_path A C (path_universe g)) (p a))) @
eta_path_universe (path_universe g) =
((((concat_1p (path_universe g))^ @
   whiskerR path_universe_1^ (path_universe g)) @
  whiskerR (equiv_path2_universe <span class="mi">1</span> <span class="mi">1</span> p)
    (path_universe g)) @
 whiskerR path_universe_1 (path_universe g)) @
concat_1p (path_universe g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkdd"><span class="nb">generalize</span> (path_universe g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p0</span> : A = C,
((eta_path_universe p0)^ @
 equiv_path2_universe (equiv_path A C p0)
   (equiv_path A C p0)
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; ap (equiv_path A C p0) (p a))) @
eta_path_universe p0 =
((((concat_1p p0)^ @ whiskerR path_universe_1^ p0) @
  whiskerR (equiv_path2_universe <span class="mi">1</span> <span class="mi">1</span> p) p0) @
 whiskerR path_universe_1 p0) @ concat_1p p0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkde"><span class="nb">intros</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; C</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A = C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eta_path_universe h)^ @
 equiv_path2_universe (equiv_path A C h)
   (equiv_path A C h)
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; ap (equiv_path A C h) (p a))) @
eta_path_universe h =
((((concat_1p h)^ @ whiskerR path_universe_1^ h) @
  whiskerR (equiv_path2_universe <span class="mi">1</span> <span class="mi">1</span> p) h) @
 whiskerR path_universe_1 h) @ concat_1p h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkdf"><span class="nb">destruct</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eta_path_universe <span class="mi">1</span>)^ @
 equiv_path2_universe (equiv_path A A <span class="mi">1</span>)
   (equiv_path A A <span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; ap (equiv_path A A <span class="mi">1</span>) (p a))) @
eta_path_universe <span class="mi">1</span> =
((((concat_1p <span class="mi">1</span>)^ @ whiskerR path_universe_1^ <span class="mi">1</span>) @
  whiskerR (equiv_path2_universe <span class="mi">1</span> <span class="mi">1</span> p) <span class="mi">1</span>) @
 whiskerR path_universe_1 <span class="mi">1</span>) @ concat_1p <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chke0"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eta_path_universe <span class="mi">1</span>)^ @
 ap (equiv_path A A)^-<span class="mi">1</span>
   (equiv_path_equiv (equiv_path A A <span class="mi">1</span>)
      (equiv_path A A <span class="mi">1</span>)
      (path_forall (transport idmap <span class="mi">1</span>)
         (transport idmap <span class="mi">1</span>)
         (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; ap (transport idmap <span class="mi">1</span>) (p a))))) @
eta_path_universe <span class="mi">1</span> =
(((<span class="mi">1</span> @ whiskerR path_universe_1^ <span class="mi">1</span>) @
  whiskerR
    (ap (equiv_path A A)^-<span class="mi">1</span>
       (equiv_path_equiv <span class="mi">1</span> <span class="mi">1</span>
          (path_forall idmap idmap p))) <span class="mi">1</span>) @
 whiskerR path_universe_1 <span class="mi">1</span>) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chke1"><span class="nb">rewrite</span> !concat_1p, !concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eta_path_universe <span class="mi">1</span>)^ @
 ap (equiv_path A A)^-<span class="mi">1</span>
   (equiv_path_equiv (equiv_path A A <span class="mi">1</span>)
      (equiv_path A A <span class="mi">1</span>)
      (path_forall (transport idmap <span class="mi">1</span>)
         (transport idmap <span class="mi">1</span>)
         (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; ap (transport idmap <span class="mi">1</span>) (p a))))) @
eta_path_universe <span class="mi">1</span> =
(whiskerR path_universe_1^ <span class="mi">1</span> @
 whiskerR
   (ap (equiv_path A A)^-<span class="mi">1</span>
      (equiv_path_equiv <span class="mi">1</span> <span class="mi">1</span>
         (path_forall idmap idmap p))) <span class="mi">1</span>) @
whiskerR path_universe_1 <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chke2"><span class="nb">refine</span> (_ @ whiskerR (whiskerR_pp <span class="mi">1</span> path_universe_1^ _) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eta_path_universe <span class="mi">1</span>)^ @
 ap (equiv_path A A)^-<span class="mi">1</span>
   (equiv_path_equiv (equiv_path A A <span class="mi">1</span>)
      (equiv_path A A <span class="mi">1</span>)
      (path_forall (transport idmap <span class="mi">1</span>)
         (transport idmap <span class="mi">1</span>)
         (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; ap (transport idmap <span class="mi">1</span>) (p a))))) @
eta_path_universe <span class="mi">1</span> =
whiskerR
  (path_universe_1^ @
   ap (equiv_path A A)^-<span class="mi">1</span>
     (equiv_path_equiv <span class="mi">1</span> <span class="mi">1</span> (path_forall idmap idmap p)))
  <span class="mi">1</span> @ whiskerR path_universe_1 <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chke3"><span class="nb">refine</span> (_ @ whiskerR_pp <span class="mi">1</span> _ path_universe_1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eta_path_universe <span class="mi">1</span>)^ @
 ap (equiv_path A A)^-<span class="mi">1</span>
   (equiv_path_equiv (equiv_path A A <span class="mi">1</span>)
      (equiv_path A A <span class="mi">1</span>)
      (path_forall (transport idmap <span class="mi">1</span>)
         (transport idmap <span class="mi">1</span>)
         (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; ap (transport idmap <span class="mi">1</span>) (p a))))) @
eta_path_universe <span class="mi">1</span> =
whiskerR
  ((path_universe_1^ @
    ap (equiv_path A A)^-<span class="mi">1</span>
      (equiv_path_equiv <span class="mi">1</span> <span class="mi">1</span>
         (path_forall idmap idmap p))) @
   path_universe_1) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chke4"><span class="nb">refine</span> (_ @ (whiskerR_p1_1 _)^).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eta_path_universe <span class="mi">1</span>)^ @
 ap (equiv_path A A)^-<span class="mi">1</span>
   (equiv_path_equiv (equiv_path A A <span class="mi">1</span>)
      (equiv_path A A <span class="mi">1</span>)
      (path_forall (transport idmap <span class="mi">1</span>)
         (transport idmap <span class="mi">1</span>)
         (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; ap (transport idmap <span class="mi">1</span>) (p a))))) @
eta_path_universe <span class="mi">1</span> =
(path_universe_1^ @
 ap (equiv_path A A)^-<span class="mi">1</span>
   (equiv_path_equiv <span class="mi">1</span> <span class="mi">1</span> (path_forall idmap idmap p))) @
path_universe_1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chke5"><span class="nb">apply</span> whiskerR, whiskerL, ap, ap, ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, a = a</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; ap (transport idmap <span class="mi">1</span>) (p a)) = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> path_forall; <span class="nb">intros</span> x; <span class="nb">apply</span> ap_idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chke6"><span class="kn">Definition</span> <span class="nf">path2_universe_precompose_idmap</span>
             {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">b</span>:B, b = b)
             (<span class="nv">g</span> : A &lt;~&gt; B)
  : equiv_path2_universe g g (<span class="kr">fun</span> <span class="nv">a</span> =&gt; (p (g a)))
    = (concat_p1 _)^
      @ whiskerL (path_universe g) (path_universe_1)^
      @ whiskerL (path_universe g)
          (equiv_path2_universe (equiv_idmap B) (equiv_idmap B) p)
      @ whiskerL (path_universe g) (path_universe_1)
      @ concat_p1 _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path2_universe g g (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; p (g a)) =
((((concat_p1 (path_universe g))^ @
   whiskerL (path_universe g) path_universe_1^) @
  whiskerL (path_universe g)
    (equiv_path2_universe <span class="mi">1</span> <span class="mi">1</span> p)) @
 whiskerL (path_universe g) path_universe_1) @
concat_p1 (path_universe g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chke7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path2_universe g g (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; p (g a)) =
((((concat_p1 (path_universe g))^ @
   whiskerL (path_universe g) path_universe_1^) @
  whiskerL (path_universe g)
    (equiv_path2_universe <span class="mi">1</span> <span class="mi">1</span> p)) @
 whiskerL (path_universe g) path_universe_1) @
concat_p1 (path_universe g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chke8"><span class="nb">transitivity</span> ((eta_path_universe (path_universe g))^
                @ equiv_path2_universe
                  (equiv_path A B (path_universe g))
                  (equiv_path A B (path_universe g))
                  (<span class="kr">fun</span> <span class="nv">a</span> =&gt; p (equiv_path A B (path_universe g) a))
                @ eta_path_universe (path_universe g)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path2_universe g g (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; p (g a)) =
((eta_path_universe (path_universe g))^ @
 equiv_path2_universe
   (equiv_path A B (path_universe g))
   (equiv_path A B (path_universe g))
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    p (equiv_path A B (path_universe g) a))) @
eta_path_universe (path_universe g)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="universe-v-chke9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><label class="goal-separator" for="universe-v-chke9"><hr></label><div class="goal-conclusion">((eta_path_universe (path_universe g))^ @
 equiv_path2_universe
   (equiv_path A B (path_universe g))
   (equiv_path A B (path_universe g))
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    p (equiv_path A B (path_universe g) a))) @
eta_path_universe (path_universe g) =
((((concat_p1 (path_universe g))^ @
   whiskerL (path_universe g) path_universe_1^) @
  whiskerL (path_universe g)
    (equiv_path2_universe <span class="mi">1</span> <span class="mi">1</span> p)) @
 whiskerL (path_universe g) path_universe_1) @
concat_p1 (path_universe g)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkea">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path2_universe g g (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; p (g a)) =
((eta_path_universe (path_universe g))^ @
 equiv_path2_universe
   (equiv_path A B (path_universe g))
   (equiv_path A B (path_universe g))
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    p (equiv_path A B (path_universe g) a))) @
eta_path_universe (path_universe g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkeb"><span class="nb">refine</span> ((apD (<span class="kr">fun</span> <span class="nv">g&#39;</span> =&gt; equiv_path2_universe g&#39; g&#39;
                              (<span class="kr">fun</span> <span class="nv">a</span> =&gt; p (g&#39; a)))
              (eisretr (equiv_path A B) g))^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">g&#39;</span> : A &lt;~&gt; B =&gt;
   path_universe g&#39; = path_universe g&#39;)
  (eisretr (equiv_path A B) g)
  (equiv_path2_universe
     (equiv_path A B ((equiv_path A B)^-<span class="mi">1</span> g))
     (equiv_path A B ((equiv_path A B)^-<span class="mi">1</span> g))
     (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
      p (equiv_path A B ((equiv_path A B)^-<span class="mi">1</span> g) a))) =
((eta_path_universe (path_universe g))^ @
 equiv_path2_universe
   (equiv_path A B (path_universe g))
   (equiv_path A B (path_universe g))
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    p (equiv_path A B (path_universe g) a))) @
eta_path_universe (path_universe g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkec"><span class="nb">refine</span> (transport_paths_FlFr (eisretr (equiv_path A B) g) _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((ap path_universe_uncurried
    (eisretr (equiv_path A B) g))^ @
 equiv_path2_universe
   (equiv_path A B ((equiv_path A B)^-<span class="mi">1</span> g))
   (equiv_path A B ((equiv_path A B)^-<span class="mi">1</span> g))
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    p (equiv_path A B ((equiv_path A B)^-<span class="mi">1</span> g) a))) @
ap path_universe_uncurried
  (eisretr (equiv_path A B) g) =
((eta_path_universe (path_universe g))^ @
 equiv_path2_universe
   (equiv_path A B (path_universe g))
   (equiv_path A B (path_universe g))
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    p (equiv_path A B (path_universe g) a))) @
eta_path_universe (path_universe g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chked"><span class="nb">apply</span> concat2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap path_universe_uncurried
   (eisretr (equiv_path A B) g))^ @
equiv_path2_universe
  (equiv_path A B ((equiv_path A B)^-<span class="mi">1</span> g))
  (equiv_path A B ((equiv_path A B)^-<span class="mi">1</span> g))
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
   p (equiv_path A B ((equiv_path A B)^-<span class="mi">1</span> g) a)) =
(eta_path_universe (path_universe g))^ @
equiv_path2_universe
  (equiv_path A B (path_universe g))
  (equiv_path A B (path_universe g))
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; p (equiv_path A B (path_universe g) a))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="universe-v-chkee" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><label class="goal-separator" for="universe-v-chkee"><hr></label><div class="goal-conclusion">ap path_universe_uncurried
  (eisretr (equiv_path A B) g) =
eta_path_universe (path_universe g)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkef">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap path_universe_uncurried
   (eisretr (equiv_path A B) g))^ @
equiv_path2_universe
  (equiv_path A B ((equiv_path A B)^-<span class="mi">1</span> g))
  (equiv_path A B ((equiv_path A B)^-<span class="mi">1</span> g))
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
   p (equiv_path A B ((equiv_path A B)^-<span class="mi">1</span> g) a)) =
(eta_path_universe (path_universe g))^ @
equiv_path2_universe
  (equiv_path A B (path_universe g))
  (equiv_path A B (path_universe g))
  (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; p (equiv_path A B (path_universe g) a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkf0"><span class="nb">apply</span> whiskerR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(ap path_universe_uncurried
   (eisretr (equiv_path A B) g))^ =
(eta_path_universe (path_universe g))^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkf1"><span class="nb">apply</span> inverse2, <span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta_path_universe (path_universe g) =
ap path_universe_uncurried
  (eisretr (equiv_path A B) g)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (eisadj (equiv_path A B)^-<span class="mi">1</span> g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkf2">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap path_universe_uncurried
  (eisretr (equiv_path A B) g) =
eta_path_universe (path_universe g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">refine</span> (eisadj (equiv_path A B)^-<span class="mi">1</span> g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkf3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eta_path_universe (path_universe g))^ @
 equiv_path2_universe
   (equiv_path A B (path_universe g))
   (equiv_path A B (path_universe g))
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt;
    p (equiv_path A B (path_universe g) a))) @
eta_path_universe (path_universe g) =
((((concat_p1 (path_universe g))^ @
   whiskerL (path_universe g) path_universe_1^) @
  whiskerL (path_universe g)
    (equiv_path2_universe <span class="mi">1</span> <span class="mi">1</span> p)) @
 whiskerL (path_universe g) path_universe_1) @
concat_p1 (path_universe g)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkf4"><span class="nb">generalize</span> (path_universe g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">p0</span> : A = B,
((eta_path_universe p0)^ @
 equiv_path2_universe (equiv_path A B p0)
   (equiv_path A B p0)
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; p (equiv_path A B p0 a))) @
eta_path_universe p0 =
((((concat_p1 p0)^ @ whiskerL p0 path_universe_1^) @
  whiskerL p0 (equiv_path2_universe <span class="mi">1</span> <span class="mi">1</span> p)) @
 whiskerL p0 path_universe_1) @ concat_p1 p0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkf5"><span class="nb">intros</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eta_path_universe h)^ @
 equiv_path2_universe (equiv_path A B h)
   (equiv_path A B h)
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; p (equiv_path A B h a))) @
eta_path_universe h =
((((concat_p1 h)^ @ whiskerL h path_universe_1^) @
  whiskerL h (equiv_path2_universe <span class="mi">1</span> <span class="mi">1</span> p)) @
 whiskerL h path_universe_1) @ concat_p1 h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkf6"><span class="nb">destruct</span> h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : A, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eta_path_universe <span class="mi">1</span>)^ @
 equiv_path2_universe (equiv_path A A <span class="mi">1</span>)
   (equiv_path A A <span class="mi">1</span>)
   (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; p (equiv_path A A <span class="mi">1</span> a))) @
eta_path_universe <span class="mi">1</span> =
((((concat_p1 <span class="mi">1</span>)^ @ whiskerL <span class="mi">1</span> path_universe_1^) @
  whiskerL <span class="mi">1</span> (equiv_path2_universe <span class="mi">1</span> <span class="mi">1</span> p)) @
 whiskerL <span class="mi">1</span> path_universe_1) @ concat_p1 <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkf7"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : A, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eta_path_universe <span class="mi">1</span>)^ @
 ap (equiv_path A A)^-<span class="mi">1</span>
   (equiv_path_equiv (equiv_path A A <span class="mi">1</span>)
      (equiv_path A A <span class="mi">1</span>)
      (path_forall (transport idmap <span class="mi">1</span>)
         (transport idmap <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; p a)))) @
eta_path_universe <span class="mi">1</span> =
(((<span class="mi">1</span> @ whiskerL <span class="mi">1</span> path_universe_1^) @
  whiskerL <span class="mi">1</span>
    (ap (equiv_path A A)^-<span class="mi">1</span>
       (equiv_path_equiv <span class="mi">1</span> <span class="mi">1</span>
          (path_forall idmap idmap p)))) @
 whiskerL <span class="mi">1</span> path_universe_1) @ <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkf8"><span class="nb">rewrite</span> !concat_p1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : A, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eta_path_universe <span class="mi">1</span>)^ @
 ap (equiv_path A A)^-<span class="mi">1</span>
   (equiv_path_equiv (equiv_path A A <span class="mi">1</span>)
      (equiv_path A A <span class="mi">1</span>)
      (path_forall (transport idmap <span class="mi">1</span>)
         (transport idmap <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; p a)))) @
eta_path_universe <span class="mi">1</span> =
((<span class="mi">1</span> @ whiskerL <span class="mi">1</span> path_universe_1^) @
 whiskerL <span class="mi">1</span>
   (ap (equiv_path A A)^-<span class="mi">1</span>
      (equiv_path_equiv <span class="mi">1</span> <span class="mi">1</span>
         (path_forall idmap idmap p)))) @
whiskerL <span class="mi">1</span> path_universe_1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkf9"><span class="nb">refine</span> (_ @ (((concat_1p (whiskerL <span class="mi">1</span> path_universe_1^))^ @@ <span class="mi">1</span>) @@ <span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : A, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eta_path_universe <span class="mi">1</span>)^ @
 ap (equiv_path A A)^-<span class="mi">1</span>
   (equiv_path_equiv (equiv_path A A <span class="mi">1</span>)
      (equiv_path A A <span class="mi">1</span>)
      (path_forall (transport idmap <span class="mi">1</span>)
         (transport idmap <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; p a)))) @
eta_path_universe <span class="mi">1</span> =
(whiskerL <span class="mi">1</span> path_universe_1^ @
 whiskerL <span class="mi">1</span>
   (ap (equiv_path A A)^-<span class="mi">1</span>
      (equiv_path_equiv <span class="mi">1</span> <span class="mi">1</span>
         (path_forall idmap idmap p)))) @
whiskerL <span class="mi">1</span> path_universe_1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkfa"><span class="nb">refine</span> (_ @ whiskerR (whiskerL_pp <span class="mi">1</span> path_universe_1^ _) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : A, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eta_path_universe <span class="mi">1</span>)^ @
 ap (equiv_path A A)^-<span class="mi">1</span>
   (equiv_path_equiv (equiv_path A A <span class="mi">1</span>)
      (equiv_path A A <span class="mi">1</span>)
      (path_forall (transport idmap <span class="mi">1</span>)
         (transport idmap <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; p a)))) @
eta_path_universe <span class="mi">1</span> =
whiskerL <span class="mi">1</span>
  (path_universe_1^ @
   ap (equiv_path A A)^-<span class="mi">1</span>
     (equiv_path_equiv <span class="mi">1</span> <span class="mi">1</span> (path_forall idmap idmap p))) @
whiskerL <span class="mi">1</span> path_universe_1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkfb"><span class="nb">refine</span> (_ @ whiskerL_pp <span class="mi">1</span> _ path_universe_1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : A, b = b</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((eta_path_universe <span class="mi">1</span>)^ @
 ap (equiv_path A A)^-<span class="mi">1</span>
   (equiv_path_equiv (equiv_path A A <span class="mi">1</span>)
      (equiv_path A A <span class="mi">1</span>)
      (path_forall (transport idmap <span class="mi">1</span>)
         (transport idmap <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; p a)))) @
eta_path_universe <span class="mi">1</span> =
whiskerL <span class="mi">1</span>
  ((path_universe_1^ @
    ap (equiv_path A A)^-<span class="mi">1</span>
      (equiv_path_equiv <span class="mi">1</span> <span class="mi">1</span>
         (path_forall idmap idmap p))) @
   path_universe_1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> ((whiskerL_1p_1 _)^).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">PathEquivSimplNever</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** 3-paths *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkfc"><span class="kn">Definition</span> <span class="nf">equiv_path3_universe</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> : A &lt;~&gt; B} (<span class="nv">p</span> <span class="nv">q</span> : f == g)
: (p == q) &lt;~&gt; (path2_universe p = path2_universe q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p == q &lt;~&gt; path2_universe p = path2_universe q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkfd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p == q &lt;~&gt; path2_universe p = path2_universe q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkfe"><span class="nb">refine</span> (_ oE equiv_path_forall p q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p = q &lt;~&gt; path2_universe p = path2_universe q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chkff"><span class="nb">refine</span> (_ oE equiv_ap (equiv_path_arrow f g) p q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_arrow f g p = equiv_path_arrow f g q &lt;~&gt;
path2_universe p = path2_universe q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk100"><span class="nb">refine</span> (_ oE equiv_ap (equiv_path_equiv f g) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_equiv f g (equiv_path_arrow f g p) =
equiv_path_equiv f g (equiv_path_arrow f g q) &lt;~&gt;
path2_universe p = path2_universe q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk101"><span class="nb">unfold</span> path2_universe, equiv_path2_universe.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">equiv_path_equiv f g (equiv_path_arrow f g p) =
equiv_path_equiv f g (equiv_path_arrow f g q) &lt;~&gt;
(equiv_ap (equiv_path A B)^-<span class="mi">1</span> f g
 oE equiv_path_equiv f g oE equiv_path_arrow f g) p =
(equiv_ap (equiv_path A B)^-<span class="mi">1</span> f g
 oE equiv_path_equiv f g oE equiv_path_arrow f g) q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk102"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>f == g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span> @
 ap
   (<span class="kr">fun</span> <span class="nv">u</span> : {f : A -&gt; B &amp; IsEquiv f} =&gt;
    {| equiv_fun := u.<span class="mi">1</span>; equiv_isequiv := u.<span class="mi">2</span> |})
   (path_sigma_hprop (f; equiv_isequiv f)
      (g; equiv_isequiv g) (path_forall f g p))) @ <span class="mi">1</span> =
(<span class="mi">1</span> @
 ap
   (<span class="kr">fun</span> <span class="nv">u</span> : {f : A -&gt; B &amp; IsEquiv f} =&gt;
    {| equiv_fun := u.<span class="mi">1</span>; equiv_isequiv := u.<span class="mi">2</span> |})
   (path_sigma_hprop (f; equiv_isequiv f)
      (g; equiv_isequiv g) (path_forall f g q))) @ <span class="mi">1</span> &lt;~&gt;
ap (equiv_path A B)^-<span class="mi">1</span>
  ((<span class="mi">1</span> @
    ap
      (<span class="kr">fun</span> <span class="nv">u</span> : {f : A -&gt; B &amp; IsEquiv f} =&gt;
       {| equiv_fun := u.<span class="mi">1</span>; equiv_isequiv := u.<span class="mi">2</span> |})
      (path_sigma_hprop (f; equiv_isequiv f)
         (g; equiv_isequiv g) (path_forall f g p))) @
   <span class="mi">1</span>) =
ap (equiv_path A B)^-<span class="mi">1</span>
  ((<span class="mi">1</span> @
    ap
      (<span class="kr">fun</span> <span class="nv">u</span> : {f : A -&gt; B &amp; IsEquiv f} =&gt;
       {| equiv_fun := u.<span class="mi">1</span>; equiv_isequiv := u.<span class="mi">2</span> |})
      (path_sigma_hprop (f; equiv_isequiv f)
         (g; equiv_isequiv g) (path_forall f g q))) @
   <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (equiv_ap (ap (equiv_path A B)^-<span class="mi">1</span>) _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">path3_universe</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> : A &lt;~&gt; B} {<span class="nv">p</span> <span class="nv">q</span> : f == g}
: (p == q) -&gt; (path2_universe p = path2_universe q)
  := equiv_path3_universe p q.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk103"><span class="kn">Definition</span> <span class="nf">transport_path_universe_pV_uncurried</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B) (<span class="nv">z</span> : B)
: transport_path_universe f (transport idmap (path_universe f)^ z)
  @ ap f (transport_path_universe_V f z)
  @ eisretr f z
  = transport_pV idmap (path_universe f) z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport_path_universe f
   (transport idmap (path_universe f)^ z) @
 ap f (transport_path_universe_V f z)) @ eisretr f z =
transport_pV idmap (path_universe f) z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk104"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport_path_universe f
   (transport idmap (path_universe f)^ z) @
 ap f (transport_path_universe_V f z)) @ eisretr f z =
transport_pV idmap (path_universe f) z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk105"><span class="nb">pattern</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">e</span> : A &lt;~&gt; B =&gt;
 (transport_path_universe e
    (transport idmap (path_universe e)^ z) @
  ap e (transport_path_universe_V e z)) @ eisretr e z =
 transport_pV idmap (path_universe e) z) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk106"><span class="nb">refine</span> (equiv_ind (equiv_path A B) _ _ _); <span class="nb">intros</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport_path_universe (equiv_path A B p)
   (transport idmap
      (path_universe (equiv_path A B p))^ z) @
 ap (equiv_path A B p)
   (transport_path_universe_V (equiv_path A B p) z)) @
eisretr (equiv_path A B p) z =
transport_pV idmap (path_universe (equiv_path A B p))
  z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk107"><span class="nb">refine</span> (_ @ ap_transport_pV_idmap p (path_universe (equiv_path A B p))
            (eissect (equiv_path A B) p) z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(transport_path_universe (equiv_path A B p)
   (transport idmap
      (path_universe (equiv_path A B p))^ z) @
 ap (equiv_path A B p)
   (transport_path_universe_V (equiv_path A B p) z)) @
eisretr (equiv_path A B p) z =
(ap
   (transport idmap (path_universe (equiv_path A B p)))
   (ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s^ z)
      (eissect (equiv_path A B) p)) @
 ap
   (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt;
    transport idmap s (transport idmap p^ z))
   (eissect (equiv_path A B) p)) @
transport_pV idmap p z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk108"><span class="nb">apply</span> whiskerR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_path_universe (equiv_path A B p)
  (transport idmap (path_universe (equiv_path A B p))^
     z) @
ap (equiv_path A B p)
  (transport_path_universe_V (equiv_path A B p) z) =
ap
  (transport idmap (path_universe (equiv_path A B p)))
  (ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s^ z)
     (eissect (equiv_path A B) p)) @
ap
  (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt;
   transport idmap s (transport idmap p^ z))
  (eissect (equiv_path A B) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk109"><span class="nb">refine</span> ((concat_Ap _ _)^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (transport idmap (path_universe (equiv_path A B p)))
  (transport_path_universe_V (equiv_path A B p) z) @
transport_path_universe (equiv_path A B p)
  ((equiv_path A B p)^-<span class="mi">1</span> z) =
ap
  (transport idmap (path_universe (equiv_path A B p)))
  (ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s^ z)
     (eissect (equiv_path A B) p)) @
ap
  (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt;
   transport idmap s (transport idmap p^ z))
  (eissect (equiv_path A B) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk10a"><span class="nb">apply</span> concat2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (transport idmap (path_universe (equiv_path A B p)))
  (transport_path_universe_V (equiv_path A B p) z) =
ap
  (transport idmap (path_universe (equiv_path A B p)))
  (ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s^ z)
     (eissect (equiv_path A B) p))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="universe-v-chk10b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><label class="goal-separator" for="universe-v-chk10b"><hr></label><div class="goal-conclusion">transport_path_universe (equiv_path A B p)
  ((equiv_path A B p)^-<span class="mi">1</span> z) =
ap
  (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt;
   transport idmap s (transport idmap p^ z))
  (eissect (equiv_path A B) p)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk10c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (transport idmap (path_universe (equiv_path A B p)))
  (transport_path_universe_V (equiv_path A B p) z) =
ap
  (transport idmap (path_universe (equiv_path A B p)))
  (ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s^ z)
     (eissect (equiv_path A B) p))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk10d"><span class="nb">apply</span> ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_path_universe_V (equiv_path A B p) z =
ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s^ z)
  (eissect (equiv_path A B) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk10e"><span class="nb">refine</span> (transport_path_universe_V_equiv_path _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">s</span> : B = A =&gt; transport idmap s z)
  (inverse2 (eissect (equiv_path A B) p)) =
ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s^ z)
  (eissect (equiv_path A B) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk10f"><span class="nb">unfold</span> inverse2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (<span class="kr">fun</span> <span class="nv">s</span> : B = A =&gt; transport idmap s z)
  (ap inverse (eissect (equiv_path A B) p)) =
ap (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt; transport idmap s^ z)
  (eissect (equiv_path A B) p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> (ap_compose inverse (<span class="kr">fun</span> <span class="nv">s</span> =&gt; transport idmap s z)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk110">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A &lt;~&gt; B</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_path_universe (equiv_path A B p)
  ((equiv_path A B p)^-<span class="mi">1</span> z) =
ap
  (<span class="kr">fun</span> <span class="nv">s</span> : A = B =&gt;
   transport idmap s (transport idmap p^ z))
  (eissect (equiv_path A B) p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> transport_path_universe_equiv_path.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transport_path_universe_pV</span>
           {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">feq</span> : IsEquiv f } (<span class="nv">z</span> : B)
: transport_path_universe f (transport idmap (path_universe f)^ z)
  @ ap f (transport_path_universe_V f z)
  @ eisretr f z
  = transport_pV idmap (path_universe f) z
:= transport_path_universe_pV_uncurried (Build_Equiv A B f feq) z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Equivalence induction *)</span>

<span class="sd">(** Paulin-Mohring style *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk111"><span class="kn">Theorem</span> <span class="nf">equiv_induction</span> {<span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : <span class="kr">forall</span> <span class="nv">V</span>, U &lt;~&gt; V -&gt; <span class="kt">Type</span>) :
  (P U (equiv_idmap U)) -&gt; (<span class="kr">forall</span> <span class="nv">V</span> (<span class="nv">w</span> : U &lt;~&gt; V), P V w).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">V</span> : <span class="kt">Type</span>, U &lt;~&gt; V -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P U <span class="mi">1</span>%equiv -&gt; <span class="kr">forall</span> (<span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">w</span> : U &lt;~&gt; V), P V w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk112"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">V</span> : <span class="kt">Type</span>, U &lt;~&gt; V -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P U <span class="mi">1</span>%equiv -&gt; <span class="kr">forall</span> (<span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">w</span> : U &lt;~&gt; V), P V w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk113"><span class="nb">intros</span> H0 V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">V</span> : <span class="kt">Type</span>, U &lt;~&gt; V -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P U <span class="mi">1</span>%equiv</span></span></span><br><span><var>V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">w</span> : U &lt;~&gt; V, P V w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk114"><span class="nb">apply</span> (equiv_ind (equiv_path U V)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">V</span> : <span class="kt">Type</span>, U &lt;~&gt; V -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P U <span class="mi">1</span>%equiv</span></span></span><br><span><var>V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : U = V, P V (equiv_path U V x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> p; <span class="nb">induction</span> p; <span class="bp">exact</span> H0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_induction_comp</span> {<span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : <span class="kr">forall</span> <span class="nv">V</span>, U &lt;~&gt; V -&gt; <span class="kt">Type</span>)
  (<span class="nv">didmap</span> : P U (equiv_idmap U))
  : equiv_induction P didmap U (equiv_idmap U) = didmap
  := (equiv_ind_comp (P U) _ <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Martin-Lof style *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk115"><span class="kn">Theorem</span> <span class="nf">equiv_induction&#39;</span> (<span class="nv">P</span> : <span class="kr">forall</span> <span class="nv">U</span> <span class="nv">V</span>, U &lt;~&gt; V -&gt; <span class="kt">Type</span>) :
  (<span class="kr">forall</span> <span class="nv">T</span>, P T T (equiv_idmap T)) -&gt; (<span class="kr">forall</span> <span class="nv">U</span> <span class="nv">V</span> (<span class="nv">w</span> : U &lt;~&gt; V), P U V w).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">U</span> <span class="nv">V</span> : <span class="kt">Type</span>, U &lt;~&gt; V -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, P T T <span class="mi">1</span>%equiv) -&gt;
<span class="kr">forall</span> (<span class="nv">U</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">w</span> : U &lt;~&gt; V), P U V w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk116"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">U</span> <span class="nv">V</span> : <span class="kt">Type</span>, U &lt;~&gt; V -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, P T T <span class="mi">1</span>%equiv) -&gt;
<span class="kr">forall</span> (<span class="nv">U</span> <span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">w</span> : U &lt;~&gt; V), P U V w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk117"><span class="nb">intros</span> H0 U V w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">U</span> <span class="nv">V</span> : <span class="kt">Type</span>, U &lt;~&gt; V -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, P T T <span class="mi">1</span>%equiv</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>U &lt;~&gt; V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P U V w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk118"><span class="nb">apply</span> (equiv_ind (equiv_path U V)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">U</span> <span class="nv">V</span> : <span class="kt">Type</span>, U &lt;~&gt; V -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, P T T <span class="mi">1</span>%equiv</span></span></span><br><span><var>U, V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>U &lt;~&gt; V</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : U = V, P U V (equiv_path U V x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> p; <span class="nb">induction</span> p; <span class="nb">apply</span> H0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_induction&#39;_comp</span> (<span class="nv">P</span> : <span class="kr">forall</span> <span class="nv">U</span> <span class="nv">V</span>, U &lt;~&gt; V -&gt; <span class="kt">Type</span>)
  (<span class="nv">didmap</span> : <span class="kr">forall</span> <span class="nv">T</span>, P T T (equiv_idmap T)) (<span class="nv">U</span> : <span class="kt">Type</span>)
  : equiv_induction&#39; P didmap U U (equiv_idmap U) = didmap U
  := (equiv_ind_comp (P U U) _ <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk119"><span class="kn">Theorem</span> <span class="nf">equiv_induction_inv</span> {<span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : <span class="kr">forall</span> <span class="nv">V</span>, V &lt;~&gt; U -&gt; <span class="kt">Type</span>) :
  (P U (equiv_idmap U)) -&gt; (<span class="kr">forall</span> <span class="nv">V</span> (<span class="nv">w</span> : V &lt;~&gt; U), P V w).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">V</span> : <span class="kt">Type</span>, V &lt;~&gt; U -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P U <span class="mi">1</span>%equiv -&gt; <span class="kr">forall</span> (<span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">w</span> : V &lt;~&gt; U), P V w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk11a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">V</span> : <span class="kt">Type</span>, V &lt;~&gt; U -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P U <span class="mi">1</span>%equiv -&gt; <span class="kr">forall</span> (<span class="nv">V</span> : <span class="kt">Type</span>) (<span class="nv">w</span> : V &lt;~&gt; U), P V w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk11b"><span class="nb">intros</span> H0 V.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">V</span> : <span class="kt">Type</span>, V &lt;~&gt; U -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P U <span class="mi">1</span>%equiv</span></span></span><br><span><var>V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">w</span> : V &lt;~&gt; U, P V w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk11c"><span class="nb">apply</span> (equiv_ind (equiv_path V U)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>U</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">V</span> : <span class="kt">Type</span>, V &lt;~&gt; U -&gt; <span class="kt">Type</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>P U <span class="mi">1</span>%equiv</span></span></span><br><span><var>V</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : V = U, P V (equiv_path V U x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* We manually apply [paths_ind_r] to reduce universe levels. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">revert</span> V; rapply paths_ind_r; <span class="nb">apply</span> H0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_induction_inv_comp</span> {<span class="nv">U</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : <span class="kr">forall</span> <span class="nv">V</span>, V &lt;~&gt; U -&gt; <span class="kt">Type</span>)
  (<span class="nv">didmap</span> : P U (equiv_idmap U))
  : equiv_induction_inv P didmap U (equiv_idmap U) = didmap
  := (equiv_ind_comp (P U) _ <span class="mi">1</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Based equivalence types *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk11d"><span class="kn">Global Instance</span> <span class="nf">contr_basedequiv</span>@{u +} {X : <span class="kt">Type</span>@{u}}
: Contr {Y : <span class="kt">Type</span>@{u} &amp; X &lt;~&gt; Y}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {Y : <span class="kt">Type</span> &amp; X &lt;~&gt; Y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk11e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {Y : <span class="kt">Type</span> &amp; X &lt;~&gt; Y}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk11f"><span class="nb">apply</span> (Build_Contr _ (X; equiv_idmap)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : {x : _ &amp; X &lt;~&gt; x}, (X; <span class="mi">1</span>%equiv) = y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk120"><span class="nb">intros</span> [Y f]; <span class="nb">revert</span> Y f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : X &lt;~&gt; Y), (X; <span class="mi">1</span>%equiv) = (Y; f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_induction _ idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk121"><span class="kn">Global Instance</span> <span class="nf">contr_basedequiv&#39;</span>@{u +} {X : <span class="kt">Type</span>@{u}}
: Contr {Y : <span class="kt">Type</span>@{u} &amp; Y &lt;~&gt; X}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {Y : <span class="kt">Type</span> &amp; Y &lt;~&gt; X}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk122"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr {Y : <span class="kt">Type</span> &amp; Y &lt;~&gt; X}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* The next line is used so that Coq can figure out the type of (X; equiv_idmap). *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk123">srapply Build_Contr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{Y : <span class="kt">Type</span> &amp; Y &lt;~&gt; X}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="universe-v-chk124" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="universe-v-chk124"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : {Y : <span class="kt">Type</span> &amp; Y &lt;~&gt; X}, <span class="nl">?center</span> = y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk125">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{Y : <span class="kt">Type</span> &amp; Y &lt;~&gt; X}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (X; equiv_idmap).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk126">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : {Y : <span class="kt">Type</span> &amp; Y &lt;~&gt; X}, (X; <span class="mi">1</span>%equiv) = y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk127"><span class="nb">intros</span> [Y f]; <span class="nb">revert</span> Y f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Y</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y &lt;~&gt; X), (X; <span class="mi">1</span>%equiv) = (Y; f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (equiv_induction_inv _ idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Truncations *)</span>

<span class="sd">(** Truncatedness of the universe is a subtle question, but with univalence we can conclude things about truncations of certain of its path-spaces. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk128"><span class="kn">Global Instance</span> <span class="nf">istrunc_paths_Type</span>
       {<span class="nv">n</span> : trunc_index} {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{IsTrunc n.+<span class="mi">1</span> B}
: IsTrunc n.+<span class="mi">1</span> (A = B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n.+<span class="mi">1</span> (A = B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk129"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n.+<span class="mi">1</span> B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n.+<span class="mi">1</span> (A = B)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (istrunc_isequiv_istrunc _ path_universe_uncurried).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We can also say easily that the universe is not a set. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk12a"><span class="kn">Definition</span> <span class="nf">not_hset_Type</span> : ~ (IsHSet <span class="kt">Type</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ IsHSet <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk12b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ IsHSet <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk12c"><span class="nb">intro</span> HT.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>IsHSet <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk12d"><span class="nb">apply</span> true_ne_false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>IsHSet <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk12e"><span class="nb">pose</span> (r := path_ishprop (path_universe equiv_negb) <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>IsHSet <span class="kt">Type</span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>path_ishprop (path_universe equiv_negb) <span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>path_universe equiv_negb = <span class="mi">1</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="universe-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="universe-v-chk12f"><span class="nb">refine</span> (_ @ (ap (<span class="kr">fun</span> <span class="nv">q</span> =&gt; transport idmap q false) r)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>IsHSet <span class="kt">Type</span></span></span></span><br><span><var>r</var><span><span class="hyp-body"><b>:= </b><span>path_ishprop (path_universe equiv_negb) <span class="mi">1</span></span></span><span class="hyp-type"><b>: </b><span>path_universe equiv_negb = <span class="mi">1</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">true =
transport idmap (path_universe equiv_negb) false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> transport_path_universe.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Univalence</span>.</span></span></pre>
</div>
</div></body>
</html>
