<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Core.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* -*- mode: coq; mode: visual-line -*- *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka72" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka72"><span class="kn">Require Import</span> Basics Types WildCat.Core WildCat.<span class="kn">Universe</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Modalities.Modality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Users of this file almost always want to be able to write [Tr n] for both a [Modality] and a [ReflectiveSubuniverse], so they want the coercion [modality_to_reflective_subuniverse]: *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> (coercions) Modalities.Modality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Truncations of types, in all dimensions *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable Variables</span> <span class="nf">A</span> X n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The definition *)</span>

<span class="sd">(** The definition of [Trunc n], the n-truncation of a type.</span>

<span class="sd">If Coq supported higher inductive types natively, we would construct this as somthing like:</span>

<span class="sd">   Inductive Trunc n (A : Type) : Type :=</span>
<span class="sd">   | tr : A -&gt; Trunc n A</span>
<span class="sd">   | istrunc_truncation : forall (f : Sphere n.+1 -&gt; Trunc n A)</span>
<span class="sd">       (x : Sphere n.+1), f x = f North.</span>

<span class="sd">However, while we are faking our higher-inductives anyway, we can take some shortcuts, rather than translating the definition above.  Firstly, we directly posit a ‚Äúconstructor‚Äù giving truncatedness, rather than rephrasing it in terms of maps of spheres.  Secondly, we omit the ‚Äúcomputation rule‚Äù for this constructor, since it is implied by truncatedness of the result type (and, for essentially that reason, is never wanted in practice anyway).</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Export</span> Trunc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Delimit Scope</span> trunc_scope <span class="kr">with</span> trunc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Cumulative</span> Private <span class="kn">Inductive</span> <span class="nf">Trunc</span> (<span class="nv">n</span> : trunc_index) (<span class="nv">A</span> :<span class="kt">Type</span>) : <span class="kt">Type</span> :=
  tr : A -&gt; Trunc n A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Bind Scope</span> trunc_scope <span class="kr">with</span> Trunc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> tr {n A} a.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Without explicit universe parameters, this instance is insufficiently polymorphic. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka73" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka73"><span class="kn">Global Instance</span> <span class="nf">istrunc_truncation</span> (<span class="nv">n</span> : trunc_index) (<span class="nv">A</span> : <span class="kt">Type</span>@{i})
: IsTrunc@{j} n (Trunc@{i} n A).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (Trunc n A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trunc_ind</span> {<span class="nv">n</span> <span class="nv">A</span>}
  (<span class="nv">P</span> : Trunc n A -&gt; <span class="kt">Type</span>) {<span class="nv">Pt</span> : <span class="kr">forall</span> <span class="nv">aa</span>, IsTrunc n (P aa)}
  : (<span class="kr">forall</span> <span class="nv">a</span>, P (tr a)) -&gt; (<span class="kr">forall</span> <span class="nv">aa</span>, P aa)
:= (<span class="kr">fun</span> <span class="nv">f</span> <span class="nv">aa</span> =&gt; <span class="kr">match</span> aa <span class="kr">with</span> tr a =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; f a <span class="kr">end</span> Pt).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Trunc</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The non-dependent version of the eliminator. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trunc_rec</span> {<span class="nv">n</span> <span class="nv">A</span> <span class="nv">X</span>} `{IsTrunc n X}
  : (A -&gt; X) -&gt; (Trunc n A -&gt; X)
:= Trunc_ind (<span class="kr">fun</span> <span class="nv">_</span> =&gt; X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trunc_rec_tr</span> <span class="nv">n</span> {<span class="nv">A</span> : <span class="kt">Type</span>}
  : Trunc_rec (A:=A) (tr (n:=n)) == idmap
  := Trunc_ind _ (<span class="kr">fun</span> <span class="nv">a</span> =&gt; idpath).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** [Trunc] is a modality *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka74" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka74"><span class="kn">Definition</span> <span class="nf">Tr</span> (<span class="nv">n</span> : trunc_index) : Modality.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Modality</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka75" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka75"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Modality</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka76" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka76">srapply (Build_Modality (<span class="kr">fun</span> <span class="nv">A</span> =&gt; IsTrunc n A)); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
IsTrunc n T -&gt;
<span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; IsTrunc n U</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chka77" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><label class="goal-separator" for="core-v-chka77"><hr></label><div class="goal-conclusion"><span class="kt">Type</span> -&gt; <span class="kt">Type</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chka78" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><label class="goal-separator" for="core-v-chka78"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsTrunc n (<span class="nl">?Goal0</span> T)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chka79" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><label class="goal-separator" for="core-v-chka79"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, T -&gt; <span class="nl">?Goal0</span> T</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chka7a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><label class="goal-separator" for="core-v-chka7a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : <span class="nl">?Goal0</span> A -&gt; <span class="kt">Type</span>),
(<span class="kr">forall</span> <span class="nv">oa</span> : <span class="nl">?Goal0</span> A, IsTrunc n (B oa)) -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, B (<span class="nl">?Goal2</span> A a)) -&gt;
<span class="kr">forall</span> <span class="nv">z</span> : <span class="nl">?Goal0</span> A, B z</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chka7b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><label class="goal-separator" for="core-v-chka7b"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : <span class="nl">?Goal0</span> A -&gt; <span class="kt">Type</span>)
(<span class="nv">B_inO</span> : <span class="kr">forall</span> <span class="nv">oa</span> : <span class="nl">?Goal0</span> A, IsTrunc n (B oa))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, B (<span class="nl">?Goal2</span> A a)) (<span class="nv">a</span> : A),
<span class="nl">?Goal3</span> A B B_inO f (<span class="nl">?Goal2</span> A a) = f a</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chka7c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><label class="goal-separator" for="core-v-chka7c"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsTrunc n A -&gt; <span class="kr">forall</span> <span class="nv">z</span> <span class="nv">z&#39;</span> : A, IsTrunc n (z = z&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka7d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka7d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> <span class="nv">U</span> : <span class="kt">Type</span>,
IsTrunc n T -&gt;
<span class="kr">forall</span> <span class="nv">f</span> : T -&gt; U, IsEquiv f -&gt; IsTrunc n U</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> A B ? f ?; rapply (istrunc_isequiv_istrunc A f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka7e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka7e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">Type</span> -&gt; <span class="kt">Type</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Trunc n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka7f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka7f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, IsTrunc n (Trunc n T)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="nb">apply</span> istrunc_truncation.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka80" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka80">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">T</span> : <span class="kt">Type</span>, T -&gt; Trunc n T</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> A; <span class="nb">apply</span> tr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka81" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka81">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : Trunc n A -&gt; <span class="kt">Type</span>),
(<span class="kr">forall</span> <span class="nv">oa</span> : Trunc n A, IsTrunc n (B oa)) -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : A, B ((<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; tr) A a)) -&gt;
<span class="kr">forall</span> <span class="nv">z</span> : Trunc n A, B z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka82" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka82"><span class="nb">intros</span> A B ? f oa; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>Trunc n A -&gt; <span class="kt">Type</span></span></span></span><br><span><var>B_inO</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">oa</span> : Trunc n A, IsTrunc n (B oa)</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, B (tr a)</span></span></span><br><span><var>oa</var><span class="hyp-type"><b>: </b><span>Trunc n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">B oa</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (Trunc_ind B f oa).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka83" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka83">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">B</span> : Trunc n A -&gt; <span class="kt">Type</span>)
(<span class="nv">B_inO</span> : <span class="kr">forall</span> <span class="nv">oa</span> : Trunc n A, IsTrunc n (B oa))
(<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, B ((<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; tr) A a))
(<span class="nv">a</span> : A),
(<span class="kr">fun</span> (<span class="nv">A0</span> : <span class="kt">Type</span>) (<span class="nv">B0</span> : Trunc n A0 -&gt; <span class="kt">Type</span>)
   (<span class="nv">B_inO0</span> : <span class="kr">forall</span> <span class="nv">oa</span> : Trunc n A0, IsTrunc n (B0 oa))
   (<span class="nv">f0</span> : <span class="kr">forall</span> <span class="nv">a0</span> : A0,
         B0 ((<span class="kr">fun</span> <span class="nv">A1</span> : <span class="kt">Type</span> =&gt; tr) A0 a0))
   (<span class="nv">oa</span> : Trunc n A0) =&gt; Trunc_ind B0 f0 oa : B0 oa) A
  B B_inO f ((<span class="kr">fun</span> <span class="nv">A0</span> : <span class="kt">Type</span> =&gt; tr) A a) = f a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka84" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka84">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsTrunc n A -&gt; <span class="kr">forall</span> <span class="nv">z</span> <span class="nv">z&#39;</span> : A, IsTrunc n (z = z&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (@istrunc_paths&#39; n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We don&#39;t usually declare modalities as coercions, but this particular one is convenient so that lemmas about (for instance) connected maps can be applied to truncation modalities without the user/reader needing to be (particularly) aware of the general notion of modality. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">Tr</span> : trunc_index &gt;-&gt; Modality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** However, if the coercion is not printed, then we get things like [Tr (-1) X] being printed as [(-1) X], which is terribly confusing.  So we tell Coq to always print this coercion.  This does mean that although the user can type things like [IsConnected n X], it will always be displayed back as [IsConnected (Tr n) X]. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Add Printing Coercion</span> Tr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">TruncationModality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> (<span class="nv">n</span> : trunc_index).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trunc_iff_isequiv_truncation</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
    : IsTrunc n A &lt;-&gt; IsEquiv (@tr n A)
    := inO_iff_isequiv_to_O (Tr n) A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">isequiv_tr</span> <span class="nv">A</span> `{IsTrunc n A} : IsEquiv (@tr n A)
    := fst (trunc_iff_isequiv_truncation A) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_tr</span> (<span class="nv">A</span> : <span class="kt">Type</span>) `{IsTrunc n A}
    : A &lt;~&gt; Tr n A
  := Build_Equiv _ _ (@tr n A) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">untrunc_istrunc</span> {<span class="nv">A</span> : <span class="kt">Type</span>} `{IsTrunc n A}
    : Tr n A -&gt; A
    := (@tr n A)^-<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Functoriality *)</span>

  <span class="sd">(** Since a modality lives on a single universe, by default if we simply define [Trunc_functor] to be [O_functor] then it would force [X] and [Y] to live in the same universe.  But since we defined [Trunc] as a cumulative inductive, if we add universe annotations we can make [Trunc_functor] more universe-polymorphic than [O_functor] is.  This is sometimes useful.  *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trunc_functor</span>@{i j k} {X : <span class="kt">Type</span>@{i}} {Y : <span class="kt">Type</span>@{j}} (f : X -&gt; Y)
    : Tr@{i} n X -&gt; Tr@{j} n Y
    := O_functor@{k k k} (Tr n) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">is0functor_Tr</span> : Is0Functor (Tr n)
    := Build_Is0Functor _ _ _ _ (Tr n) (@Trunc_functor).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">Trunc_functor_isequiv</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>}
    (<span class="nv">f</span> : X -&gt; Y) `{IsEquiv _ _ f}
    : IsEquiv (Trunc_functor f)
    := isequiv_O_functor (Tr n) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trunc_functor_equiv</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X &lt;~&gt; Y)
    : Tr n X &lt;~&gt; Tr n Y
    := equiv_O_functor (Tr n) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trunc_functor_compose</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} (<span class="nv">f</span> : X -&gt; Y) (<span class="nv">g</span> : Y -&gt; Z)
    : Trunc_functor (g o f) == Trunc_functor g o Trunc_functor f
    := O_functor_compose (Tr n) f g.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Trunc_functor_idmap</span> (<span class="nv">X</span> : <span class="kt">Type</span>)
    : @Trunc_functor X X idmap == idmap
    := O_functor_idmap (Tr n) X.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">isequiv_Trunc_functor</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">f</span> : X -&gt; Y) `{IsEquiv _ _ f}
    : IsEquiv (Trunc_functor f)
    := isequiv_O_functor (Tr n) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_Trunc_prod_cmp</span> {<span class="nv">X</span> <span class="nv">Y</span>}
    : Tr n (X * Y) &lt;~&gt; Tr n X * Tr n Y
    := equiv_O_prod_cmp (Tr n) X Y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka85" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka85"><span class="kn">Global Instance</span> <span class="nf">is1functor_Tr</span> : Is1Functor (Tr n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (Tr n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka86" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka86"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Is1Functor (Tr n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka87" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka87"><span class="nb">apply</span> Build_Is1Functor.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt; fmap (Tr n) f $== fmap (Tr n) g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chka88" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><label class="goal-separator" for="core-v-chka88"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, fmap (Tr n) (Id a) $== Id (Tr n a)</div></blockquote><input class="alectryon-extra-goal-toggle" id="core-v-chka89" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><label class="goal-separator" for="core-v-chka89"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap (Tr n) (g $o f) $==
fmap (Tr n) g $o fmap (Tr n) f</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka8a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka8a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : a $-&gt; b),
f $== g -&gt; fmap (Tr n) f $== fmap (Tr n) g</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> @O_functor_homotopy.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka8b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka8b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : <span class="kt">Type</span>, fmap (Tr n) (Id a) $== Id (Tr n a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> @Trunc_functor_idmap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka8c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka8c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : a $-&gt; b) (<span class="nv">g</span> : b $-&gt; c),
fmap (Tr n) (g $o f) $==
fmap (Tr n) g $o fmap (Tr n) f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> @Trunc_functor_compose.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">TruncationModality</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We have to teach Coq to translate back and forth between [IsTrunc n] and [In (Tr n)]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka8d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka8d"><span class="kn">Global Instance</span> <span class="nf">inO_tr_istrunc</span> {<span class="nv">n</span> : trunc_index} (<span class="nv">A</span> : <span class="kt">Type</span>) `{IsTrunc n A}
  : In (Tr n) A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Tr n) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka8e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka8e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsTrunc0</var><span class="hyp-type"><b>: </b><span>IsTrunc n A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In (Tr n) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Having both of these as [Instance]s would cause infinite loops. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka8f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka8f"><span class="kn">Definition</span> <span class="nf">istrunc_inO_tr</span> {<span class="nv">n</span> : trunc_index} (<span class="nv">A</span> : <span class="kt">Type</span>) `{In (Tr n) A}
  : IsTrunc n A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (Tr n) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka90" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka90"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In (Tr n) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Instead, we make the latter an immediate instance, but with high cost (i.e. low priority) so that it doesn&#39;t override the ordinary lemmas about truncation.  Unfortunately, [Hint Immediate] doesn&#39;t allow specifying a cost, so we use [Hint Extern] instead. *)</span>
<span class="sd">(** Hint Immediate istrunc_inO_tr : typeclass_instances. *)</span>
<span class="sd">(** See https://github.com/coq/coq/issues/11697 *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Extern</span> <span class="mi">1000</span> (IsTrunc _ _) =&gt; <span class="nb">simple apply</span> istrunc_inO_tr; <span class="kp">solve</span> [ <span class="nb">trivial</span> ] : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** This doesn&#39;t seem to be quite the same as [Hint Immediate] with a different cost either, though.  *)</span>

<span class="sd">(** Unfortunately, this isn&#39;t perfect; Coq still can&#39;t always find [In n] hypotheses in the context when it wants [IsTrunc].  You can always apply [istrunc_inO_tr] explicitly, but sometimes it also works to just [pose] it into the context. *)</span>

<span class="sd">(** We do the same for [IsTruncMap n] and [MapIn (Tr n)]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka91" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka91"><span class="kn">Global Instance</span> <span class="nf">mapinO_tr_istruncmap</span> {<span class="nv">n</span> : trunc_index} {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>}
  (<span class="nv">f</span> : A -&gt; B) `{IsTruncMap n A B f}
  : MapIn (Tr n) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap n f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka92" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka92"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>IsTruncMap n f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MapIn (Tr n) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka93" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka93"><span class="kn">Definition</span> <span class="nf">istruncmap_mapinO_tr</span> {<span class="nv">n</span> : trunc_index} {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>}
  (<span class="nv">f</span> : A -&gt; B) `{MapIn (Tr n) _ _ f}
  : IsTruncMap n f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka94" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka94"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>MapIn (Tr n) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTruncMap n f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export]
<span class="kn">Hint Immediate</span> istruncmap_mapinO_tr : typeclass_instances.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** A few special things about the (-1)-truncation *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> trunc_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We define [merely A] to be an inhabitant of the universe [hProp] of hprops, rather than a type.  We can always treat it as a type because there is a coercion, but this means that if we need an element of [hProp] then we don&#39;t need a separate name for it. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">merely</span> (<span class="nv">A</span> : <span class="kt">Type</span>@{i}) : HProp@{i} := Build_HProp (Tr (-<span class="mi">1</span>) A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">hexists</span> {<span class="nv">X</span>} (<span class="nv">P</span> : X -&gt; <span class="kt">Type</span>) : HProp := merely (sig P).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">hor</span> (<span class="nv">P</span> <span class="nv">Q</span> : <span class="kt">Type</span>) : HProp := merely (P + Q).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> hprop_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;A \/ B&quot;</span> := (hor A B) : hprop_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">himage</span> {<span class="nv">X</span> <span class="nv">Y</span>} (<span class="nv">f</span> : X -&gt; Y) := image (Tr (-<span class="mi">1</span>)) f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka95" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka95"><span class="kn">Definition</span> <span class="nf">contr_inhab_prop</span> {<span class="nv">A</span>} `{IsHProp A} (ma : merely A) : Contr A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br><span><var>ma</var><span class="hyp-type"><b>: </b><span>merely A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka96" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka96"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br><span><var>ma</var><span class="hyp-type"><b>: </b><span>merely A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka97" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka97"><span class="nb">refine</span> (@contr_trunc_conn (Tr (-<span class="mi">1</span>)) A _ _); <span class="kp">try</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHProp0</var><span class="hyp-type"><b>: </b><span>IsHProp A</span></span></span><br><span><var>ma</var><span class="hyp-type"><b>: </b><span>merely A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>)) A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">refine</span> (contr_inhabited_hprop _ ma).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A stable type is logically equivalent to its (-1)-truncation. (It follows that this is true for decidable types as well.) *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka98" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka98"><span class="kn">Definition</span> <span class="nf">merely_inhabited_iff_inhabited_stable</span> {<span class="nv">A</span>} {<span class="nv">A_stable</span> : Stable A}
  : Tr (-<span class="mi">1</span>) A &lt;-&gt; A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_stable</var><span class="hyp-type"><b>: </b><span>Stable A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) A &lt;-&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka99" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka99"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_stable</var><span class="hyp-type"><b>: </b><span>Stable A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) A &lt;-&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka9a" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka9a"><span class="nb">refine</span> (_, tr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_stable</var><span class="hyp-type"><b>: </b><span>Stable A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) A -&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka9b" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka9b"><span class="nb">intro</span> ma.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_stable</var><span class="hyp-type"><b>: </b><span>Stable A</span></span></span><br><span><var>ma</var><span class="hyp-type"><b>: </b><span>Tr (-<span class="mi">1</span>) A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka9c" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka9c"><span class="nb">apply</span> stable; <span class="nb">intro</span> na.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>A_stable</var><span class="hyp-type"><b>: </b><span>Stable A</span></span></span><br><span><var>ma</var><span class="hyp-type"><b>: </b><span>Tr (-<span class="mi">1</span>) A</span></span></span><br><span><var>na</var><span class="hyp-type"><b>: </b><span>~ A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">revert</span> ma; rapply Trunc_ind; <span class="bp">exact</span> na.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Surjections are the (-1)-connected maps, but they can be characterized more simply since an inhabited hprop is automatically contractible. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="nf">IsSurjection</span> := (IsConnMap (Tr (-<span class="mi">1</span>))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka9d" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka9d"><span class="kn">Definition</span> <span class="nf">BuildIsSurjection</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B)
  : (<span class="kr">forall</span> <span class="nv">b</span>, merely (hfiber f b)) -&gt; IsSurjection f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">b</span> : B, merely (hfiber f b)) -&gt;
IsConnMap (Tr (-<span class="mi">1</span>)) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka9e" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka9e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">b</span> : B, merely (hfiber f b)) -&gt;
IsConnMap (Tr (-<span class="mi">1</span>)) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chka9f" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chka9f"><span class="nb">intros</span> H b; <span class="nb">refine</span> (contr_inhabited_hprop _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : B, merely (hfiber f b)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber f b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** A family of types is pointwise merely inhabited if and only if the corresponding fibration is surjective. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaa0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaa0"><span class="kn">Lemma</span> <span class="nf">iff_merely_issurjection</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : X -&gt; <span class="kt">Type</span>)
  : (<span class="kr">forall</span> <span class="nv">x</span>, merely (P x)) &lt;-&gt; IsSurjection (pr1 : {x : X &amp; P x} -&gt; X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)) &lt;-&gt;
IsConnMap (Tr (-<span class="mi">1</span>)) (pr1 : {x : X &amp; P x} -&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaa1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaa1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)) &lt;-&gt;
IsConnMap (Tr (-<span class="mi">1</span>)) (pr1 : {x : X &amp; P x} -&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaa2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaa2"><span class="nb">refine</span> (iff_compose _ (iff_forall_inO_mapinO_pr1 (Conn _) P)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)) &lt;-&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : X, In (Conn (Tr (-<span class="mi">1</span>))) (P a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaa3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaa3"><span class="nb">apply</span> iff_functor_forall; <span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">merely (P a) &lt;-&gt; In (Conn (Tr (-<span class="mi">1</span>))) (P a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">symmetry</span>; <span class="nb">apply</span> (iff_contr_hprop (Tr (-<span class="mi">1</span>) (P a))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaa4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaa4"><span class="kn">Lemma</span> <span class="nf">equiv_merely_issurjection</span> `{Funext} {X : <span class="kt">Type</span>} (P : X -&gt; <span class="kt">Type</span>)
  : (<span class="kr">forall</span> <span class="nv">x</span>, merely (P x)) &lt;~&gt; IsSurjection (pr1 : {x : X &amp; P x} -&gt; X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)) &lt;~&gt;
IsConnMap (Tr (-<span class="mi">1</span>)) (pr1 : {x : X &amp; P x} -&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaa5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaa5"><span class="kn">Proof</span>. <span class="c">(* Can also be proved from equiv_forall_inO_mapinO_pr1. *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>X -&gt; <span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">x</span> : X, merely (P x)) &lt;~&gt;
IsConnMap (Tr (-<span class="mi">1</span>)) (pr1 : {x : X &amp; P x} -&gt; X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_iff_hprop_uncurried (iff_merely_issurjection P)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Surjections cancel on the right *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaa6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaa6"><span class="kn">Lemma</span> <span class="nf">cancelR_issurjection</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; C)
      (<span class="nv">isconn</span> : IsSurjection (g o f))
  : IsSurjection g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaa7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaa7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaa8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaa8"><span class="nb">intro</span> c.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>)) (hfiber g c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaa9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaa9">rapply contr_inhabited_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber g c)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaaa" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaaa">rapply (Trunc_functor _ (X:= (hfiber (g o f) c))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) c -&gt; hfiber g c</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkaab" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><label class="goal-separator" for="core-v-chkaab"><hr></label><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) c)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaac" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaac">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) c -&gt; hfiber g c</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaad" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaad"><span class="nb">intros</span> [a p].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>g (f a) = c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">hfiber g c</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (f a; p).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaae" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaae">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>B -&gt; C</span></span></span><br><span><var>isconn</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) (g o f)</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x)) c)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> center, isconn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Retractions are surjective. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaaf" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaaf"><span class="kn">Definition</span> <span class="nf">issurj_retr</span> {<span class="nv">X</span> <span class="nv">Y</span> : <span class="kt">Type</span>} {<span class="nv">r</span> : X -&gt; Y} (<span class="nv">s</span> : Y -&gt; X) (<span class="nv">h</span> : <span class="kr">forall</span> <span class="nv">y</span>:Y, r (s y) = y)
  : IsSurjection r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, r (s y) = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkab0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkab0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, r (s y) = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr (-<span class="mi">1</span>)) r</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkab1" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkab1"><span class="nb">intro</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, r (s y) = y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnected (Tr (-<span class="mi">1</span>)) (hfiber r y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkab2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkab2">rapply contr_inhabited_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>X -&gt; Y</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : Y, r (s y) = y</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (-<span class="mi">1</span>) (hfiber r y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (tr (s y; h y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Since embeddings are the (-1)-truncated maps, a map that is both a surjection and an embedding is an equivalence. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkab3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkab3"><span class="kn">Definition</span> <span class="nf">isequiv_surj_emb</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B)
  `{IsSurjection f} `{IsEmbedding f}
  : IsEquiv f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkab4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkab4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; B</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (@isequiv_conn_ino_map (Tr (-<span class="mi">1</span>))); <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If [X] is a set and [f : Y -&gt; Z] is a surjection, then [- o f] is an embedding. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkab5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkab5"><span class="kn">Definition</span> <span class="nf">isembedding_precompose_surjection_hset</span> `{Funext} {X Y Z : <span class="kt">Type</span>}
  `{IsHSet X} (f : Y -&gt; Z) `{IsSurjection f}
  : IsEmbedding (<span class="kr">fun</span> <span class="nv">phi</span> : Z -&gt; X =&gt; phi o f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding (<span class="kr">fun</span> <span class="nv">phi</span> : Z -&gt; X =&gt; phi o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkab6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkab6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEmbedding (<span class="kr">fun</span> <span class="nv">phi</span> : Z -&gt; X =&gt; phi o f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkab7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkab7"><span class="nb">intros</span> phi; <span class="nb">apply</span> istrunc_S.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
(<span class="nv">x</span> : hfiber (<span class="kr">fun</span> (<span class="nv">phi</span> : Z -&gt; X) (<span class="nv">x</span> : Y) =&gt; phi (f x))
       phi)
(<span class="nv">y</span> : hfiber
       (<span class="kr">fun</span> (<span class="nv">phi</span> : Z -&gt; X) (<span class="nv">x0</span> : Y) =&gt; phi (f x0)) phi),
Contr (x = y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkab8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkab8"><span class="nb">intros</span> g0 g1; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g0, g1</var><span class="hyp-type"><b>: </b><span>hfiber (<span class="kr">fun</span> (<span class="nv">phi</span> : Z -&gt; X) (<span class="nv">x</span> : Y) =&gt; phi (f x))
  phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Contr (g0 = g1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkab9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkab9">rapply contr_inhabited_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g0, g1</var><span class="hyp-type"><b>: </b><span>hfiber (<span class="kr">fun</span> (<span class="nv">phi</span> : Z -&gt; X) (<span class="nv">x</span> : Y) =&gt; phi (f x))
  phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g0 = g1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaba" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaba"><span class="nb">apply</span> path_sigma_hprop, equiv_path_arrow.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g0, g1</var><span class="hyp-type"><b>: </b><span>hfiber (<span class="kr">fun</span> (<span class="nv">phi</span> : Z -&gt; X) (<span class="nv">x</span> : Y) =&gt; phi (f x))
  phi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g0.<span class="mi">1</span> == g1.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkabb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkabb">rapply conn_map_elim; <span class="nb">intro</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>IsHSet0</var><span class="hyp-type"><b>: </b><span>IsHSet X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y -&gt; Z</span></span></span><br><span><var>IsSurjection0</var><span class="hyp-type"><b>: </b><span>IsConnMap (Tr (-<span class="mi">1</span>)) f</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>Y -&gt; X</span></span></span><br><span><var>g0, g1</var><span class="hyp-type"><b>: </b><span>hfiber (<span class="kr">fun</span> (<span class="nv">phi</span> : Z -&gt; X) (<span class="nv">x</span> : Y) =&gt; phi (f x))
  phi</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g0.<span class="mi">1</span> (f y) = g1.<span class="mi">1</span> (f y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (ap10 (g0.<span class="mi">2</span> @ g1.<span class="mi">2</span>^) y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Tactic to remove truncations in hypotheses if possible</span>

<span class="sd">  See [strip_reflections] and [strip_modalities] for generalizations to other reflective subuniverses and modalities. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">strip_truncations</span> :=
  <span class="sd">(** search for truncated hypotheses *)</span>
  <span class="kp">progress</span> <span class="kp">repeat</span>
    <span class="kr">match goal with</span>
    | [ T : _ |- _ ]
      =&gt; revert_opaque T;
        <span class="nb">refine</span> (@Trunc_ind _ _ _ _ _);
        <span class="sd">(** ensure that we didn&#39;t generate more than one subgoal, i.e. that the goal was appropriately truncated *)</span>
        [];
        <span class="nb">intro</span> T
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="sd">(** We would like to define this in terms of the [strip_modalities] tactic, however [O_ind] uses more universes than [Trunc_ind] which causes some problems down the line. *)</span>
<span class="c">(* Ltac strip_truncations := strip_modalities. *)</span>

<span class="sd">(** ** Iterated truncations *)</span>

<span class="sd">(** Compare to [O_leq_Tr] and [O_strong_leq_Tr] in SeparatedTrunc.v. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkabc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkabc"><span class="kn">Definition</span> <span class="nf">O_leq_Tr_leq</span> {<span class="nv">n</span> <span class="nv">m</span> : trunc_index} (<span class="nv">Hmn</span> : m &lt;= n)
  : O_leq (Tr m) (Tr n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>Hmn</var><span class="hyp-type"><b>: </b><span>m &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_leq (Tr m) (Tr n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkabd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkabd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>Hmn</var><span class="hyp-type"><b>: </b><span>m &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_leq (Tr m) (Tr n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> A; rapply istrunc_leq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkabe" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkabe"><span class="kn">Definition</span> <span class="nf">Trunc_min</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">X</span> : Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkabf" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkabf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkac0" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkac0"><span class="nb">destruct</span> (trunc_index_min_path n m) <span class="kr">as</span> [p|q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>trunc_index_min n m = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="core-v-chkac1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>trunc_index_min n m = m</span></span></span><br></div><label class="goal-separator" for="core-v-chkac1"><hr></label><div class="goal-conclusion">Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkac2" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkac2">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>trunc_index_min n m = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkac3" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkac3"><span class="nb">assert</span> (l := trunc_index_min_leq_right n m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>trunc_index_min n m = n</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>trunc_index_min n m &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkac4" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkac4"><span class="nb">destruct</span> p^; <span class="nb">clear</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr n X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkac5" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkac5">snrapply (Build_Equiv _ _ (Trunc_functor _ tr)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (Trunc_functor n tr)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkac6" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkac6">nrapply O_inverts_conn_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsConnMap (Tr n) tr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkac7" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkac7">rapply (conn_map_O_leq _ (Tr m)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">O_leq (Tr n) (Tr m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">rapply O_leq_Tr_leq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkac8" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkac8">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>trunc_index_min n m = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkac9" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkac9"><span class="nb">assert</span> (l := trunc_index_min_leq_left n m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>trunc_index_min n m = m</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>trunc_index_min n m &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr (trunc_index_min n m) X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkaca" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkaca"><span class="nb">destruct</span> q^; <span class="nb">clear</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>m &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr m X &lt;~&gt; Tr n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkacb" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkacb">srapply equiv_tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>m &lt;= n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTrunc n (Tr m X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">srapply istrunc_leq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkacc" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkacc"><span class="kn">Definition</span> <span class="nf">Trunc_swap</span> <span class="nv">n</span> <span class="nv">m</span> <span class="nv">X</span> : Tr n (Tr m X) &lt;~&gt; Tr m (Tr n X).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr n (Tr m X) &lt;~&gt; Tr m (Tr n X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkacd" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkacd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Tr n (Tr m X) &lt;~&gt; Tr m (Tr n X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="core-v-chkace" style="display: none" type="checkbox"><label class="alectryon-input" for="core-v-chkace"><span class="nb">refine</span> (Trunc_min m n _ oE equiv_transport (<span class="kr">fun</span> <span class="nv">k</span> =&gt; Tr k _) _ oE (Trunc_min n m _)^-<span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>trunc_index</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trunc_index_min n m = trunc_index_min m n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> trunc_index_min_swap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If you are looking for a theorem about truncation, you may want to read the note &quot;Finding Theorems&quot; in &quot;STYLE.md&quot;. *)</span></span></pre>
</div>
</div></body>
</html>
