<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Colimit.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk0"><span class="kn">Require Import</span> Basics Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Diagrams.Diagram.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Diagrams.Graph.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Diagrams.Cocone.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Diagrams.ConstantDiagram.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Colimits.Coeq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> path_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Generalizable All Variables</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** This file contains the definition of colimits, and functoriality results on colimits. *)</span>

<span class="sd">(** * Colimits *)</span>

<span class="sd">(** A colimit is the extremity of a cocone. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">IsColimit</span> `(D: Diagram G) (Q: <span class="kt">Type</span>) := {
  iscolimit_cocone : Cocone D Q;
  iscolimit_unicocone : UniversalCocone iscolimit_cocone;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Use :&gt; and remove the two following lines,</span>
<span class="c">   once Coq 8.16 is the minimum required version. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Existing Instance</span> <span class="nf">iscolimit_cocone</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">iscolimit_cocone</span> : IsColimit &gt;-&gt; Cocone.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Build_IsColimit {G D Q} C H : <span class="nb">rename</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> iscolimit_cocone {G D Q} C : <span class="nb">rename</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> iscolimit_unicocone {G D Q} H : <span class="nb">rename</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [cocone_postcompose_inv] is defined for convenience: it is only the inverse of [cocone_postcompose]. It allows to recover the map [h] from a cocone [C&#39;]. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cocone_postcompose_inv</span> `{D: Diagram G} {Q X}
  (H : IsColimit D Q) (C&#39; : Cocone D X) : Q -&gt; X
  := @equiv_inv _ _ _ (iscolimit_unicocone H X) C&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Existence of colimits *)</span>

<span class="sd">(** Whatever the diagram considered, there exists a colimit of it. The existence is given by the HIT [colimit]. *)</span>

<span class="sd">(** ** Definition of the HIT </span>
<span class="sd">&lt;&lt;</span>
<span class="sd">  HIT Colimit {G : Graph} (D : Diagram G) : Type :=</span>
<span class="sd">  | colim : forall i, D i -&gt; Colimit D</span>
<span class="sd">  | colimp : forall i j (f : G i j) (x : D i) : colim j (D _f f x) = colim i x</span>
<span class="sd">  .</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">*)</span>

<span class="sd">(** A colimit is just the coequalizer of the source and target maps of the diagram. *)</span>
<span class="sd">(** The source type in the coequalizer ought to be:</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">{x : sig D &amp; {y : sig D &amp; {f : G x.1 y.1 &amp; D _f f x.2 = y.2}}}</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">However we notice that the path type forms a contractible component, so we can use the more efficient:</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">{x : sig D &amp; {j : G &amp; G x.1 j}}</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">*)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Colimit</span> {<span class="nv">G</span> : Graph} (<span class="nv">D</span> : Diagram G) : <span class="kt">Type</span> :=
  @Coeq
    {x : sig D &amp; {j : G &amp; G x.<span class="mi">1</span> j}}
    (sig D)
    (<span class="kr">fun</span> <span class="nv">t</span> =&gt; t.<span class="mi">1</span>)
    (<span class="kr">fun</span> <span class="nv">t</span> =&gt; (t.<span class="mi">2</span>.<span class="mi">1</span>; D _f t.<span class="mi">2</span>.<span class="mi">2</span> t.<span class="mi">1</span>.<span class="mi">2</span>))
  .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">colim</span> {<span class="nv">G</span> : Graph} {<span class="nv">D</span> : Diagram G} (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i) : Colimit D :=
  coeq (i ; x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">colimp</span> {<span class="nv">G</span> : Graph} {<span class="nv">D</span> : Diagram G} (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">f</span> : G i j) (<span class="nv">x</span> : D i)
  : colim j (D _f f x) = colim i x
  := (cglue ((i; x); j; f))^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk1"><span class="kn">Definition</span> <span class="nf">Colimit_ind</span> {<span class="nv">G</span> : Graph} {<span class="nv">D</span> : Diagram G} (<span class="nv">P</span> : Colimit D -&gt; <span class="kt">Type</span>)
(<span class="nv">q</span> : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">x</span>, P (colim i x))
(<span class="nv">pp_q</span> : <span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span>: G i j) (<span class="nv">x</span> : D i),
  (@colimp G D i j g x) # (q j (D _f g x)) = q i x)
: <span class="kr">forall</span> <span class="nv">w</span>, P w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">w</span> : Colimit D, P w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">w</span> : Colimit D, P w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk3">srapply Coeq_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : {x : _ &amp; D x}, P (coeq a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk4"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : {x : {x : _ &amp; D x} &amp; {j : G &amp; G x.<span class="mi">1</span> j}},
transport P (cglue b)
  (<span class="nl">?coeq&#39;</span>
     ((<span class="kr">fun</span> <span class="nv">t</span> : {x : {x : _ &amp; D x} &amp; {j : G &amp; G x.<span class="mi">1</span> j}}
       =&gt; t.<span class="mi">1</span>) b)) =
<span class="nl">?coeq&#39;</span>
  ((<span class="kr">fun</span> <span class="nv">t</span> : {x : {x : _ &amp; D x} &amp; {j : G &amp; G x.<span class="mi">1</span> j}} =&gt;
    ((t.<span class="mi">2</span>).<span class="mi">1</span>; (D _f (t.<span class="mi">2</span>).<span class="mi">2</span>) (t.<span class="mi">1</span>).<span class="mi">2</span>)) b)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : {x : _ &amp; D x}, P (coeq a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk6"><span class="nb">intros</span> [x i].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>D x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (coeq (x; i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (q x i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : {x : {x : _ &amp; D x} &amp; {j : G &amp; G x.<span class="mi">1</span> j}},
transport P (cglue b)
  ((<span class="kr">fun</span> <span class="nv">a</span> : {x : _ &amp; D x} =&gt;
    (<span class="kr">fun</span> (<span class="nv">x</span> : G) (<span class="nv">i</span> : D x) =&gt; q x i) a.<span class="mi">1</span> a.<span class="mi">2</span>)
     ((<span class="kr">fun</span> <span class="nv">t</span> : {x : {x : _ &amp; D x} &amp; {j : G &amp; G x.<span class="mi">1</span> j}}
       =&gt; t.<span class="mi">1</span>) b)) =
(<span class="kr">fun</span> <span class="nv">a</span> : {x : _ &amp; D x} =&gt;
 (<span class="kr">fun</span> (<span class="nv">x</span> : G) (<span class="nv">i</span> : D x) =&gt; q x i) a.<span class="mi">1</span> a.<span class="mi">2</span>)
  ((<span class="kr">fun</span> <span class="nv">t</span> : {x : {x : _ &amp; D x} &amp; {j : G &amp; G x.<span class="mi">1</span> j}} =&gt;
    ((t.<span class="mi">2</span>).<span class="mi">1</span>; (D _f (t.<span class="mi">2</span>).<span class="mi">2</span>) (t.<span class="mi">1</span>).<span class="mi">2</span>)) b)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk8"><span class="nb">intros</span> [[i x] [j f]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G (i; x).<span class="mi">1</span> j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (cglue ((i; x); j; f))
  (q (((i; x); j; f).<span class="mi">1</span>).<span class="mi">1</span> (((i; x); j; f).<span class="mi">1</span>).<span class="mi">2</span>) =
q (((i; x); j; f).<span class="mi">2</span>).<span class="mi">1</span>
  ((D _f (((i; x); j; f).<span class="mi">2</span>).<span class="mi">2</span>) (((i; x); j; f).<span class="mi">1</span>).<span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk9"><span class="nb">cbn</span> <span class="kr">in</span> f; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (cglue ((i; x); j; f)) (q i x) =
q j ((D _f f) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chka"><span class="nb">apply</span> moveR_transport_p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q i x =
transport P (cglue ((i; x); j; f))^ (q j ((D _f f) x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chkb"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport P (cglue ((i; x); j; f))^ (q j ((D _f f) x)) =
q i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (pp_q _ _ _ _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chkc"><span class="kn">Definition</span> <span class="nf">Colimit_ind_beta_colimp</span> {<span class="nv">G</span> : Graph} {<span class="nv">D</span> : Diagram G}
  (<span class="nv">P</span> : Colimit D -&gt; <span class="kt">Type</span>) (<span class="nv">q</span> : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">x</span>, P (colim i x))
  (<span class="nv">pp_q</span> : <span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span>: G) (<span class="nv">g</span>: G i j) (<span class="nv">x</span>: D i),
    @colimp G D i j g x # q _ (D _f g x) = q _ x)
  (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i)
  : apD (Colimit_ind P q pp_q) (colimp i j g x) = pp_q i j g x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Colimit_ind P q pp_q) (colimp i j g x) =
pp_q i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Colimit_ind P q pp_q) (colimp i j g x) =
pp_q i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chke"><span class="nb">refine</span> (apD_V _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">moveR_transport_V P (cglue ((i; x); j; g))
  (Colimit_ind P q pp_q (colim j ((D _f g) x)))
  (Colimit_ind P q pp_q (colim i x))
  (apD (Colimit_ind P q pp_q) (cglue ((i; x); j; g)))^ =
pp_q i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chkf"><span class="nb">apply</span> moveR_equiv_M.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(apD (Colimit_ind P q pp_q) (cglue ((i; x); j; g)))^ =
(moveR_transport_V P (cglue ((i; x); j; g))
   (Colimit_ind P q pp_q (colim j ((D _f g) x)))
   (Colimit_ind P q pp_q (colim i x)))^-<span class="mi">1</span>
  (pp_q i j g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk10"><span class="nb">apply</span> moveR_equiv_M.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD (Colimit_ind P q pp_q) (cglue ((i; x); j; g)) =
inverse^-<span class="mi">1</span>
  ((moveR_transport_V P (cglue ((i; x); j; g))
      (Colimit_ind P q pp_q (colim j ((D _f g) x)))
      (Colimit_ind P q pp_q (colim i x)))^-<span class="mi">1</span>
     (pp_q i j g x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk11"><span class="nb">refine</span> (Coeq_ind_beta_cglue _ _ _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">moveR_transport_p P (cglue ((i; x); j; g)) (q i x)
  (q j ((D _f g) x)) (pp_q i j g x)^ =
inverse^-<span class="mi">1</span>
  ((moveR_transport_V P (cglue ((i; x); j; g))
      (Colimit_ind P q pp_q (colim j ((D _f g) x)))
      (Colimit_ind P q pp_q (colim i x)))^-<span class="mi">1</span>
     (pp_q i j g x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk12"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; <span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i), P (colim i x)</span></span></span><br><span><var>pp_q</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
transport P (colimp i j g x) (q j ((D _f g) x)) =
q i x</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">inverse^-<span class="mi">1</span>
  ((moveR_transport_V P (cglue ((i; x); j; g))
      (Colimit_ind P q pp_q (colim j ((D _f g) x)))
      (Colimit_ind P q pp_q (colim i x)))^-<span class="mi">1</span>
     (pp_q i j g x)) =
moveR_transport_p P (cglue ((i; x); j; g)) (q i x)
  (q j ((D _f g) x)) (pp_q i j g x)^</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> moveL_transport_p_V.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk13"><span class="kn">Definition</span> <span class="nf">Colimit_rec</span> {<span class="nv">G</span> : Graph} {<span class="nv">D</span> : Diagram G} (<span class="nv">P</span> : <span class="kt">Type</span>) (<span class="nv">C</span> : Cocone D P)
  : Colimit D -&gt; P.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit D -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit D -&gt; P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk15">srapply (Colimit_ind _ C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i),
transport (<span class="kr">fun</span> <span class="nv">_</span> : Colimit D =&gt; P) (colimp i j g x)
  (C j ((D _f g) x)) = C i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk16"><span class="nb">intros</span> i j g x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">_</span> : Colimit D =&gt; P) (colimp i j g x)
  (C j ((D _f g) x)) = C i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk17"><span class="nb">refine</span> (transport_const _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">C j ((D _f g) x) = C i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> legs_comm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk18"><span class="kn">Definition</span> <span class="nf">Colimit_rec_beta_colimp</span> {<span class="nv">G</span> : Graph} {<span class="nv">D</span> : Diagram G}
  (<span class="nv">P</span> : <span class="kt">Type</span>) (<span class="nv">C</span> : Cocone D P) (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span>: G i j) (<span class="nv">x</span>: D i)
  : ap (Colimit_rec P C) (colimp i j g x) = legs_comm C i j g x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Colimit_rec P C) (colimp i j g x) =
legs_comm C i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Colimit_rec P C) (colimp i j g x) =
legs_comm C i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk1a">rapply (cancelL (transport_const (colimp i j g x) _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport_const (colimp i j g x)
  (Colimit_rec P C (colim j ((D _f g) x))) @
ap (Colimit_rec P C) (colimp i j g x) =
transport_const (colimp i j g x)
  (Colimit_rec P C (colim j ((D _f g) x))) @
legs_comm C i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk1b">srapply ((apD_const (Colimit_ind (<span class="kr">fun</span> <span class="nv">_</span> =&gt; P) C _) (colimp i j g x))^ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apD
  (Colimit_ind (<span class="kr">fun</span> <span class="nv">_</span> : Colimit D =&gt; P) C
     (<span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
      transport_const (colimp i j g x)
        (C j ((D _f g) x)) @ legs_comm C i j g x))
  (colimp i j g x) =
transport_const (colimp i j g x)
  (Colimit_rec P C (colim j ((D _f g) x))) @
legs_comm C i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply (Colimit_ind_beta_colimp (<span class="kr">fun</span> <span class="nv">_</span> =&gt; P) C _ i j g x).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> colim : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> colimp : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Colimit_rec is an equivalence *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk1c"><span class="kn">Global Instance</span> <span class="nf">isequiv_colimit_rec</span> `{Funext} {G : Graph}
  {D : Diagram G} (P : <span class="kt">Type</span>) : IsEquiv (Colimit_rec (D:=D) P).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (Colimit_rec P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk1d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (Colimit_rec P)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk1e">srapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Colimit D -&gt; P) -&gt; Cocone D P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk1f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="colimit-v-chk1f"><hr></label><div class="goal-conclusion">Colimit_rec P o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="colimit-v-chk20" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="colimit-v-chk20"><hr></label><div class="goal-conclusion"><span class="nl">?g</span> o Colimit_rec P == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk21">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Colimit D -&gt; P) -&gt; Cocone D P</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk22"><span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Cocone D P</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk23">srapply Build_Cocone.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G, D i -&gt; P</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk24"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
<span class="nl">?legs</span> j o D _f g == <span class="nl">?legs</span> i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk25"><span class="mi">1</span>: <span class="nb">intros</span> i g; <span class="nb">apply</span> f, (colim i g).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g0</span> : D i0) =&gt; f (colim i0 g0)) j
o D _f g ==
(<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g0</span> : D i0) =&gt; f (colim i0 g0)) i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk26"><span class="nb">intros</span> i j g x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (colim j ((D _f g) x)) = f (colim i x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ap, colimp.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk27">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit_rec P
o (<span class="kr">fun</span> <span class="nv">f</span> : Colimit D -&gt; P =&gt;
   {|
     legs := <span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">g</span> : D i) =&gt; f (colim i g);
     legs_comm :=
       <span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) =&gt;
       (<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; ap f (colimp i j g x))
       :
       (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g0</span> : D i0) =&gt; f (colim i0 g0)) j
       o D _f g ==
       (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g0</span> : D i0) =&gt; f (colim i0 g0)) i
   |}) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="colimit-v-chk28"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : Colimit D -&gt; P =&gt;
 {|
   legs := <span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">g</span> : D i) =&gt; f (colim i g);
   legs_comm :=
     <span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) =&gt;
     (<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; ap f (colimp i j g x))
     :
     (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g0</span> : D i0) =&gt; f (colim i0 g0)) j
     o D _f g ==
     (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g0</span> : D i0) =&gt; f (colim i0 g0)) i
 |}) o Colimit_rec P == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk29">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit_rec P
o (<span class="kr">fun</span> <span class="nv">f</span> : Colimit D -&gt; P =&gt;
   {|
     legs := <span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">g</span> : D i) =&gt; f (colim i g);
     legs_comm :=
       <span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) =&gt;
       (<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; ap f (colimp i j g x))
       :
       (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g0</span> : D i0) =&gt; f (colim i0 g0)) j
       o D _f g ==
       (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g0</span> : D i0) =&gt; f (colim i0 g0)) i
   |}) == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk2a"><span class="nb">intro</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit_rec P
  {|
    legs := <span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">g</span> : D i) =&gt; x (colim i g);
    legs_comm :=
      <span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x0</span> : D i) =&gt;
      ap x (colimp i j g x0)
  |} = x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk2b"><span class="nb">apply</span> path_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit_rec P
  {|
    legs := <span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">g</span> : D i) =&gt; x (colim i g);
    legs_comm :=
      <span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x0</span> : D i) =&gt;
      ap x (colimp i j g x0)
  |} == x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk2c">srapply Colimit_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x0</span> : D i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
 Colimit_rec P
   {|
     legs := <span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g</span> : D i0) =&gt; x (colim i0 g);
     legs_comm :=
       <span class="kr">fun</span> (<span class="nv">i0</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i0 j) (<span class="nv">x1</span> : D i0) =&gt;
       ap x (colimp i0 j g x1)
   |} w = x w) (colim i x0)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk2d"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x0</span> : D i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
   Colimit_rec P
     {|
       legs :=
         <span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g0</span> : D i0) =&gt; x (colim i0 g0);
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">i0</span> <span class="nv">j0</span> : G) (<span class="nv">g0</span> : G i0 j0) (<span class="nv">x1</span> : D i0) =&gt;
         ap x (colimp i0 j0 g0 x1)
     |} w = x w) (colimp i j g x0)
  (<span class="nl">?q</span> j ((D _f g) x0)) = <span class="nl">?q</span> i x0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk2e"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x0</span> : D i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
   Colimit_rec P
     {|
       legs :=
         <span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g0</span> : D i0) =&gt; x (colim i0 g0);
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">i0</span> <span class="nv">j0</span> : G) (<span class="nv">g0</span> : G i0 j0) (<span class="nv">x1</span> : D i0) =&gt;
         ap x (colimp i0 j0 g0 x1)
     |} w = x w) (colimp i j g x0)
  ((<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x1</span> : D i0) =&gt; <span class="mi">1</span>) j ((D _f g) x0)) =
(<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x1</span> : D i0) =&gt; <span class="mi">1</span>) i x0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk2f"><span class="nb">intros</span> ????; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
   Colimit_rec P
     {|
       legs := <span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">g</span> : D i) =&gt; x (colim i g);
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x0</span> : D i) =&gt;
         ap x (colimp i j g x0)
     |} w = x w) (colimp i j g x0) <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk30">nrapply transport_paths_FlFr&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (Colimit_rec P
     {|
       legs := <span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">g</span> : D i) =&gt; x (colim i g);
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x0</span> : D i) =&gt;
         ap x (colimp i j g x0)
     |}) (colimp i j g x0) @ <span class="mi">1</span> =
<span class="mi">1</span> @ ap x (colimp i j g x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk31"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; P</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (Colimit_rec P
     {|
       legs := <span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">g</span> : D i) =&gt; x (colim i g);
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x0</span> : D i) =&gt;
         ap x (colimp i j g x0)
     |}) (colimp i j g x0) = ap x (colimp i j g x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Colimit_rec_beta_colimp.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk32">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : Colimit D -&gt; P =&gt;
 {|
   legs := <span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">g</span> : D i) =&gt; f (colim i g);
   legs_comm :=
     <span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) =&gt;
     (<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; ap f (colimp i j g x))
     :
     (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g0</span> : D i0) =&gt; f (colim i0 g0)) j
     o D _f g ==
     (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g0</span> : D i0) =&gt; f (colim i0 g0)) i
 |}) o Colimit_rec P == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk33">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">f</span> : Colimit D -&gt; P =&gt;
 {|
   legs := <span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">g</span> : D i) =&gt; f (colim i g);
   legs_comm :=
     <span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) =&gt;
     (<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; ap f (colimp i j g x))
     :
     (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g0</span> : D i0) =&gt; f (colim i0 g0)) j
     o D _f g ==
     (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g0</span> : D i0) =&gt; f (colim i0 g0)) i
 |}) o Colimit_rec P == idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk34"><span class="nb">intros</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>legs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, D i -&gt; P</span></span></span><br><span><var>legs_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; legs j ((D _f g) x)) ==
legs i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  legs :=
    <span class="kr">fun</span> (<span class="nv">i</span> : G) (<span class="nv">g</span> : D i) =&gt;
    Colimit_rec P
      {| legs := legs; legs_comm := legs_comm |}
      (colim i g);
  legs_comm :=
    <span class="kr">fun</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i) =&gt;
    ap
      (Colimit_rec P
         {| legs := legs; legs_comm := legs_comm |})
      (colimp i j g x)
|} = {| legs := legs; legs_comm := legs_comm |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk35">srapply path_cocone.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>legs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, D i -&gt; P</span></span></span><br><span><var>legs_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; legs j ((D _f g) x)) ==
legs i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G,
{|
  legs :=
    <span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g</span> : D i0) =&gt;
    Colimit_rec P
      {| legs := legs; legs_comm := legs_comm |}
      (colim i0 g);
  legs_comm :=
    <span class="kr">fun</span> (<span class="nv">i0</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i0 j) (<span class="nv">x</span> : D i0) =&gt;
    ap
      (Colimit_rec P
         {| legs := legs; legs_comm := legs_comm |})
      (colimp i0 j g x)
|} i == {| legs := legs; legs_comm := legs_comm |} i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk36" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>legs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, D i -&gt; P</span></span></span><br><span><var>legs_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; legs j ((D _f g) x)) ==
legs i</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk36"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) 
(<span class="nv">x</span> : D i),
Cocone.legs_comm
  {|
    legs :=
      <span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g0</span> : D i0) =&gt;
      Colimit_rec P
        {| legs := legs; legs_comm := legs_comm |}
        (colim i0 g0);
    legs_comm :=
      <span class="kr">fun</span> (<span class="nv">i0</span> <span class="nv">j0</span> : G) (<span class="nv">g0</span> : G i0 j0) (<span class="nv">x0</span> : D i0) =&gt;
      ap
        (Colimit_rec P
           {| legs := legs; legs_comm := legs_comm |})
        (colimp i0 j0 g0 x0)
  |} i j g x @ <span class="nl">?path_legs</span> i x =
<span class="nl">?path_legs</span> j ((D _f g) x) @
Cocone.legs_comm
  {| legs := legs; legs_comm := legs_comm |} i j g x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk37"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>legs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, D i -&gt; P</span></span></span><br><span><var>legs_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; legs j ((D _f g) x)) ==
legs i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i),
Cocone.legs_comm
  {|
    legs :=
      <span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">g0</span> : D i0) =&gt;
      Colimit_rec P
        {| legs := legs; legs_comm := legs_comm |}
        (colim i0 g0);
    legs_comm :=
      <span class="kr">fun</span> (<span class="nv">i0</span> <span class="nv">j0</span> : G) (<span class="nv">g0</span> : G i0 j0) (<span class="nv">x0</span> : D i0) =&gt;
      ap
        (Colimit_rec P
           {| legs := legs; legs_comm := legs_comm |})
        (colimp i0 j0 g0 x0)
  |} i j g x @ (<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0) =&gt; <span class="mi">1</span>) i x =
(<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0) =&gt; <span class="mi">1</span>) j ((D _f g) x) @
Cocone.legs_comm
  {| legs := legs; legs_comm := legs_comm |} i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk38"><span class="nb">intros</span> ????; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>legs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, D i -&gt; P</span></span></span><br><span><var>legs_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; legs j ((D _f g) x)) ==
legs i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (Colimit_rec P
     {| legs := legs; legs_comm := legs_comm |})
  (colimp i j g x) @ <span class="mi">1</span> = <span class="mi">1</span> @ legs_comm i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk39"><span class="nb">rewrite</span> Colimit_rec_beta_colimp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>legs</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> : G, D i -&gt; P</span></span></span><br><span><var>legs_comm</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j),
(<span class="kr">fun</span> <span class="nv">x</span> : D i =&gt; legs j ((D _f g) x)) ==
legs i</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Cocone.legs_comm
  {| legs := legs; legs_comm := legs_comm |} i j g x @
<span class="mi">1</span> = <span class="mi">1</span> @ legs_comm i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input">hott_simpl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">}</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_colimit_rec</span> `{Funext} {G : Graph} {D : Diagram G} (P : <span class="kt">Type</span>)
  : Cocone D P &lt;~&gt; (Colimit D -&gt; P) := Build_Equiv _ _ _ (isequiv_colimit_rec P).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** And we can now show that the HIT is actually a colimit. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cocone_colimit</span> {<span class="nv">G</span> : Graph} (<span class="nv">D</span> : Diagram G) : Cocone D (Colimit D)
  := Build_Cocone colim colimp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk3a"><span class="kn">Global Instance</span> <span class="nf">unicocone_colimit</span> `{Funext} {G : Graph} (D : Diagram G)
  : UniversalCocone (cocone_colimit D).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">UniversalCocone (cocone_colimit D)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk3b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">UniversalCocone (cocone_colimit D)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk3c">srapply Build_UniversalCocone; <span class="nb">intro</span> Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (cocone_postcompose (cocone_colimit D))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk3d">srapply (isequiv_adjointify _ (Colimit_rec Y) _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose (cocone_colimit D) o Colimit_rec Y ==
idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><label class="goal-separator" for="colimit-v-chk3e"><hr></label><div class="goal-conclusion">Colimit_rec Y o cocone_postcompose (cocone_colimit D) ==
idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk3f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose (cocone_colimit D) o Colimit_rec Y ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk40"><span class="nb">intros</span> C.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose (cocone_colimit D)
  (Colimit_rec Y C) = C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk41">srapply path_cocone.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : G,
cocone_postcompose (cocone_colimit D)
  (Colimit_rec Y C) i == C i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk42" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D Y</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk42"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i),
legs_comm
  (cocone_postcompose (cocone_colimit D)
     (Colimit_rec Y C)) i j g x @ <span class="nl">?path_legs</span> i x =
<span class="nl">?path_legs</span> j ((D _f g) x) @ legs_comm C i j g x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk43"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i),
legs_comm
  (cocone_postcompose (cocone_colimit D)
     (Colimit_rec Y C)) i j g x @
(<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0) =&gt; <span class="mi">1</span>) i x =
(<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0) =&gt; <span class="mi">1</span>) j ((D _f g) x) @
legs_comm C i j g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk44"><span class="nb">intros</span> i j f x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D Y</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Colimit_rec Y C) (colimp i j f x) @ <span class="mi">1</span> =
<span class="mi">1</span> @ legs_comm C i j f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk45"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>Cocone D Y</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (Colimit_rec Y C) (colimp i j f x) =
legs_comm C i j f x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Colimit_rec_beta_colimp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk46">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit_rec Y o cocone_postcompose (cocone_colimit D) ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk47"><span class="nb">intro</span> f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit_rec Y
  (cocone_postcompose (cocone_colimit D) f) = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk48"><span class="nb">apply</span> path_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Colimit_rec Y
  (cocone_postcompose (cocone_colimit D) f) == f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk49">srapply Colimit_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : G) (<span class="nv">x</span> : D i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
 Colimit_rec Y
   (cocone_postcompose (cocone_colimit D) f) w = f w)
  (colim i x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk4a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; Y</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk4a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
   Colimit_rec Y
     (cocone_postcompose (cocone_colimit D) f) w = 
   f w) (colimp i j g x) (<span class="nl">?q</span> j ((D _f g) x)) = <span class="nl">?q</span> i x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk4b"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : G) (<span class="nv">g</span> : G i j) (<span class="nv">x</span> : D i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
   Colimit_rec Y
     (cocone_postcompose (cocone_colimit D) f) w = 
   f w) (colimp i j g x)
  ((<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0) =&gt; <span class="mi">1</span>) j ((D _f g) x)) =
(<span class="kr">fun</span> (<span class="nv">i0</span> : G) (<span class="nv">x0</span> : D i0) =&gt; <span class="mi">1</span>) i x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk4c"><span class="nb">intros</span> i j g x; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; Y</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit D =&gt;
   Colimit_rec Y
     (cocone_postcompose (cocone_colimit D) f) w = 
   f w) (colimp i j g x) <span class="mi">1</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk4d">nrapply (transport_paths_FlFr&#39; (g:=f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; Y</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (Colimit_rec Y
     (cocone_postcompose (cocone_colimit D) f))
  (colimp i j g x) @ <span class="mi">1</span> = <span class="mi">1</span> @ ap f (colimp i j g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk4e"><span class="nb">apply</span> equiv_p1_1q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Colimit D -&gt; Y</span></span></span><br><span><var>i, j</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G i j</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>D i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (Colimit_rec Y
     (cocone_postcompose (cocone_colimit D) f))
  (colimp i j g x) = ap f (colimp i j g x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Colimit_rec_beta_colimp.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">iscolimit_colimit</span> `{Funext} {G : Graph} (D : Diagram G)
  : IsColimit D (Colimit D) := Build_IsColimit _ (unicocone_colimit D).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Functoriality of colimits *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">FunctorialityColimit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{Funext} {G : Graph}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** Colimits are preserved by composition with a (diagram) equivalence. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk4f"><span class="kn">Definition</span> <span class="nf">iscolimit_precompose_equiv</span> {<span class="nv">D1</span> <span class="nv">D2</span> : Diagram G}
    (<span class="nv">m</span> : D1 ~d~ D2) {<span class="nv">Q</span> : <span class="kt">Type</span>}
    : IsColimit D2 Q -&gt; IsColimit D1 Q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsColimit D2 Q -&gt; IsColimit D1 Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk50"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsColimit D2 Q -&gt; IsColimit D1 Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk51"><span class="nb">intros</span> HQ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsColimit D1 Q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk52">srapply (Build_IsColimit (cocone_precompose m HQ) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">UniversalCocone (cocone_precompose m HQ)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> cocone_precompose_equiv_universality, HQ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk53"><span class="kn">Definition</span> <span class="nf">iscolimit_postcompose_equiv</span> {<span class="nv">D</span>: Diagram G} `(f: Q &lt;~&gt; Q&#39;)
    : IsColimit D Q -&gt; IsColimit D Q&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Q, Q'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Q &lt;~&gt; Q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsColimit D Q -&gt; IsColimit D Q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk54"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Q, Q'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Q &lt;~&gt; Q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsColimit D Q -&gt; IsColimit D Q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk55"><span class="nb">intros</span> HQ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Q, Q'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Q &lt;~&gt; Q&#39;</span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>IsColimit D Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsColimit D Q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk56">srapply (Build_IsColimit (cocone_postcompose HQ f) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Q, Q'</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Q &lt;~&gt; Q&#39;</span></span></span><br><span><var>HQ</var><span class="hyp-type"><b>: </b><span>IsColimit D Q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">UniversalCocone (cocone_postcompose HQ f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> cocone_postcompose_equiv_universality, HQ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A diagram map [m] : [D1] =&gt; [D2] induces a map between any two colimits of [D1] and [D2]. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_colimit</span> {<span class="nv">D1</span> <span class="nv">D2</span> : Diagram G} (<span class="nv">m</span> : DiagramMap D1 D2)
    {<span class="nv">Q1</span> <span class="nv">Q2</span>} (<span class="nv">HQ1</span> : IsColimit D1 Q1) (<span class="nv">HQ2</span> : IsColimit D2 Q2)
    : Q1 -&gt; Q2 := cocone_postcompose_inv HQ1 (cocone_precompose m HQ2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** And this map commutes with diagram map. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">functor_colimit_commute</span> {<span class="nv">D1</span> <span class="nv">D2</span> : Diagram G}
    (<span class="nv">m</span> : DiagramMap D1 D2) {<span class="nv">Q1</span> <span class="nv">Q2</span>}
    (<span class="nv">HQ1</span> : IsColimit D1 Q1) (<span class="nv">HQ2</span>: IsColimit D2 Q2)
    : cocone_precompose m HQ2
      = cocone_postcompose HQ1 (functor_colimit m HQ1 HQ2)
    := (eisretr (cocone_postcompose HQ1) _)^.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** ** Colimits of equivalent diagrams *)</span>

  <span class="sd">(** Now we have than two equivalent diagrams have equivalent colimits. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> {<span class="nv">D1</span> <span class="nv">D2</span> : Diagram G} (<span class="nv">m</span> : D1 ~d~ D2) {<span class="nv">Q1</span> <span class="nv">Q2</span>}
    (<span class="nv">HQ1</span> : IsColimit D1 Q1) (<span class="nv">HQ2</span> : IsColimit D2 Q2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk57"><span class="kn">Definition</span> <span class="nf">functor_colimit_eissect</span>
    : functor_colimit m HQ1 HQ2
      o functor_colimit (diagram_equiv_inv m) HQ2 HQ1 == idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_colimit m HQ1 HQ2
o functor_colimit (diagram_equiv_inv m) HQ2 HQ1 ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk58"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_colimit m HQ1 HQ2
o functor_colimit (diagram_equiv_inv m) HQ2 HQ1 ==
idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk59"><span class="nb">apply</span> ap10.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Q2 =&gt;
 functor_colimit m HQ1 HQ2
   (functor_colimit (diagram_equiv_inv m) HQ2 HQ1 x)) =
idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk5a">srapply (equiv_inj (cocone_postcompose HQ2) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (cocone_postcompose HQ2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk5b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk5b"><hr></label><div class="goal-conclusion">cocone_postcompose HQ2
  (<span class="kr">fun</span> <span class="nv">x</span> : Q2 =&gt;
   functor_colimit m HQ1 HQ2
     (functor_colimit (diagram_equiv_inv m) HQ2 HQ1 x)) =
cocone_postcompose HQ2 idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk5c"><span class="mi">1</span>: <span class="nb">apply</span> HQ2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ2
  (<span class="kr">fun</span> <span class="nv">x</span> : Q2 =&gt;
   functor_colimit m HQ1 HQ2
     (functor_colimit (diagram_equiv_inv m) HQ2 HQ1 x)) =
cocone_postcompose HQ2 idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk5d"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ2
  (<span class="kr">fun</span> <span class="nv">x</span> : Q2 =&gt;
   functor_colimit m HQ1 HQ2
     (functor_colimit (diagram_equiv_inv m) HQ2 HQ1 x)) =
<span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk5e"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> = cocone_postcompose HQ2 idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk5f"><span class="mi">2</span>:<span class="nb">symmetry</span>; <span class="nb">apply</span> cocone_postcompose_identity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ2
  (<span class="kr">fun</span> <span class="nv">x</span> : Q2 =&gt;
   functor_colimit m HQ1 HQ2
     (functor_colimit (diagram_equiv_inv m) HQ2 HQ1 x)) =
HQ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk60"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ2
  (<span class="kr">fun</span> <span class="nv">x</span> : Q2 =&gt;
   functor_colimit m HQ1 HQ2
     (functor_colimit (diagram_equiv_inv m) HQ2 HQ1 x)) =
<span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk61" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk61"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> = HQ2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk62"><span class="mi">1</span>: <span class="nb">apply</span> cocone_postcompose_comp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose
  (cocone_postcompose HQ2
     (functor_colimit (diagram_equiv_inv m) HQ2 HQ1))
  (functor_colimit m HQ1 HQ2) = HQ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk63"><span class="nb">rewrite</span> eisretr, cocone_precompose_postcompose, eisretr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_precompose (diagram_equiv_inv m)
  (cocone_precompose m HQ2) = HQ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk64"><span class="nb">rewrite</span> cocone_precompose_comp, diagram_inv_is_section.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_precompose (diagram_idmap D2) HQ2 = HQ2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> cocone_precompose_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk65"><span class="kn">Definition</span> <span class="nf">functor_colimit_eisretr</span>
    : functor_colimit (diagram_equiv_inv m) HQ2 HQ1
      o functor_colimit m HQ1 HQ2 == idmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_colimit (diagram_equiv_inv m) HQ2 HQ1
o functor_colimit m HQ1 HQ2 == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk66"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">functor_colimit (diagram_equiv_inv m) HQ2 HQ1
o functor_colimit m HQ1 HQ2 == idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk67"><span class="nb">apply</span> ap10.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">x</span> : Q1 =&gt;
 functor_colimit (diagram_equiv_inv m) HQ2 HQ1
   (functor_colimit m HQ1 HQ2 x)) = idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk68">srapply (equiv_inj (cocone_postcompose HQ1) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv (cocone_postcompose HQ1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk69" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk69"><hr></label><div class="goal-conclusion">cocone_postcompose HQ1
  (<span class="kr">fun</span> <span class="nv">x</span> : Q1 =&gt;
   functor_colimit (diagram_equiv_inv m) HQ2 HQ1
     (functor_colimit m HQ1 HQ2 x)) =
cocone_postcompose HQ1 idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk6a"><span class="mi">1</span>: <span class="nb">apply</span> HQ1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ1
  (<span class="kr">fun</span> <span class="nv">x</span> : Q1 =&gt;
   functor_colimit (diagram_equiv_inv m) HQ2 HQ1
     (functor_colimit m HQ1 HQ2 x)) =
cocone_postcompose HQ1 idmap</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk6b"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ1
  (<span class="kr">fun</span> <span class="nv">x</span> : Q1 =&gt;
   functor_colimit (diagram_equiv_inv m) HQ2 HQ1
     (functor_colimit m HQ1 HQ2 x)) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk6c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk6c"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> = cocone_postcompose HQ1 idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk6d"><span class="mi">2</span>:<span class="nb">symmetry</span>; <span class="nb">apply</span> cocone_postcompose_identity.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ1
  (<span class="kr">fun</span> <span class="nv">x</span> : Q1 =&gt;
   functor_colimit (diagram_equiv_inv m) HQ2 HQ1
     (functor_colimit m HQ1 HQ2 x)) = HQ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk6e"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose HQ1
  (<span class="kr">fun</span> <span class="nv">x</span> : Q1 =&gt;
   functor_colimit (diagram_equiv_inv m) HQ2 HQ1
     (functor_colimit m HQ1 HQ2 x)) = <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="colimit-v-chk6f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><label class="goal-separator" for="colimit-v-chk6f"><hr></label><div class="goal-conclusion"><span class="nl">?Goal</span> = HQ1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk70"><span class="mi">1</span>: <span class="nb">apply</span> cocone_postcompose_comp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_postcompose
  (cocone_postcompose HQ1 (functor_colimit m HQ1 HQ2))
  (functor_colimit (diagram_equiv_inv m) HQ2 HQ1) =
HQ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk71"><span class="nb">rewrite</span> eisretr, cocone_precompose_postcompose, eisretr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_precompose m
  (cocone_precompose (diagram_equiv_inv m) HQ1) = HQ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk72"><span class="nb">rewrite</span> cocone_precompose_comp, diagram_inv_is_retraction.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D1, D2</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>D1 ~d~ D2</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D1 Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D2 Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">cocone_precompose (diagram_idmap D1) HQ1 = HQ1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> cocone_precompose_identity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">isequiv_functor_colimit</span>
    : IsEquiv (functor_colimit m HQ1 HQ2)
    := isequiv_adjointify _ _
      functor_colimit_eissect functor_colimit_eisretr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_functor_colimit</span> : Q1 &lt;~&gt; Q2
    := Build_Equiv _ _ _ isequiv_functor_colimit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">FunctorialityColimit</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Unicity of colimits *)</span>

<span class="sd">(** A particuliar case of the functoriality result is that all colimits of a diagram are equivalent (and hence equal in presence of univalence). *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk73"><span class="kn">Theorem</span> <span class="nf">colimit_unicity</span> `{Funext} {G : Graph} {D : Diagram G} {Q1 Q2 : <span class="kt">Type</span>}
  (HQ1 : IsColimit D Q1) (HQ2 : IsColimit D Q2)
  : Q1 &lt;~&gt; Q2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q1 &lt;~&gt; Q2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk74"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q1 &lt;~&gt; Q2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk75">srapply equiv_functor_colimit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>Q1, Q2</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>HQ1</var><span class="hyp-type"><b>: </b><span>IsColimit D Q1</span></span></span><br><span><var>HQ2</var><span class="hyp-type"><b>: </b><span>IsColimit D Q2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">D ~d~ D</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">srapply (Build_diagram_equiv (diagram_idmap D)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Colimits are left adjoint to constant diagram *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk76"><span class="kn">Theorem</span> <span class="nf">colimit_adjoint</span> `{Funext} {G : Graph} {D : Diagram G} {C : <span class="kt">Type</span>}
  : (Colimit D -&gt; C) &lt;~&gt; DiagramMap D (diagram_const C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Colimit D -&gt; C) &lt;~&gt; DiagramMap D (diagram_const C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk77"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Colimit D -&gt; C) &lt;~&gt; DiagramMap D (diagram_const C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk78"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DiagramMap D (diagram_const C) &lt;~&gt; (Colimit D -&gt; C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="colimit-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="colimit-v-chk79"><span class="nb">refine</span> (equiv_colimit_rec C oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>Graph</span></span></span><br><span><var>D</var><span class="hyp-type"><b>: </b><span>Diagram G</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DiagramMap D (diagram_const C) &lt;~&gt; Cocone D C</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> equiv_diagram_const_cocone.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
