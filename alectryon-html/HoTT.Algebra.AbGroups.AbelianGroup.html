<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>AbelianGroup.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.19.0+0.19.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk0"><span class="kn">Require Import</span> Basics Types.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file number_string_notation_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Spaces.Nat.Core Spaces.Int.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Classes.interfaces.canonical_names (Zero, zero, Plus).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Classes.interfaces.abstract_algebra (IsAbGroup(..), abgroup_group, abgroup_commutative).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Algebra.Groups.Group.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Export</span> Algebra.Groups.Subgroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Algebra.Groups.QuotientGroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> WildCat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Set Polymorphic Inductive Cumulativity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> mc_add_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** * Abelian groups *)</span>

<span class="sd">(** Definition of an abelian group *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">AbGroup</span> := {
  abgroup_group : Group;
  abgroup_commutative : Commutative (@group_sgop abgroup_group);
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">abgroup_group</span> : AbGroup &gt;-&gt; Group.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Existing Instance</span> <span class="nf">abgroup_commutative</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk1"><span class="kn">Global Instance</span> <span class="nf">isabgroup_abgroup</span> {<span class="nv">A</span> : AbGroup} : IsAbGroup A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbGroup A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbGroup A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="bp">exact</span> _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">issig_abgroup</span> : _ &lt;~&gt; AbGroup := <span class="kp">ltac</span>:(issig).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">zero_abgroup</span> (<span class="nv">A</span> : AbGroup) : Zero A := group_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">plus_abgroup</span> (<span class="nv">A</span> : AbGroup) : Plus A := group_sgop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">negate_abgroup</span> (<span class="nv">A</span> : AbGroup) : Negate A := group_inverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ab_comm</span> {<span class="nv">A</span> : AbGroup} (<span class="nv">x</span> <span class="nv">y</span> : A) : x + y = y + x
  := commutativity x y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk3"><span class="kn">Definition</span> <span class="nf">ab_neg_op</span> {<span class="nv">A</span> : AbGroup} (<span class="nv">x</span> <span class="nv">y</span> : A) : - (x + y) = -x - y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- (x + y) = - x - y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- (x + y) = - x - y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk5">lhs nrapply grp_inv_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- y + - x = - x - y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ab_comm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Paths between abelian groups *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk6"><span class="kn">Definition</span> <span class="nf">equiv_path_abgroup</span> `{Univalence} {A B : AbGroup@{u}}
  : GroupIsomorphism A B &lt;~&gt; (A = B).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism A B &lt;~&gt; A = B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism A B &lt;~&gt; A = B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk8"><span class="nb">refine</span> (equiv_ap_inv issig_abgroup _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism A B &lt;~&gt;
issig_abgroup^-<span class="mi">1</span> A = issig_abgroup^-<span class="mi">1</span> B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk9"><span class="nb">refine</span> (equiv_path_sigma_hprop _ _ oE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism A B &lt;~&gt;
(issig_abgroup^-<span class="mi">1</span> A).<span class="mi">1</span> = (issig_abgroup^-<span class="mi">1</span> B).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> equiv_path_group.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">equiv_path_abgroup_group</span> `{Univalence} {A B : AbGroup}
  : (A = B :&gt; AbGroup) &lt;~&gt; (A = B :&gt; Group)
  := equiv_path_group oE equiv_path_abgroup^-<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Subgroups of abelian groups *)</span>

<span class="sd">(** Subgroups of abelian groups are abelian *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chka"><span class="kn">Global Instance</span> <span class="nf">isabgroup_subgroup</span> (<span class="nv">G</span> : AbGroup) (<span class="nv">H</span> : Subgroup G)
  : IsAbGroup H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbGroup H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbGroup H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chkc">nrapply Build_IsAbGroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsGroup H</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chkd"><hr></label><div class="goal-conclusion">Commutative sg_op</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chke"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Commutative sg_op</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chkf"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x + y = y + x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk10"><span class="nb">apply</span> path_sigma_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x + y).<span class="mi">1</span> = (y + x).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk11"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>H</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x.<span class="mi">1</span> + y.<span class="mi">1</span> = y.<span class="mi">1</span> + x.<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> commutativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Given any subgroup of an abelian group, we can coerce it to an abelian group. Note that Coq complains this coercion doesn&#39;t satisfy the uniform-inheritance condition, but in practice it works and doesn&#39;t cause any issue, so we ignore it. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abgroup_subgroup</span> (<span class="nv">G</span> : AbGroup) : Subgroup G -&gt; AbGroup
  := <span class="kr">fun</span> <span class="nv">H</span> =&gt; Build_AbGroup H _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[warnings=<span class="s2">&quot;-uniform-inheritance&quot;</span>]
<span class="kn">Coercion</span> <span class="nf">abgroup_subgroup</span> : Subgroup &gt;-&gt; AbGroup.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk12"><span class="kn">Global Instance</span> <span class="nf">isnormal_ab_subgroup</span> (<span class="nv">G</span> : AbGroup) (<span class="nv">H</span> : Subgroup G)
  : IsNormalSubgroup H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsNormalSubgroup H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk13"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsNormalSubgroup H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk14"><span class="nb">intros</span> x y h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>H (x + y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">H (y + x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> ab_comm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Quotients of abelian groups *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk15"><span class="kn">Global Instance</span> <span class="nf">isabgroup_quotient</span> (<span class="nv">G</span> : AbGroup) (<span class="nv">H</span> : Subgroup G)
  : IsAbGroup (QuotientGroup&#39; G H (isnormal_ab_subgroup G H)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbGroup
  (QuotientGroup&#39; G H (isnormal_ab_subgroup G H))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsAbGroup
  (QuotientGroup&#39; G H (isnormal_ab_subgroup G H))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk17">nrapply Build_IsAbGroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsGroup
  (QuotientGroup&#39; G H (isnormal_ab_subgroup G H))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk18" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk18"><hr></label><div class="goal-conclusion">Commutative sg_op</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk19"><span class="mi">1</span>: <span class="bp">exact</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Commutative sg_op</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk1a"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>QuotientGroup&#39; G H (isnormal_ab_subgroup G H)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">y</span> : QuotientGroup&#39; G H (isnormal_ab_subgroup G H),
x + y = y + x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk1b">srapply Quotient_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>QuotientGroup&#39; G H (isnormal_ab_subgroup G H)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : G,
(<span class="kr">fun</span>
   <span class="nv">q</span> : G /
       in_cosetL
         {|
           normalsubgroup_subgroup := H;
           normalsubgroup_isnormal :=
             isnormal_ab_subgroup G H
         |} =&gt; x + q = q + x)
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := H;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup G H
        |}) x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk1c"><span class="nb">intro</span> y; <span class="nb">revert</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span>
<span class="nv">x</span> : QuotientGroup&#39; G H (isnormal_ab_subgroup G H),
(<span class="kr">fun</span>
   <span class="nv">q</span> : G /
       in_cosetL
         {|
           normalsubgroup_subgroup := H;
           normalsubgroup_isnormal :=
             isnormal_ab_subgroup G H
         |} =&gt; x + q = q + x)
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := H;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup G H
        |}) y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk1d">srapply Quotient_ind_hprop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : G,
(<span class="kr">fun</span>
   <span class="nv">q</span> : G /
       in_cosetL
         {|
           normalsubgroup_subgroup := H;
           normalsubgroup_isnormal :=
             isnormal_ab_subgroup G H
         |} =&gt;
 (<span class="kr">fun</span>
    <span class="nv">q0</span> : G /
         in_cosetL
           {|
             normalsubgroup_subgroup := H;
             normalsubgroup_isnormal :=
               isnormal_ab_subgroup G H
           |} =&gt; q + q0 = q0 + q)
   (class_of
      (in_cosetL
         {|
           normalsubgroup_subgroup := H;
           normalsubgroup_isnormal :=
             isnormal_ab_subgroup G H
         |}) y))
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := H;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup G H
        |}) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk1e"><span class="nb">intro</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span>
   <span class="nv">q</span> : G /
       in_cosetL
         {|
           normalsubgroup_subgroup := H;
           normalsubgroup_isnormal :=
             isnormal_ab_subgroup G H
         |} =&gt;
 (<span class="kr">fun</span>
    <span class="nv">q0</span> : G /
         in_cosetL
           {|
             normalsubgroup_subgroup := H;
             normalsubgroup_isnormal :=
               isnormal_ab_subgroup G H
           |} =&gt; q + q0 = q0 + q)
   (class_of
      (in_cosetL
         {|
           normalsubgroup_subgroup := H;
           normalsubgroup_isnormal :=
             isnormal_ab_subgroup G H
         |}) y))
  (class_of
     (in_cosetL
        {|
          normalsubgroup_subgroup := H;
          normalsubgroup_isnormal :=
            isnormal_ab_subgroup G H
        |}) x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk1f"><span class="nb">apply</span> (ap (class_of _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x + y = y + x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> commutativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">QuotientAbGroup</span> (<span class="nv">G</span> : AbGroup) (<span class="nv">H</span> : Subgroup G) : AbGroup
  := (Build_AbGroup (QuotientGroup&#39; G H (isnormal_ab_subgroup G H)) _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> QuotientAbGroup G H : <span class="nb">simpl</span> never.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">quotient_abgroup_rec</span> {<span class="nv">G</span> : AbGroup}
  (<span class="nv">N</span> : Subgroup G) (<span class="nv">H</span> : AbGroup)
  (<span class="nv">f</span> : GroupHomomorphism G H) (<span class="nv">h</span> : <span class="kr">forall</span> <span class="nv">n</span> : G, N n -&gt; f n = mon_unit)
  : GroupHomomorphism (QuotientAbGroup G N) H
  := grp_quotient_rec G (Build_NormalSubgroup G N _) f h.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk20"><span class="kn">Theorem</span> <span class="nf">equiv_quotient_abgroup_ump</span> {<span class="nv">F</span> : Funext} {<span class="nv">G</span> : AbGroup}
  (<span class="nv">N</span> : Subgroup G) (<span class="nv">H</span> : Group)
  : {f : GroupHomomorphism G H &amp; <span class="kr">forall</span> (<span class="nv">n</span> : G), N n -&gt; f n = mon_unit}
    &lt;~&gt; (GroupHomomorphism (QuotientAbGroup G N) H).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : GroupHomomorphism G H &amp;
<span class="kr">forall</span> <span class="nv">n</span> : G, N n -&gt; f n = mon_unit} &lt;~&gt;
GroupHomomorphism (QuotientAbGroup G N) H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>F</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>G</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>N</var><span class="hyp-type"><b>: </b><span>Subgroup G</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{f : GroupHomomorphism G H &amp;
<span class="kr">forall</span> <span class="nv">n</span> : G, N n -&gt; f n = mon_unit} &lt;~&gt;
GroupHomomorphism (QuotientAbGroup G N) H</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (equiv_grp_quotient_ump (Build_NormalSubgroup G N _) _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** The wild category of abelian groups *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">isgraph_abgroup</span> : IsGraph AbGroup
  := isgraph_induced abgroup_group.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">is01cat_abgroup</span> : Is01Cat AbGroup
  := is01cat_induced abgroup_group.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">is01cat_grouphomomorphism</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} : Is01Cat (A $-&gt; B)
  := is01cat_induced (@grp_homo_map A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">is0gpd_grouphomomorphism</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} : Is0Gpd (A $-&gt; B)
  := is0gpd_induced (@grp_homo_map A B).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">is2graph_abgroup</span> : Is2Graph AbGroup
  := is2graph_induced abgroup_group.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** AbGroup forms a 1Cat *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">is1cat_abgroup</span> : Is1Cat AbGroup
  := is1cat_induced _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">hasmorext_abgroup</span> `{Funext} : HasMorExt AbGroup
  := hasmorext_induced _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">hasequivs_abgroup</span> : HasEquivs AbGroup
  := hasequivs_induced _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Zero object of AbGroup *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk22"><span class="kn">Definition</span> <span class="nf">abgroup_trivial</span> : AbGroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">AbGroup</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk23"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">AbGroup</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk24">rapply (Build_AbGroup grp_trivial).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Commutative group_sgop</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** AbGroup is a pointed category *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk25"><span class="kn">Global Instance</span> <span class="nf">ispointedcat_abgroup</span> : IsPointedCat AbGroup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPointedCat AbGroup</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk26"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsPointedCat AbGroup</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk27"><span class="nb">apply</span> Build_IsPointedCat <span class="kr">with</span> abgroup_trivial.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsInitial abgroup_trivial</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsTerminal abgroup_trivial</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">intro</span> A; <span class="nb">apply</span> ispointedcat_group.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Image of group homomorphisms between abelian groups *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">abgroup_image</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">f</span> : A $-&gt; B) : AbGroup
  := Build_AbGroup (grp_image f) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** First isomorphism theorem of abelian groups *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk28"><span class="kn">Definition</span> <span class="nf">abgroup_first_iso</span> `{Funext} {A B : AbGroup} (f : A $-&gt; B)
  : GroupIsomorphism (QuotientAbGroup A (grp_kernel f)) (abgroup_image f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (QuotientAbGroup A (grp_kernel f))
  (abgroup_image f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk29"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (QuotientAbGroup A (grp_kernel f))
  (abgroup_image f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk2a"><span class="nb">etransitivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (QuotientAbGroup A (grp_kernel f))
  <span class="nl">?Goal</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk2b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk2b"><hr></label><div class="goal-conclusion">GroupIsomorphism <span class="nl">?Goal</span> (abgroup_image f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk2c"><span class="mi">2</span>: rapply grp_first_iso.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Funext</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism (QuotientAbGroup A (grp_kernel f))
  (QuotientGroup A (grp_kernel f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_iso_quotient_normal.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Kernels of abelian groups *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ab_kernel</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">f</span> : A $-&gt; B) : AbGroup
  := Build_AbGroup (grp_kernel f) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Transporting in families related to abelian groups *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk2d"><span class="kn">Lemma</span> <span class="nf">transport_abgrouphomomorphism_from_const</span> `{Univalence} {A B B&#39; : AbGroup}
      (p : B = B&#39;) (f : GroupHomomorphism A B)
  : transport (Hom A) p f
    = grp_homo_compose (equiv_path_abgroup^-<span class="mi">1</span> p) f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>B = B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Hom A) p f =
grp_homo_compose (equiv_path_abgroup^-<span class="mi">1</span> p) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk2e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>B = B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Hom A) p f =
grp_homo_compose (equiv_path_abgroup^-<span class="mi">1</span> p) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk2f"><span class="nb">induction</span> p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Hom A) <span class="mi">1</span> f =
grp_homo_compose (equiv_path_abgroup^-<span class="mi">1</span> <span class="mi">1</span>%path) f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> equiv_path_grouphomomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk30"><span class="kn">Lemma</span> <span class="nf">transport_iso_abgrouphomomorphism_from_const</span> `{Univalence} {A B B&#39; : AbGroup}
      (phi : GroupIsomorphism B B&#39;) (f : GroupHomomorphism A B)
  : transport (Hom A) (equiv_path_abgroup phi) f
    = grp_homo_compose phi f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism B B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Hom A) (equiv_path_abgroup phi) f =
grp_homo_compose phi f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk31"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism B B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (Hom A) (equiv_path_abgroup phi) f =
grp_homo_compose phi f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk32"><span class="nb">refine</span> (transport_abgrouphomomorphism_from_const _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B, B'</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism B B&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose
  (equiv_path_abgroup^-<span class="mi">1</span> (equiv_path_abgroup phi)) f =
grp_homo_compose phi f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk33"><span class="kn">Lemma</span> <span class="nf">transport_abgrouphomomorphism_to_const</span> `{Univalence} {A A&#39; B : AbGroup}
      (p : A = A&#39;) (f : GroupHomomorphism A B)
  : transport (<span class="kr">fun</span> <span class="nv">G</span> =&gt; Hom G B) p f
    = grp_homo_compose f (grp_iso_inverse (equiv_path_abgroup^-<span class="mi">1</span> p)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = A&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">G</span> : AbGroup =&gt; G $-&gt; B) p f =
grp_homo_compose f
  (grp_iso_inverse (equiv_path_abgroup^-<span class="mi">1</span> p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk34"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>A = A&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">G</span> : AbGroup =&gt; G $-&gt; B) p f =
grp_homo_compose f
  (grp_iso_inverse (equiv_path_abgroup^-<span class="mi">1</span> p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk35"><span class="nb">induction</span> p; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f =
grp_homo_compose f
  {|
    grp_homo_map := idmap;
    issemigrouppreserving_grp_homo :=
      abstract_algebra.invert_sg_morphism idmap
        abstract_algebra.id_sg_morphism
  |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> equiv_path_grouphomomorphism.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk36"><span class="kn">Lemma</span> <span class="nf">transport_iso_abgrouphomomorphism_to_const</span> `{Univalence} {A A&#39; B : AbGroup}
      (phi : GroupIsomorphism A A&#39;) (f : GroupHomomorphism A B)
  : transport (<span class="kr">fun</span> <span class="nv">G</span> =&gt; Hom G B) (equiv_path_abgroup phi) f
    = grp_homo_compose f (grp_iso_inverse phi).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism A A&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">G</span> : AbGroup =&gt; G $-&gt; B)
  (equiv_path_abgroup phi) f =
grp_homo_compose f (grp_iso_inverse phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk37"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism A A&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transport (<span class="kr">fun</span> <span class="nv">G</span> : AbGroup =&gt; G $-&gt; B)
  (equiv_path_abgroup phi) f =
grp_homo_compose f (grp_iso_inverse phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk38"><span class="nb">refine</span> (transport_abgrouphomomorphism_to_const _ _ @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Univalence</span></span></span><br><span><var>A, A', B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>phi</var><span class="hyp-type"><b>: </b><span>GroupIsomorphism A A&#39;</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>GroupHomomorphism A B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_homo_compose f
  (grp_iso_inverse
     (equiv_path_abgroup^-<span class="mi">1</span> (equiv_path_abgroup phi))) =
grp_homo_compose f (grp_iso_inverse phi)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> eissect.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Operations on abelian groups *)</span>

<span class="sd">(** The negation automorphism of an abelian group *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk39"><span class="kn">Definition</span> <span class="nf">ab_homo_negation</span> {<span class="nv">A</span> : AbGroup} : GroupIsomorphism A A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism A A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupIsomorphism A A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk3b">snrapply Build_GroupIsomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism A A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk3c"><hr></label><div class="goal-conclusion">IsEquiv <span class="nl">?grp_iso_homo</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk3d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism A A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk3e">snrapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk3f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk3f"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk40">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">a</span> =&gt; -a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk41">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk42"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- (x + y) = - x + - y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk43"><span class="nb">refine</span> (grp_inv_op x y @ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- y + - x = - x + - y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> commutativity.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk44">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsEquiv
  {|
    grp_homo_map := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a;
    issemigrouppreserving_grp_homo :=
      (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt;
       grp_inv_op x y @ commutativity (- y) (- x))
      :
      IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a)
  |}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk45">srapply isequiv_adjointify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk46" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk46"><hr></label><div class="goal-conclusion">{|
  grp_homo_map := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a;
  issemigrouppreserving_grp_homo :=
    (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt;
     grp_inv_op x y @ commutativity (- y) (- x))
    :
    IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a)
|} o <span class="nl">?g</span> == idmap</div></blockquote><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk47" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk47"><hr></label><div class="goal-conclusion"><span class="nl">?g</span>
o {|
    grp_homo_map := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a;
    issemigrouppreserving_grp_homo :=
      (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt;
       grp_inv_op x y @ commutativity (- y) (- x))
      :
      IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a)
  |} == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk48"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">a</span> =&gt; -a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  grp_homo_map := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a;
  issemigrouppreserving_grp_homo :=
    (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt;
     grp_inv_op x y @ commutativity (- y) (- x))
    :
    IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a)
|} o (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a) == idmap</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk49" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk49"><hr></label><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a)
o {|
    grp_homo_map := <span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a;
    issemigrouppreserving_grp_homo :=
      (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : A =&gt;
       grp_inv_op x y @ commutativity (- y) (- x))
      :
      IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; - a)
  |} == idmap</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="mi">1</span>-<span class="mi">2</span>: <span class="bp">exact</span> negate_involutive.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Multiplication by [n : Int] defines an endomorphism of any abelian group [A]. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk4a"><span class="kn">Definition</span> <span class="nf">ab_mul</span> {<span class="nv">A</span> : AbGroup} (<span class="nv">n</span> : Int) : GroupHomomorphism A A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism A A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk4b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">GroupHomomorphism A A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk4c">snrapply Build_GroupHomomorphism.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A -&gt; A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk4d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk4d"><hr></label><div class="goal-conclusion">IsSemiGroupPreserving <span class="nl">?grp_homo_map</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk4e"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">a</span> =&gt; grp_pow a n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSemiGroupPreserving (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; grp_pow a n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk4f"><span class="nb">intros</span> a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Int</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">grp_pow (a + b) n = grp_pow a n + grp_pow b n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_pow_mul, ab_comm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** [ab_mul n] is natural. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ab_mul_natural</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup}
  (<span class="nv">f</span> : GroupHomomorphism A B) (<span class="nv">n</span> : Int)
  : f o ab_mul n == ab_mul n o f
  := grp_pow_natural f n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The image of an inclusion is a normal subgroup. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ab_image_embedding</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">f</span> : A $-&gt; B) `{IsEmbedding f} : NormalSubgroup B
  := {| normalsubgroup_subgroup := grp_image_embedding f; normalsubgroup_isnormal := _ |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ab_image_in_embedding</span> {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">f</span> : A $-&gt; B) `{IsEmbedding f}
  : GroupIsomorphism A (ab_image_embedding f)
  := grp_image_in_embedding f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** The cokernel of a homomorphism into an abelian group. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ab_cokernel</span> {<span class="nv">G</span> : Group@{u}} {<span class="nv">A</span> : AbGroup@{u}} (<span class="nv">f</span> : GroupHomomorphism G A)
  : AbGroup := QuotientAbGroup _ (grp_image f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ab_cokernel_embedding</span> {<span class="nv">G</span> : Group} {<span class="nv">A</span> : AbGroup} (<span class="nv">f</span> : G $-&gt; A) `{IsEmbedding f}
  : AbGroup := QuotientAbGroup _ (grp_image_embedding f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk50"><span class="kn">Definition</span> <span class="nf">ab_cokernel_embedding_rec</span> {<span class="nv">G</span>: Group} {<span class="nv">A</span> <span class="nv">B</span> : AbGroup} (<span class="nv">f</span> : G $-&gt; A) `{IsEmbedding f}
  (h : A $-&gt; B) (p : grp_homo_compose h f $== grp_homo_const)
  : ab_cokernel_embedding f $-&gt; B.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_homo_compose h f $== grp_homo_const</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_cokernel_embedding f $-&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk51"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_homo_compose h f $== grp_homo_const</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_cokernel_embedding f $-&gt; B</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk52">snrapply (grp_quotient_rec _ _ h).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_homo_compose h f $== grp_homo_const</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : A,
{|
  normalsubgroup_subgroup := grp_image_embedding f;
  normalsubgroup_isnormal :=
    isnormal_ab_subgroup A (grp_image_embedding f)
|} n -&gt; h n = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk53"><span class="nb">intros</span> a [g q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_homo_compose h f $== grp_homo_const</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>f g = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h a = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk54"><span class="nb">induction</span> q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>G</var><span class="hyp-type"><b>: </b><span>Group</span></span></span><br><span><var>A, B</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>G $-&gt; A</span></span></span><br><span><var>IsEmbedding0</var><span class="hyp-type"><b>: </b><span>IsEmbedding f</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A $-&gt; B</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>grp_homo_compose h f $== grp_homo_const</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>G</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h (f g) = mon_unit</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (p g).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** ** Finite Sums *)</span>

<span class="sd">(** Indexed finite sum of abelian group elements. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk55"><span class="kn">Definition</span> <span class="nf">ab_sum</span> {<span class="nv">A</span> : AbGroup} (<span class="nv">n</span> : nat) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span>, (k &lt; n)%nat -&gt; A) : A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk56"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk57"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; <span class="mi">0</span>)%nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk58" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A) -&gt; A</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk58"><hr></label><div class="goal-conclusion">A</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk59">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; <span class="mi">0</span>)%nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> zero.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk5a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A) -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk5b"><span class="nb">refine</span> (f n _ + IHn _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A) -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk5c"><span class="nb">intros</span> k Hk.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A) -&gt; A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>(k &lt; n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> (f k _).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If the function is constant in the range of a finite sum then the sum is equal to the constant times [n]. This is a group power in the underlying group. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk5d"><span class="kn">Definition</span> <span class="nf">ab_sum_const</span> {<span class="nv">A</span> : AbGroup} (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span>, (k &lt; n)%nat -&gt; A) (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">Hk</span>, f k Hk = a)
  : ab_sum n f = ab_mul n a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat), f k Hk = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n f = ab_mul n a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk5e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat), f k Hk = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n f = ab_mul n a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk5f"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn] <span class="kr">in</span> f, p |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; <span class="mi">0</span>)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; <span class="mi">0</span>)%nat), f k Hk = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum <span class="mi">0</span> f = ab_mul <span class="mi">0</span>%nat a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat), f k Hk = a</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A,
(<span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat), f k Hk = a) -&gt; ab_sum n f = ab_mul n a</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk60"><hr></label><div class="goal-conclusion">ab_sum n.+<span class="mi">1</span> f = ab_mul n.+<span class="mi">1</span>%nat a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk61">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; <span class="mi">0</span>)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; <span class="mi">0</span>)%nat), f k Hk = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum <span class="mi">0</span> f = ab_mul <span class="mi">0</span>%nat a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk62">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat), f k Hk = a</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A,
(<span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat), f k Hk = a) -&gt; ab_sum n f = ab_mul n a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n.+<span class="mi">1</span> f = ab_mul n.+<span class="mi">1</span>%nat a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk63">rhs_V nrapply (ap@{<span class="kt">Set</span> _} _ (int_nat_succ n)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat), f k Hk = a</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A,
(<span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat), f k Hk = a) -&gt; ab_sum n f = ab_mul n a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n.+<span class="mi">1</span> f = grp_pow a n.+<span class="mi">1</span>%int</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk64">rhs nrapply grp_pow_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat), f k Hk = a</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A,
(<span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat), f k Hk = a) -&gt; ab_sum n f = ab_mul n a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n.+<span class="mi">1</span> f = a + grp_pow a n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk65"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat), f k Hk = a</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A,
(<span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat), f k Hk = a) -&gt; ab_sum n f = ab_mul n a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f n (leq_refl n.+<span class="mi">1</span>) +
ab_sum n
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt;
   f k (lt_succ_r Hk)) = a + grp_pow a n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk66">f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat), f k Hk = a</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A,
(<span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat), f k Hk = a) -&gt; ab_sum n f = ab_mul n a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt;
   f k (lt_succ_r Hk)) = grp_pow a n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk67"><span class="nb">apply</span> IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat), f k Hk = a</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A,
(<span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat), f k Hk = a) -&gt; ab_sum n f = ab_mul n a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat),
f k (lt_succ_r Hk) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk68"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat), f k Hk = a</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A,
(<span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat), f k Hk = a) -&gt; ab_sum n f = ab_mul n a</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hk</var><span class="hyp-type"><b>: </b><span>(k &lt; n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f k (lt_succ_r Hk) = a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> p.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** If the function is zero in the range of a finite sum then the sum is zero. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk69"><span class="kn">Definition</span> <span class="nf">ab_sum_zero</span> {<span class="nv">A</span> : AbGroup} (<span class="nv">n</span> : nat)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span>, (k &lt; n)%nat -&gt; A) (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">Hk</span>, f k Hk = <span class="mi">0</span>)
  : ab_sum n f = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat), f k Hk = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n f = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk6a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat), f k Hk = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n f = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk6b">lhs nrapply (ab_sum_const _ <span class="mi">0</span> f p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat), f k Hk = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_mul n <span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> grp_pow_unit.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Finite sums distribute over addition. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk6c"><span class="kn">Definition</span> <span class="nf">ab_sum_plus</span> {<span class="nv">A</span> : AbGroup} (<span class="nv">n</span> : nat) (<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span>, (k &lt; n)%nat -&gt; A)
  : ab_sum n (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">Hk</span> =&gt; f k Hk + g k Hk)
    = ab_sum n (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">Hk</span> =&gt; f k Hk) + ab_sum n (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">Hk</span> =&gt; g k Hk).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk + g k Hk) =
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk) +
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; g k Hk)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk6d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk + g k Hk) =
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk) +
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; g k Hk)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk6e"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; <span class="mi">0</span>)%nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum <span class="mi">0</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; <span class="mi">0</span>)%nat) =&gt; f k Hk + g k Hk) =
ab_sum <span class="mi">0</span> (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; <span class="mi">0</span>)%nat) =&gt; f k Hk) +
ab_sum <span class="mi">0</span> (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; <span class="mi">0</span>)%nat) =&gt; g k Hk)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk6f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A,
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk + g k Hk) =
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk) +
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; g k Hk)</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk6f"><hr></label><div class="goal-conclusion">ab_sum n.+<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat) =&gt;
   f k Hk + g k Hk) =
ab_sum n.+<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat) =&gt; f k Hk) +
ab_sum n.+<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat) =&gt; g k Hk)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk70"><span class="mi">1</span>: <span class="bp">by</span> <span class="nb">rewrite</span> grp_unit_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A,
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk + g k Hk) =
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk) +
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; g k Hk)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n.+<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat) =&gt;
   f k Hk + g k Hk) =
ab_sum n.+<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat) =&gt; f k Hk) +
ab_sum n.+<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat) =&gt; g k Hk)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk71"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A,
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk + g k Hk) =
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk) +
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; g k Hk)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f n (leq_refl n.+<span class="mi">1</span>) + g n (leq_refl n.+<span class="mi">1</span>) +
ab_sum n
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt;
   f k (lt_succ_r Hk) + g k (lt_succ_r Hk)) =
f n (leq_refl n.+<span class="mi">1</span>) +
ab_sum n
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt;
   f k (lt_succ_r Hk)) +
(g n (leq_refl n.+<span class="mi">1</span>) +
 ab_sum n
   (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt;
    g k (lt_succ_r Hk)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk72"><span class="nb">rewrite</span> &lt;- !grp_assoc; f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A,
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk + g k Hk) =
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk) +
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; g k Hk)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g n (leq_refl n.+<span class="mi">1</span>) +
ab_sum n
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt;
   f k (lt_succ_r Hk) + g k (lt_succ_r Hk)) =
ab_sum n
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt;
   f k (lt_succ_r Hk)) +
(g n (leq_refl n.+<span class="mi">1</span>) +
 ab_sum n
   (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt;
    g k (lt_succ_r Hk)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk73"><span class="nb">rewrite</span> IHn, ab_comm, &lt;- grp_assoc; f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A,
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk + g k Hk) =
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; f k Hk) +
ab_sum n (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt; g k Hk)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt;
   g k (lt_succ_r Hk)) + g n (leq_refl n.+<span class="mi">1</span>) =
g n (leq_refl n.+<span class="mi">1</span>) +
ab_sum n
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt;
   g k (lt_succ_r Hk))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> ab_comm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Double finite sums commute. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk74"><span class="kn">Definition</span> <span class="nf">ab_sum_sum</span> {<span class="nv">A</span> : AbGroup} (<span class="nv">m</span> <span class="nv">n</span> : nat)
  (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span>, (i &lt; m)%nat -&gt; (j &lt; n)%nat -&gt; A)
  : ab_sum m (<span class="kr">fun</span> <span class="nv">i</span> <span class="nv">Hi</span> =&gt; ab_sum n (<span class="kr">fun</span> <span class="nv">j</span> <span class="nv">Hj</span> =&gt; f i j Hi Hj))
   = ab_sum n (<span class="kr">fun</span> <span class="nv">j</span> <span class="nv">Hj</span> =&gt; ab_sum m (<span class="kr">fun</span> <span class="nv">i</span> <span class="nv">Hi</span> =&gt; f i j Hi Hj)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : nat, (i &lt; m)%nat -&gt; (j &lt; n)%nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum m
  (<span class="kr">fun</span> (<span class="nv">i</span> : nat) (<span class="nv">Hi</span> : (i &lt; m)%nat) =&gt;
   ab_sum n
     (<span class="kr">fun</span> (<span class="nv">j</span> : nat) (<span class="nv">Hj</span> : (j &lt; n)%nat) =&gt; f i j Hi Hj)) =
ab_sum n
  (<span class="kr">fun</span> (<span class="nv">j</span> : nat) (<span class="nv">Hj</span> : (j &lt; n)%nat) =&gt;
   ab_sum m
     (<span class="kr">fun</span> (<span class="nv">i</span> : nat) (<span class="nv">Hi</span> : (i &lt; m)%nat) =&gt; f i j Hi Hj))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk75"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : nat, (i &lt; m)%nat -&gt; (j &lt; n)%nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum m
  (<span class="kr">fun</span> (<span class="nv">i</span> : nat) (<span class="nv">Hi</span> : (i &lt; m)%nat) =&gt;
   ab_sum n
     (<span class="kr">fun</span> (<span class="nv">j</span> : nat) (<span class="nv">Hj</span> : (j &lt; n)%nat) =&gt; f i j Hi Hj)) =
ab_sum n
  (<span class="kr">fun</span> (<span class="nv">j</span> : nat) (<span class="nv">Hj</span> : (j &lt; n)%nat) =&gt;
   ab_sum m
     (<span class="kr">fun</span> (<span class="nv">i</span> : nat) (<span class="nv">Hi</span> : (i &lt; m)%nat) =&gt; f i j Hi Hj))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk76"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn] <span class="kr">in</span> m, f |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : nat, (i &lt; m)%nat -&gt; (j &lt; <span class="mi">0</span>)%nat -&gt; A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum m
  (<span class="kr">fun</span> (<span class="nv">i</span> : nat) (<span class="nv">Hi</span> : (i &lt; m)%nat) =&gt;
   ab_sum <span class="mi">0</span>
     (<span class="kr">fun</span> (<span class="nv">j</span> : nat) (<span class="nv">Hj</span> : (j &lt; <span class="mi">0</span>)%nat) =&gt; f i j Hi Hj)) =
ab_sum <span class="mi">0</span>
  (<span class="kr">fun</span> (<span class="nv">j</span> : nat) (<span class="nv">Hj</span> : (j &lt; <span class="mi">0</span>)%nat) =&gt;
   ab_sum m
     (<span class="kr">fun</span> (<span class="nv">i</span> : nat) (<span class="nv">Hi</span> : (i &lt; m)%nat) =&gt; f i j Hi Hj))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk77" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : nat,
(i &lt; m)%nat -&gt; (j &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : nat, (i &lt; m)%nat -&gt; (j &lt; n)%nat -&gt; A),
ab_sum m
(<span class="kr">fun</span> (<span class="nv">i</span> : nat) (<span class="nv">Hi</span> : (i &lt; m)%nat) =&gt;
ab_sum n (<span class="kr">fun</span> (<span class="nv">j</span> : nat) (<span class="nv">Hj</span> : (j &lt; n)%nat) =&gt; f i j Hi Hj)) =
ab_sum n
(<span class="kr">fun</span> (<span class="nv">j</span> : nat) (<span class="nv">Hj</span> : (j &lt; n)%nat) =&gt;
ab_sum m (<span class="kr">fun</span> (<span class="nv">i</span> : nat) (<span class="nv">Hi</span> : (i &lt; m)%nat) =&gt; f i j Hi Hj))</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk77"><hr></label><div class="goal-conclusion">ab_sum m
  (<span class="kr">fun</span> (<span class="nv">i</span> : nat) (<span class="nv">Hi</span> : (i &lt; m)%nat) =&gt;
   ab_sum n.+<span class="mi">1</span>
     (<span class="kr">fun</span> (<span class="nv">j</span> : nat) (<span class="nv">Hj</span> : (j &lt; n.+<span class="mi">1</span>)%nat) =&gt;
      f i j Hi Hj)) =
ab_sum n.+<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">j</span> : nat) (<span class="nv">Hj</span> : (j &lt; n.+<span class="mi">1</span>)%nat) =&gt;
   ab_sum m
     (<span class="kr">fun</span> (<span class="nv">i</span> : nat) (<span class="nv">Hi</span> : (i &lt; m)%nat) =&gt; f i j Hi Hj))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk78"><span class="mi">1</span>: <span class="bp">by</span> nrapply ab_sum_zero.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : nat,
(i &lt; m)%nat -&gt; (j &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">i</span> <span class="nv">j</span> : nat, (i &lt; m)%nat -&gt; (j &lt; n)%nat -&gt; A),
ab_sum m
(<span class="kr">fun</span> (<span class="nv">i</span> : nat) (<span class="nv">Hi</span> : (i &lt; m)%nat) =&gt;
ab_sum n (<span class="kr">fun</span> (<span class="nv">j</span> : nat) (<span class="nv">Hj</span> : (j &lt; n)%nat) =&gt; f i j Hi Hj)) =
ab_sum n
(<span class="kr">fun</span> (<span class="nv">j</span> : nat) (<span class="nv">Hj</span> : (j &lt; n)%nat) =&gt;
ab_sum m (<span class="kr">fun</span> (<span class="nv">i</span> : nat) (<span class="nv">Hi</span> : (i &lt; m)%nat) =&gt; f i j Hi Hj))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum m
  (<span class="kr">fun</span> (<span class="nv">i</span> : nat) (<span class="nv">Hi</span> : (i &lt; m)%nat) =&gt;
   ab_sum n.+<span class="mi">1</span>
     (<span class="kr">fun</span> (<span class="nv">j</span> : nat) (<span class="nv">Hj</span> : (j &lt; n.+<span class="mi">1</span>)%nat) =&gt;
      f i j Hi Hj)) =
ab_sum n.+<span class="mi">1</span>
  (<span class="kr">fun</span> (<span class="nv">j</span> : nat) (<span class="nv">Hj</span> : (j &lt; n.+<span class="mi">1</span>)%nat) =&gt;
   ab_sum m
     (<span class="kr">fun</span> (<span class="nv">i</span> : nat) (<span class="nv">Hi</span> : (i &lt; m)%nat) =&gt; f i j Hi Hj))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">lhs nrapply ab_sum_plus; <span class="nb">cbn</span>; f_ap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Finite sums are equal if the functions are equal in the range. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk79"><span class="kn">Definition</span> <span class="nf">path_ab_sum</span> {<span class="nv">A</span> : AbGroup} {<span class="nv">n</span> : nat} {<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span>, (k &lt; n)%nat -&gt; A}
  (<span class="nv">p</span> : <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">Hk</span>, f k Hk = g k Hk)
  : ab_sum n f = ab_sum n g.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat),
f k Hk = g k Hk</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n f = ab_sum n g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk7a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat),
f k Hk = g k Hk</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n f = ab_sum n g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk7b"><span class="nb">induction</span> n <span class="kr">as</span> [|n IHn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; <span class="mi">0</span>)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; <span class="mi">0</span>)%nat),
f k Hk = g k Hk</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum <span class="mi">0</span> f = ab_sum <span class="mi">0</span> g</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abeliangroup-v-chk7c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat),
f k Hk = g k Hk</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A,
(<span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat), f k Hk = g k Hk) -&gt;
ab_sum n f = ab_sum n g</span></span></span><br></div><label class="goal-separator" for="abeliangroup-v-chk7c"><hr></label><div class="goal-conclusion">ab_sum n.+<span class="mi">1</span> f = ab_sum n.+<span class="mi">1</span> g</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk7d"><span class="mi">1</span>: <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat),
f k Hk = g k Hk</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A,
(<span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat), f k Hk = g k Hk) -&gt;
ab_sum n f = ab_sum n g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ab_sum n.+<span class="mi">1</span> f = ab_sum n.+<span class="mi">1</span> g</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abeliangroup-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="abeliangroup-v-chk7e"><span class="nb">cbn</span>; f_ap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span>AbGroup</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n.+<span class="mi">1</span>)%nat),
f k Hk = g k Hk</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A,
(<span class="kr">forall</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat), f k Hk = g k Hk) -&gt;
ab_sum n f = ab_sum n g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nat_rect
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   (<span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A) -&gt; A)
  (<span class="kr">fun</span> <span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; <span class="mi">0</span>)%nat -&gt; A =&gt; <span class="mi">0</span>)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">IHn</span> : (<span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A) -&gt; A)
     (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A) =&gt;
   f n (leq_refl n.+<span class="mi">1</span>) +
   IHn
     (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt;
      f k (lt_succ_r Hk))) n
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt;
   f k (lt_succ_r Hk)) =
nat_rect
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   (<span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A) -&gt; A)
  (<span class="kr">fun</span> <span class="nv">_</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; <span class="mi">0</span>)%nat -&gt; A =&gt; <span class="mi">0</span>)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">IHn</span> : (<span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n)%nat -&gt; A) -&gt; A)
     (<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">k</span> : nat, (k &lt; n.+<span class="mi">1</span>)%nat -&gt; A) =&gt;
   f n (leq_refl n.+<span class="mi">1</span>) +
   IHn
     (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt;
      f k (lt_succ_r Hk))) n
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">Hk</span> : (k &lt; n)%nat) =&gt;
   g k (lt_succ_r Hk))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre>
</div>
</div></body>
</html>
